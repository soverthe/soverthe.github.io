<!DOCTYPE html>
<html lang="en-US">
<head>
<title id="titleId">Sover the Page</title>
	<link rel="icon" href="Pictures/icon.png" type="image/x-icon"> 
<meta charset="UTF-8">
<style>
	
	html, body { height: 100%; margin: 0; }
	body {
		overflow: hidden;
		background-color: #444444;
	}
	
	canvas {
		position: absolute;
		top: 0;
		left: 0;
	}
	
</style>
</head>
<body>
	<div style="position: relative;">
		<canvas id="canvasId"></canvas>
		<canvas id="notesCanvasId"></canvas>
	</div>
	<section id="imagesId" hidden></section>
<script> //Variables
	
	//if you're using notepad++, press Alt+3 to collapse all of the scripts
	
	//Canvas
	var canvas = document.getElementById("canvasId");
	var ctx = canvas.getContext("2d");
	canvas.oncontextmenu = function(){return false;}
	canvas.height = window.innerHeight; //969
	canvas.width = window.innerWidth; //1920
	
	var browserName = "Other";
	
	//Default Variables
	var hasInitiated = false;
	
	var defaultVariables = {};
	
	for (let i in window){
		if (window[i] != undefined && window[i] != null){
			defaultVariables[i] = true;
		}
	}
	
	
	//FPS
	var fps = 60;
	
	
	//Directions
	var xyArr = ["x", "y"];
	var whArr = ["w", "h"];
	var xywhArr = ["x", "y", "w", "h"];
	var xyToWH = {x: "w", y: "h"};
	var whToXY = {w: "x", h: "y"};
	var xywhInverse = {x: "y", y: "x", w: "h", h: "w"};
	
	var directions = [{x: 0, y: -1}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}];
	var directionsInverse = [{x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0}];
	var directionNumsInverse = [2,3,0,1];
	
	
	//Keyboard / Gamepad
	var keyboardAxes = {
		x: {negative: ["KeyA","ArrowLeft"], positive: ["KeyD","ArrowRight"]},
		y: {negative: ["KeyW","ArrowUp"], positive: ["KeyS","ArrowDown"]}
	};
	
	var gamepadDpadAxes = {
		x: {negative: [14], positive: [15]},
		y: {negative: [12], positive: [13]}
	}
	
	var gamepads = navigator.getGamepads();
	var gamepadAxisRange = {min: 0.05, max: 0.75};
	
	
	var inputButtons = {
		/*ex: keyboardRotateRight: {keyboard: ["KeyY"], gamepads: [[0],[0],[0],[0]], timer: 0, maxTimer: 12, disableHold: true, onclick: {f: "onRotateRight"},
		condition: "rules[keyboardMovement] == true"*/
	}
	inputButtonStates = {};
	
	//Mouse
	var mousePos = {x: 0, y: 0};
	var mousePosRatio = {x: 0, y: 0};
	var scaledMousePos = {x: 0, y: 0};
	
	var lastMousePos = {x: 0, y: 0};
	var lastMousePosRatio = {x: 0, y: 0};
	var lastScaledMousePos = {x: 0, y: 0};
	
	var isMouseDown = false;
	var mouseButton = -1;
	
	var wasEmptyMouseDown = false;
	
	var mouseMoveEvent;
	
	//Camera
	var camera = {x: 0, y: 0, speed: 16, zoom: {level: 1, min: 0.02, max: 2, speed: 1, scrollSpeed: 0.9, scrollbarSpeed: 0.0005, defaultTextLevel: 0.2},
				  areDimentionsEqual: true, minWidthToHeightRatio: 2, state: {canMove: false, canZoom: false, shouldLockMouse: false}};
	
	var mouseLockFrames = 0;
	
	//Images
	var images = {};
	
	//Entities
	var entities = [];
	
	var attacks = {};
	
	var bullets = {};
	
	
	//Buttons
	var gameState = {currentState: "menu", states: ["menu", "game"]};
	
	var buttons = {
		//ex: {menu: [{pos: {x: 0.5, y: 0.5, w: 0.2, h: 0.1}, text: "Text", textSize: 0.2, onclick: {f: "funcName", args: 12}}]};
	};
	
	
	var hoveredButtons = {gameState: "", arr: [], maxSeconds: 0.25, maxAlphaNum: 0.3, clickMultiplier: 1.25, releaseMultiplier: 2};
	
	var clickedButton = {i: "", j: 0};
	
	var closestButton = {i: "", j: 0, distance: -1};
	
	var valueReplacedButtons = {};
	var previousButtonsText = "";
	
	//Scrollbars
	var scrollbarsArr = {
		//ex: {menu: {x: {start: -4, end: 4}, y: {start: -2, end: 4}}};
	};
	
	var scrollbarsSize = {w: 0.012, h: 0.02};
	var scrollbarsMinSize = {x: {w: 0.01}, y: {h: 0.02}};
	var scrollbarMargin = {x: 0.0025, y: 0.004};
	var scrollbarStep = {x: 0.025, y: 0.025};
	
	var hoveredScrollbars = {gameState: "", arr: {}, maxSeconds: 0.25, maxAlphaNum: 0.5, clickMultiplier: 1.75, releaseMultiplier: 2};
	
	var clickedScrollbar = {xy: "", clickedPos: {x: 0, y: 0}};
	
	var scrolledCamera = structuredClone(camera);
	var scrolledCameras = {};
	
	
	//Grid
	var gridNames = [];
	
	var clickedGridTile = {gridName: "", layer: "", pos: {x: -1, y: -1}, isDown: false, mouseButton: -1, lastOnDownPos: {x: -1, y: -1}};
	
	
	//Polygons Editing
	var shouldEditPolygons = false;
	var shouldClickPolygons = false;
	var disablePolygonEditMovement = false;
	
	var isCurveSymmetryDefault = true;
	
	var savedPolygons = {};
	var clickedPolygonVertex = {i: -1, layer: "", j: -1, type: ""};
	var clickedPolygons = [];
	
	//Fonts
	var defaultFont = "Consolas";
	
	const cursefont = new FontFace('Cursefont', 'url(Cursefont.ttf)');
	
	cursefont.load().then((font) => {
		document.fonts.add(font);
		
		defaultFont = "Cursefont";
		originalVariableValues["defaultFont"] = "Cursefont";
	});
	
	
	//Events
	var events = {};
	
	var delayedEvents = [];
	
	
	//Colors
	var colors = {
		white: "#ffffff",
		black: "#000000",
		
		backgroundColor: "#646464",
		
		ace: ["#000000", "#a3a3a3", "#ffffff", "#880088"],
		pan: ["#ff218c", "#ffd800", "#21b1ff"],
		aro: ["#3da542", "#a7d379", "#ffffff", "#a9a9a9", "#000000"],
		aroace: ["#e28c00", "#eccd00", "#ffffff", "#62aedc", "#203856"],
		bi: ["#d60270", "#9b4f96", "#0038a8"],
		poly: ["#f61cb9", "#07d569", "#1c92f6"],
		omni: ["#ff9bcd", "#ff53be", "#250046", "#675fff", "#8ca5ff"],
		enby: ["#fff433", "#ffffff", "#9b59d0", "#2d2d2d"],
		trans: ["#5bcefa", "#f5a9b8", "#ffffff", "#f5a9b8", "#5bcefa"],
		agender: ["#000000", "#b9b9b9", "#ffffff", "#b8f483", "#ffffff", "#b9b9b9", "#000000"],
		demiboy: ["#7f7f7f", "#c4c4c4", "#9ad9eb", "#ffffff", "#9ad9eb", "#c4c4c4", "#7f7f7f"],
		demigirl: ["#7f7f7f", "#c4c4c4", "#ffaec9", "#ffffff", "#ffaec9", "#c4c4c4", "#7f7f7f"],
		genderfluid: ["#ff75a2", "#f5f5f5", "#be18d6", "#2c2c2c", "#333ebd"],
		genderqueer: ["#b57edc", "#ffffff", "#4a8123"],
		lesbian: ["#d52d00","#ef7627","#ff9a56","#ffffff","#d162a4","#b55690","#a30262"],
		lesbianFiveStripes: ["#d52d00","#ff9a56","#ffffff","#d162a4","#a30262"],
		mlm: ["#078d70","#26ceaa","#98e8c1","#ffffff","#7bade2","#5049cc","#3d1a78"],
		mlmFiveStripes: ["#078d70","#98e8c1","#ffffff","#7bade2","#3d1a78"],
		pride: ["#e50000", "#ff8b00", "#ffee00", "#028121", "#004cff", "#770088"],
		
		defaultButton: "#ffffff",
		defaultButtonText: "#222222",
		defaultButtonOutline: "#000000",
		defaultButtonHover: "hsla(0, 100%, 100%, {{alphaNum}})",
		defaultGridHover: "hsla(0, 100%, 100%, {{alphaNum}})",
		
		defaultButtonLocked: "#777777",
		defaultButtonLockedText: "#222222",
		defaultButtonLockedOutline: "#000000",
		
		defaultButtonLockedTitle: "#ffffff",
		defaultButtonLockedTitleShadow: "#000000",
		defaultButtonTitle: "#0f0f0f",
		defaultButtonTitleShadow: "#ffffff",
		
		defaultButtonBorder: "#000000",
		
		defaultPolygonFillColor: "#000000",
		defaultPolygonStrokeColor: "#000000",
		
		scrollbar: "#ffffffaa",
		scrollbarBackground: "#ffffff33",
		scrollbarHover: "hsla(0, 100%, 100%, {{alphaNum}})",
		
		
		debugText: "#000000"
	}
	
	//Default Values
	var defaultValues = {
		textMarginY: 0.165,
		
		buttonTextSize: 0.1,
		buttonTextMarginY: 0.165,
		buttonOutlineSize: 0.00015,
		buttonSubtextOutlineSize: 0.0001,
		buttonSubtextSize: 0.05,
		buttonSubtextPos: {x: 0.4, y: 0.3},
		
		textSpriteSize: {w: 0.65, h: 0.65},
		
		lockedButtonTitle: "",//"[Locked]",
		lockedButtonTitleSize: 0.075,
		lockedButtonTitleShadowOffset: {x: 0.00125, y: 0.00125},
		buttonTitleSize: 0.075,
		buttonTitleShadowOffset: {x: 0.00125, y: 0.00125},
		
		gridBorderSize: 0.002,
		gridHoverAlphaNum: 0.3,
		
		spriteCharacter: "ðŸ•´",
		channelIconPiece: "î€½",
		
		
		minGravityJumpRatio: 0.75, //How much gravity direction is needed for jumps
	}
	
	//Draw Order & Layers
	var drawOrder = ["drawGrids", "drawEntities", "drawButtons", "drawScrollbars"];
	var drawLayers = [];
	
	//
	var cancelNextDrawFrame = false;
	
	//Eval (technically not eval but it works like it)
	var shouldEvalText = true;
	
	//(this gets saved in initiateGame())
	var originalVariableValues = {};
	
	
</script>
<script src="CountriesData.js"></script>
<script> //Game Data Extras
	
	var gamePresets = {
		lockedCamera: {state: {canMove: false, canZoom: false, shouldLockMouse: false}},
		freeCamera: {state: {canMove: true, canZoom: true, shouldLockMouse: true}},
		zoomCamera: {state: {canMove: false, canZoom: true, shouldLockMouse: false}},
		
		textButton: {disableClick: true, color: "#00000000"},
		
		//channelIconPieceBackgroundText: {f: "addButtonToCurrentGameState", args: {pos: {x: 0, y: 0.03, w: 1, h: 1}, text: defaultValues.channelIconPiece,
		//								 textSize: 0.9, disableClick: true, outlineSize: 0.00075, textColor: "#616161", outlineColor: "#00000000", color: "#00000000"}},
		
		
		channelIconPieceBottomRight: {pos: {x: 1 - 0.075 + 0.01, y: 1 - 0.15 + 0.02, w: 0.075, h: 0.1525}, isAbsolutePositioned: true, text: defaultValues.channelIconPiece,
									  textSize: 1.79, outlineSize: 0.00075, textColor: colors.ace[1], outlineColor: "#00000000", color: "#32323200", textOffset: {y: 0.0095},
									  onclick: [{f: "loadGame", args: {gameName: "Game Selection"}}]},
		
		quitButton: {pos: {x: 0.9645, y: 0.0365, w: 0.04, h: 0.03}, isAbsolutePositioned: true,
					 text: "Quit", textSize: 0.3, color: "#ffffffAA", onclick: [{f: "loadGame", args: {gameName: "Game Selection"}}]},
	};
	
	//you can use the spread syntax, ex: {areDimentionsEqual: false, ...gamePresets["lockedCamera"]}
	
</script>
<script> //Sprites
	
	var gameSprites = {
		pigeon: {pos:{arr:{"footBack":[{x:0.012616769693028586,y:0.14869764281069403,front:{x:0.05962576540501737,y:0.14323777480102434},back:{x:-0.03351773766952966,y:0.15415751082036372}},{x:0.05992518863307804,y:0.34387150652699466,front:{x:0.0726752287677755,y:0.3668215787694501},back:{x:0.04781265050511546,y:0.32092143428453923}},{x:0.09753780703043552,y:0.4579843657325368,front:{x:0.0554626745859339,y:0.48475945001540144},back:{x:0.13897543746820226,y:0.4318467834564071}},{x:0.021250066891162434,y:0.4171488205233531,front:{x:0.00707415970763476,y:0.41592594813119166},back:{x:0.03662554657047962,y:0.41837169291551457}},{x:-0.070125220740836,y:0.46499688780662046,front:{x:-0.10200032107757964,y:0.43822180352375584},back:{x:-0.03697511639062262,y:0.49240947409622}},{x:-0.0166152786391805,y:0.33879029197262844,front:{x:-0.008327752551627154,y:0.3056401876224151},back:{x:-0.026177808740203593,y:0.37194039632284176}}],"base":[{x:0.20579645993413836,y:-0.4335995746432492,front:{x:0.3483955817782657,y:-0.4481835757409441},back:{x:0.06157689352360052,y:-0.41901557354555435}},{x:0.3808044731064765,y:-0.31044578759604835,front:{x:0.38404536223929764,y:-0.24238711580680578},back:{x:0.379184028540066,y:-0.3785044593852909}},{x:0.2958945489614123,y:-0.18593373684737396,front:{x:0.2505221011019173,y:-0.1745906248825002},back:{x:0.3428874413873179,y:-0.19727684881224772}},{x:0.2745688157029322,y:0.035320745709357775,front:{x:0.25656387607614844,y:0.11934379730101533},back:{x:0.2925737553297159,y:-0.05070285472972017}},{x:-0.06531005810409551,y:0.20725947010585413,front:{x:-0.23790685200394002,y:0.20668617480915866},back:{x:0.10595387746709395,y:0.2078327654025496}},{x:-0.47716328165849375,y:-0.1152922454286584,front:{x:-0.26510510383192953,y:-0.12129389197091965},back:{x:-0.46515998857397123,y:0.044751662364974965}},{x:0.024306668496158073,y:-0.15488310922063664,front:{x:0.056315450054884794,y:-0.21489957464324919},back:{x:-0.009702661909989033,y:-0.0968671926454445}}],"beak":[{x:0.3787973380899802,y:-0.34726125137211894,front:{x:0.512990532381967,y:-0.34506586169045045},back:{x:0.3803974474186986,y:-0.32119028570012303}},{x:0.376665763677906,y:-0.260741549829056,front:{x:0.3809711992247599,y:-0.2907814399788696},back:{x:0.518268398145524,y:-0.265132329192393}}],"footFront":[{x:-0.10868445892708911,y:0.18573687383808513,front:{x:-0.06048839506300693,y:0.1901998233300452},back:{x:-0.15808009528696082,y:0.18247349684191458}},{x:-0.06957520475579157,y:0.34975858308787977,front:{x:-0.057579479797896474,y:0.3773487504910385},back:{x:-0.08157092971368667,y:0.3209688431889316}},{x:-0.019507561406087115,y:0.47280628738912267,front:{x:-0.05182572384415061,y:0.4999320403005366},back:{x:0.011611028536186868,y:0.4456805344777089}},{x:-0.10546329494132467,y:0.43529008133228997,front:{x:-0.12225730988237782,y:0.4340905088365005},back:{x:-0.087469707504482,y:0.4364896538280794}},{x:-0.1907244785949506,y:0.47077387486278804,front:{x:-0.22517212212753962,y:0.4375902808476371},back:{x:-0.15548979554787407,y:0.5039574688779387}},{x:-0.14394869949474118,y:0.35575644556682734,front:{x:-0.1352912648353787,y:0.32348782547283994},back:{x:-0.15339317366859115,y:0.3872380261463273}}],"eye":[{x:0.26018727433674466,y:-0.353573993133958,front:{x:0.31330167873364684,y:-0.35601978816703994},back:{x:0.20707286993984247,y:-0.3522078133470866}},{x:0.26126688958295524,y:-0.27692131065300835,front:{x:0.20592661177719923,y:-0.27390238653860477},back:{x:0.3155275521425007,y:-0.27886061952120134}}],"pupil":[{x:0.2688241963064292,y:-0.3416982254256419,front:{x:0.3087699604162199,y:-0.3449370711642736},back:{x:0.22995804744284903,y:-0.3384593796870102}},{x:0.2709834267988503,y:-0.2833990021302717,front:{x:0.23103766268905962,y:-0.28016015639164},back:{x:0.31092919090864096,y:-0.2855582326226928}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"#666","beak":"#444","footBack":"#f80","footFront":"#f80","eye":"#f80","pupil":"#000000"},isFill:true,fillOutline:{"base":"#000","beak":"#000","footBack":"#000","footFront":"#000","eye":"#00000000","pupil":"#00000000"},isVisible:true},
		leafSheepSlug: {pos:{arr:{"base":[{x:0.30017473544516166,y:-0.27376168089518127,front:{x:0.34881865352383074,y:-0.2413324021760685},back:{x:0.2515308173664926,y:-0.304716901490698}},{x:0.142450516220386,y:0.04610893192515816,front:{x:0.14687269059117408,y:0.05790139691392643},back:{x:0.1395023999731939,y:0.034316466936389886}},{x:0.4151512690856522,y:-0.16615543787267073,front:{x:0.44905460592836105,y:-0.11308934542321353},back:{x:0.38124793224294334,y:-0.2177474721985319}},{x:0.15719109745634632,y:0.08885661750944315,front:{x:0.15866515557994235,y:0.10212314062180745},back:{x:0.15719109745634632,y:0.07559009439707884}},{x:0.4402102571867848,y:0.03284240881279385,front:{x:0.446106489681169,y:0.09033067563303918},back:{x:0.4343140246924006,y:-0.02317179988385544}},{x:0.15866515557994235,y:0.1596114074420528,front:{x:0.15866515557994235,y:0.17582604680160913},back:{x:0.15866515557994235,y:0.14192270995890038}},{x:0.403358804096884,y:0.2377364879926426,front:{x:0.40041068784969197,y:0.2686917085881593},back:{x:0.4077809784676721,y:0.20825532552072193}},{x:0.13360616747880977,y:0.2377364879926426,front:{x:0.12770993498442568,y:0.253951127352199},back:{x:0.1395023999731939,y:0.2200477905094902}},{x:0.22794588738895596,y:0.3320762079027888,front:{x:0.20583501553501543,y:0.35418707975672936},back:{x:0.24858270111930042,y:0.30996533604884824}},{x:-0.05639992465271902,y:0.23950535774095782,front:{x:-0.07556268025946747,y:0.23655724149376578},back:{x:-0.037237169045970575,y:0.24097941586455385}},{x:-0.37199576891462993,y:0.3276540335320007,front:{x:-0.3882104082741864,y:0.28932852231850387},back:{x:-0.35725518767866954,y:0.3659795447454975}},{x:-0.1523611084988208,y:0.2082553255207219,front:{x:-0.16415357348758905,y:0.19204068616116554},back:{x:-0.14056864351005258,y:0.22594402300387428}},{x:-0.4353802682292594,y:0.07264197814988677,front:{x:-0.4250618613640872,y:0.029894292565601784},back:{x:-0.4456986750944316,y:0.11686372185776782}},{x:-0.15383516662241686,y:0.11538966373417175,front:{x:-0.14793893412803275,y:0.10212314062180745},back:{x:-0.15973139911680098,y:0.12718212872294005}},{x:-0.37052171079103385,y:-0.2133252978277438,front:{x:-0.33661837394832506,y:-0.2383842859288764},back:{x:-0.4058991057573387,y:-0.1897403678502072}},{x:-0.0771841441954231,y:0.026946176318409717,front:{x:-0.06052728739878793,y:0.019870697325148762},back:{x:-0.09516765330329471,y:0.03402165531167069}},{x:-0.12730212039768826,y:-0.34156835458059875,front:{x:-0.06539167920665483,y:-0.3518867614457711},back:{x:-0.18773850346512566,y:-0.33124994771542643}},{x:0.008311226973146879,y:0.009257478835257307,front:{x:0.02688435933045691,y:0.013237435768966608},back:{x:-0.010261905384163151,y:0.00660417421278444}},{x:0.0923325400181208,y:-0.3459905289513869,front:{x:0.15424298120915425,y:-0.33714618020981074},back:{x:0.0289480407034913,y:-0.354834877692963}},{x:0.09085848189452479,y:0.02842023444200575,front:{x:0.10648349800464274,y:0.0344638727487495},back:{x:0.07656011809564327,y:0.022376596135262012}}],"base2":[{x:0.14539863246757803,y:-0.22806587906370412,front:{x:0.187273652468418,y:-0.21539590623476718},back:{x:0.10470491655565134,y:-0.24073585189264107}},{x:0.06432543566979618,y:0.09475285000382729,front:{x:0.07464384253496842,y:0.10654531499259556},back:{x:0.05548108692821998,y:0.08443444313865504}},{x:0.31957971042670563,y:-0.13034201183301083,front:{x:0.3573814412719306,y:-0.09490288916561238},back:{x:0.28177797958148065,y:-0.16696243858932258}},{x:0.11149529562486926,y:0.13160430309372814,front:{x:0.1203396443664455,y:0.1448708262060925},back:{x:0.10559906313048512,y:0.11833777998136384}},{x:0.3573814412719306,y:0.16025879403965662,front:{x:0.3609253535386705,y:0.1945166126181418},back:{x:0.3538375290051907,y:0.12481967137225822}},{x:0.09515879750169914,y:0.1961539381910347,front:{x:0.09368473937810312,y:0.2049982869326109},back:{x:0.0966328556252952,y:0.18878364757305452}},{x:0.2676023305145212,y:0.29492746017577076,front:{x:0.24855183726875357,y:0.3232730109619416},back:{x:0.2878341278492021,y:0.2665819093895999}},{x:-0.051093315407773295,y:0.19439917915891922,front:{x:-0.07910041975609794,y:0.19439917915891922},back:{x:-0.023086211059448643,y:0.1958732372825153}},{x:-0.3351443158247291,y:0.25395112735219894,front:{x:-0.3469367808134974,y:0.20235909302633776},back:{x:-0.3233518508359608,y:0.3070172198016562}},{x:-0.13440708055342115,y:0.18166331697104948,front:{x:-0.13293302242982513,y:0.16544867761149312},back:{x:-0.13440708055342115,y:0.19787795633060581}},{x:-0.35283301330788147,y:-0.04086049736700785,front:{x:-0.3307221414539409,y:-0.08360818295129285},back:{x:-0.37494388516182203,y:0.003361246340873175}},{x:-0.09487284167857549,y:0.10507125686899951,front:{x:-0.08160631856621119,y:0.09622690812742332},back:{x:-0.10813936479093979,y:0.11258895329933928}},{x:-0.20690125907187412,y:-0.2074290653333597,front:{x:-0.16267951536399308,y:-0.23838428592887645},back:{x:-0.24964894465615917,y:-0.17647384473784297}},{x:-0.0584375980255447,y:0.06811707510442058,front:{x:-0.047691714304529606,y:0.065729100944195},back:{x:-0.06798949466644699,y:0.07050504926464618}},{x:-0.04033269110552225,y:-0.2516508090412407,front:{x:0.005352822775772535,y:-0.26028546161347194},back:{x:-0.08601820498681703,y:-0.24183485238009628}},{x:0.0077154309535990995,y:0.06221055465985418,front:{x:0.016559779695175303,y:0.06515867090704625},back:{x:-0.0011289177879771038,y:0.06073649653625814}}],"base3":[{x:0.022885147411379016,y:-0.0874357180680507,front:{x:0.06473804249912328,y:-0.09286109335720275},back:{x:-0.01896774767636525,y:-0.08123528916616266}},{x:0.03296084437694708,y:0.16445670607115084,front:{x:0.04475330936571533,y:0.16445670607115084},back:{x:0.019694321264582773,y:0.16445670607115084}},{x:0.1527689230855582,y:-0.04380861361419991,front:{x:0.19262188860056406,y:-0.020781107372754307},back:{x:0.11291595757055234,y:-0.06761117346838152}},{x:0.0702216681641803,y:0.17730010492520518,front:{x:0.07169572628777633,y:0.18909256991397344},back:{x:0.0702216681641803,y:0.1655076399364369}},{x:0.2809780004524686,y:0.0784257550574543,front:{x:0.30345455522181275,y:0.11562832846878254},back:{x:0.2577263920703885,y:0.040448128033390075}},{x:0.06241288166091526,y:0.2241358342518232,front:{x:0.05892918556859663,y:0.23571552356193845},back:{x:0.0666716313659699,y:0.21255614494170796}},{x:0.20889801446802017,y:0.24583733540843133,front:{x:0.20579780001707612,y:0.2791646407560795},back:{x:0.21199822891896422,y:0.21173497644804712}},{x:0.05913225519746117,y:0.2703395434239461,front:{x:0.05739142203465672,y:0.2764324594937617},back:{x:0.060873088360265615,y:0.26511704393553276}},{x:0.13360616747880977,y:0.3335502660263848,front:{x:0.1055990631304851,y:0.37482389348707373},back:{x:0.16161327182713445,y:0.2908025804420999}},{x:-0.051093315407773295,y:0.21297231151622922,front:{x:-0.07762636163250192,y:0.21297231151622922},back:{x:-0.02456026918304468,y:0.21444636963982525}},{x:-0.25201480794453074,y:0.33544885288957654,front:{x:-0.2724319870144594,y:0.30213661335442976},back:{x:-0.23159762887460209,y:0.3698356807968249}},{x:-0.16267951536399305,y:0.2627954760937752,front:{x:-0.16575882278418513,y:0.2513936365077598},back:{x:-0.15852561957169947,y:0.27312272730768905}},{x:-0.2885508125959821,y:0.2645260203308769,front:{x:-0.2949983428285911,y:0.2279900156794256},back:{x:-0.2810286939912715,y:0.3010620249823284}},{x:-0.16415357348758908,y:0.22152184863308622,front:{x:-0.1708561157755802,y:0.21075532809834074},back:{x:-0.15637644282749646,y:0.2322883691678317}},{x:-0.3164901102706213,y:0.1291278854460868,front:{x:-0.30585168538681634,y:0.10494964707380286},back:{x:-0.3280956646893176,y:0.1542732533532621}},{x:-0.14056864351005255,y:0.17582604680160915,front:{x:-0.13614646913926443,y:0.1655076399364369},back:{x:-0.14351675975724462,y:0.1861444536667814}},{x:-0.2763716641728007,y:0.011728085828116998,front:{x:-0.2445083489825427,y:-0.019274058681323196},back:{x:-0.30909615004387647,y:0.04273023033755719}},{x:-0.10703027019222305,y:0.1685008033998861,front:{x:-0.10311339557591305,y:0.1669340535533621},back:{x:-0.11094714480853306,y:0.17085092816967212}},{x:-0.1811994342230413,y:-0.06709195129964873,front:{x:-0.13944552592277312,y:-0.08041717701938582},back:{x:-0.22381451320412724,y:-0.05376672557991165}},{x:-0.03214365909287732,y:0.19313368974238304,front:{x:0.014289171800397762,y:0.19180703743114663},back:{x:-0.07990314229738879,y:0.19446034205361945}}],"head":[{x:-0.12800730980401662,y:0.1282682147484056,front:{x:-0.09245302786288027,y:0.10531712976401536},back:{x:-0.16356159174515297,y:0.15360727389302142}},{x:0.0351390848225947,y:0.1291278854460868,front:{x:0.06756836354170745,y:0.14681658292923921},back:{x:0.0012357479798859317,y:0.1114391879629344}},{x:0.0656520879810326,y:0.3270644102825622,front:{x:0.04427824518889012,y:0.34298423801739947},back:{x:0.08702593077317508,y:0.31247123485896144}},{x:-0.1850851988426528,y:0.323084453348853,front:{x:-0.20410054863704163,y:0.30775424886345426},back:{x:-0.16606984904826394,y:0.3397413101454882}}],"leftEye":[{x:-0.060924263373933224,y:0.15920972975791722,front:{x:-0.045837255960353235,y:0.1579953923355038},back:{x:-0.07601127078751321,y:0.16031936892992535}},{x:-0.06166763142163596,y:0.18910647744344133,front:{x:-0.07487338926245822,y:0.188406480645969},back:{x:-0.0484618735808137,y:0.18970177599050836}}],"rightEye":[{x:-0.04030330445711251,y:0.1591282931658931,front:{x:-0.026363381384965766,y:0.16029875384442058},back:{x:-0.05424322752925925,y:0.1578531342369603}},{x:-0.04151940463818449,y:0.18904435762026353,front:{x:-0.05636133314018729,y:0.18983552853788896},back:{x:-0.02667747613618169,y:0.1883578849530434}}],"leftBlush":[{x:-0.16076978992799623,y:0.29344910366017507,front:{x:-0.14525896644740866,y:0.2962692533839183},back:{x:-0.1769856508395196,y:0.29062895393643184}},{x:-0.16358993965173946,y:0.31742037631199227,front:{x:-0.17698565083951967,y:0.31460022658824904},back:{x:-0.15019422846395925,y:0.31953548860479974}}],"rightBlush":[{x:0.044999693709932134,y:0.2955872563725991,front:{x:0.06023981858915541,y:0.2931158847705629},back:{x:0.029759568830708856,y:0.29764673270762926}},{x:0.04747106531196833,y:0.3207128676599672,front:{x:0.033466626233763154,y:0.3231842392620034},back:{x:0.06147550439017351,y:0.318653391324937}}],"leftEar":[{x:-0.29392375445648966,y:0.1151582366087672,front:{x:-0.2659844567818504,y:0.1151582366087672},back:{x:-0.3207884637590275,y:0.1151582366087672}},{x:-0.17733091608347587,y:0.13697238056242783,front:{x:-0.142514252827387,y:0.13600525102753647},back:{x:-0.21021332026978207,y:0.1379395100973192}},{x:-0.12579993335358058,y:0.1573768794895657,front:{x:-0.13087620285631835,y:0.19354529969657225},back:{x:-0.12072366385084282,y:0.12184299297040137}},{x:-0.19183785910684625,y:0.17952608009764756,front:{x:-0.22131902157876698,y:0.17657796385045552},back:{x:-0.16383075475852163,y:0.1824741963448396}},{x:-0.2906999893401851,y:0.15599259474862454,front:{x:-0.32018115181210577,y:0.1530444785014325},back:{x:-0.2626928849918605,y:0.16041476911941266}},{x:-0.382756393216881,y:0.13204652053080695,front:{x:-0.38717856758766905,y:0.11877999741844264},back:{x:-0.37980827696968894,y:0.14531304364317127}}],"rightEar":[{x:0.3037193145714856,y:0.12497997432977499,front:{x:0.30284431529078293,y:0.13703692322921018},back:{x:0.3052993512831241,y:0.11292302543033982}},{x:0.22700079708669374,y:0.14405167204487906,front:{x:0.20098491588516273,y:0.14976247523545905},back:{x:0.25238214460038255,y:0.13834086885429908}},{x:0.12618044446287435,y:0.1757078526938965,front:{x:0.09184512157630088,y:0.18212369331541228},back:{x:0.15988123366160556,y:0.1692920120723807}},{x:0.034102555982658864,y:0.15610781211388125,front:{x:0.025853618040710007,y:0.1199393919068747},back:{x:0.04235149392460773,y:0.19291076600873003}},{x:0.08803791944924756,y:0.13199553197587688,front:{x:0.11595740171430524,y:0.12882286353666578},back:{x:0.0607529708720321,y:0.13516820041508798}},{x:0.21667765643126338,y:0.11018289244593721,front:{x:0.2420590039449522,y:0.10806778015312982},back:{x:0.19129630891757457,y:0.11300304216968039}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"#080","base2":"#0b0","base3":"#0d0","head":"#fff","rightBlush":"#f08","leftBlush":"#f08","rightEar":"#006","leftEar":"#006"},isFill:true,fillOutline:false,isVisible:true},
		
		happyBlob: {pos:{arr:{"base":[{x:-0.28007683863885846,y:-0.29780735455543356,front:{x:-0.11803238199780464,y:-0.4338446761800219},back:{x:-0.4421212952799123,y:-0.1637705817782657}},{x:0.17824890230515922,y:-0.3716276070252468,front:{x:0.3096849615806807,y:-0.3284157519209657},back:{x:0.04861333699231615,y:-0.4130389681668494}},{x:0.4281174533479693,y:-0.08174807903402842,front:{x:0.4605263446761801,y:0.07309440175631193},back:{x:0.3939080680570802,y:-0.23298957189901198}},{x:0.19805433589462135,y:0.38638035126234926,front:{x:0.0800219538968167,y:0.42639132821075765},back:{x:0.31808726673984644,y:0.3463693743139409}},{x:-0.31808726673984633,y:0.2683479692645447,front:{x:-0.38890669593852917,y:0.18992645444566442},back:{x:-0.2472678375411635,y:0.34276838638858403}}],"n":[{x:-0.2232612513721186,y:-0.12495993413830933,front:{x:-0.16744593852908896,y:-0.23118907793633348},back:{x:-0.2772760702524699,y:-0.018730790340285172}},{x:-0.032408891328210766,y:-0.11595746432491745,front:{x:0.027007409440175725,y:-0.006127332601536528},back:{x:-0.0918251920965972,y:-0.22398710208562}},{x:-0.14043852908891333,y:0.020880076838639103,front:{x:-0.2880790340285401,y:0.022680570801317444},back:{x:0.007201975850713499,y:0.01727908891328234}}],"m":[{x:0.21785976948408348,y:-0.2077826564215146,front:{x:0.268273600439078,y:-0.21318413830954974},back:{x:0.16924643249176735,y:-0.20238117453347948}},{x:0.3204879253567509,y:-0.009728320526893286,front:{x:0.2862785400658618,y:0.035284028540066126},back:{x:0.35469731064764004,y:-0.05654116355653108}},{x:0.11523161361141605,y:-0.004326838638858162,front:{x:0.07382025246981341,y:-0.0529401756311743},back:{x:0.15484248079034033,y:0.042486004390779604}}],"mouth":[{x:-0.05581531284302965,y:0.14511416026344706,front:{x:-0.04861333699231615,y:0.12710922063666333},back:{x:-0.06481778265642153,y:0.1631190998902308}},{x:0.14043852908891333,y:0.1415131723380903,front:{x:0.14403951701427006,y:0.1649195938529092},back:{x:0.1368375411635566,y:0.1199072447859498}},{x:0.03420938529088914,y:0.24774231613611447,front:{x:-0.010802963776070254,y:0.240540340285401},back:{x:0.07922173435784854,y:0.25674478594950634}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"#8f4","n":"#fa4","m":"#fa4","mouth":"#fff"},isFill:true,fillOutline:"#000",isVisible:true},
		happySlugThing: {pos:{arr:{"base":[{x:0.14130692134649858,y:-0.39383649595164233,front:{x:0.40799589193547736,y:-0.42892747074735055},back:{x:-0.12721857847681095,y:-0.3569500355222563}},{x:0.4427696124088891,y:-0.09455435858735646,front:{x:0.46649019924645097,y:0.10235286991059221},back:{x:0.41919942388198206,y:-0.28867398826871843}},{x:0.19695746795960178,y:0.3864044113531373,front:{x:-0.11485470830097455,y:0.4330001013985567},back:{x:0.505509067524909,y:0.34006179317764207}},{x:-0.45625300551464776,y:0.1739722090991518,front:{x:-0.5050281512251859,y:-0.03477844856785635},back:{x:-0.40747785980410967,y:0.38393042616512896}},{x:-0.054413578054124855,y:-0.05819779361594987,front:{x:0.008127881254361015,y:-0.1549523272616295},back:{x:-0.11820804478299186,y:0.038556740029729725}}],"mouth":[{x:0.33561220672441205,y:0.07505083800673494,front:{x:0.360163554606155,y:0.07265363344137614},back:{x:0.3110608588426689,y:0.07842616568525844}},{x:0.4516703422339423,y:0.09872316525431223,front:{x:0.45615504011037333,y:0.12396014039447094},back:{x:0.39339492600579584,y:0.09940602365478284}},{x:0.401754916368559,y:0.28809563995949306,front:{x:0.3740822280691607,y:0.27708183666328956},back:{x:0.45087555624233455,y:0.24434099429617884}},{x:0.3296491289415908,y:0.20264544021838138,front:{x:0.3095391333058439,y:0.14152206323353422},back:{x:0.348212201836126,y:0.26376881720322853}}],"eye":[{x:0.2553134690265242,y:-0.2679708956855548,front:{x:0.35631005459947196,y:-0.27629766932425387},back:{x:0.15330194744306747,y:-0.2596441220468558}},{x:0.37629790342097436,y:-0.11881899602119696,front:{x:0.3827137382389285,y:-0.055766718311882416},back:{x:0.36896359119750244,y:-0.17814516276618914}},{x:0.31114247779241166,y:-0.08122570102413108,front:{x:0.24131118093173054,y:-0.08572943514622501},back:{x:0.3794204672761141,y:-0.07727278330545874}},{x:0.2417344973276896,y:-0.10222275603044635,front:{x:0.23070331818245648,y:-0.1443385050996629},back:{x:0.2527656764729227,y:-0.06108513007439449}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"#555","eye":"#fff","mouth":"#fff"},isFill:true,fillOutline:"#000",isVisible:true},
		happyFeesh: {pos:{arr:{"base":[{x:0.47600307424608523,y:-0.0064704072776244625,front:{x:0.4740776979933303,y:0.284261406888355},back:{x:0.47985382675159505,y:-0.2972022214436041}},{x:-0.14396807914097032,y:0.18414184174510376,front:{x:-0.33072957565818895,y:-0.07385857612404353},back:{x:0.042793417376248324,y:0.44406763586700604}},{x:-0.4404760220652142,y:-0.2606200726412622,front:{x:-0.47898354712031077,y:-0.19130652754208818},back:{x:-0.4019684970101176,y:-0.32800824148768126}},{x:-0.4366252695597046,y:0.284261406888355,front:{x:-0.3846401107353241,y:0.3285450607017161},back:{x:-0.4886104283840851,y:0.24190312932774874}},{x:-0.134341197877196,y:-0.21633641882790108,front:{x:0.033166536112474235,y:-0.4627845791805194},back:{x:-0.30377430811962114,y:0.030111741524717323}}],"eye":[{x:0.24425645039252286,y:-0.19852399123820927,front:{x:0.3463494783915575,y:-0.19532940351384895},back:{x:0.13897301526851624,y:-0.20171857896256937}},{x:0.24541935378957414,y:-0.03899746134069934,front:{x:0.14651673291550749,y:-0.029413698167618935},back:{x:0.34432197466364056,y:-0.04538663678941959}}],"mouth":[{x:0.2514324425781187,y:0.06123267804733659,front:{x:0.23140877134498683,y:0.079277596652115},back:{x:0.270454930249594,y:0.043187759442558066}},{x:0.3735093895870001,y:0.18686506026414043,front:{x:0.4373496156381127,y:0.19894384821298985},back:{x:0.3113646766887881,y:0.1747862723152909}},{x:0.4262003434639082,y:0.08937372016887317,front:{x:0.36101362880918275,y:0.09706799156602677},back:{x:0.4928430197723186,y:0.08167944877171956}}],"eyeShine1":[{x:0.2232925025701229,y:-0.16965384202357445,front:{x:0.2600025664975312,y:-0.16965384202357445},back:{x:0.18547001246309636,y:-0.16965384202357445}},{x:0.2221290462564224,y:-0.1095041133409794,front:{x:0.17985685143092192,y:-0.10839022947648677},back:{x:0.2644012410819224,y:-0.1095041133409794}}],"eyeShine2":[{x:0.2790957443523696,y:-0.09497910904817719,front:{x:0.2985864139056815,y:-0.09535683063061146},back:{x:0.25960507479905726,y:-0.09487991904989301}},{x:0.2796108221503475,y:-0.06638954587899895,front:{x:0.2597550440933336,y:-0.06556414434615343},back:{x:0.29946660020736093,y:-0.06693641582769438}}]},"shape":"polygon"},lineWidth:{"base":0.04,"eye":0.04,"mouth":0.01,"eyeShine1":0.04,"eyeShine2":0.04},color:{"base":"#0a9dff","eye":"#000","eyeShine1":"#fff","eyeShine2":"#fff","mouth":"#000"},isFill:{"base":true,"eye":true,"mouth":true,"eyeShine1":true},fillOutline:{"base":"#000","eye":false,"eyeShine1":false,"eyeShine2":false},isVisible:true},
		
		//heartTest: {pos:{arr:{"base":[{x:-0.0008039750593715141,y:-0.31274629809551896,front:{x:0.052096800508604824,y:-0.6027602698802752},back:{x:-0.050775021645242835,y:-0.6027602698802752}},{x:0.001361538822624454,y:0.47517704909593456,front:{x:-1.0453592515927754,y:-0.6247950374932218},back:{x:1.051012663348495,y:-0.5966399274622621}}]},"shape":"polygon"},lineWidth:0.04,color:"#ff3344",isFill:true,fillOutline:"#000000",isVisible:true},
		heart: {pos:{arr:{"layer1":[{x:0.012806439809732896,y:-0.27350896450786677,front:{x:0.0004117257226491054,y:-0.2749242205360408},back:{x:0.025201153896816687,y:-0.2728812445389682}},{x:-0.2671057446030004,y:-0.4747530186608123,front:{x:-0.43541895353091853,y:-0.4729235272594219},back:{x:-0.09696304427369187,y:-0.47658251006220276}},{x:-0.39517014270032935,y:0.035675082327113056,front:{x:-0.2360043907793634,y:0.29912184412733267},back:{x:-0.5543358946212953,y:-0.22960117087449686}},{x:0.0036589828027808226,y:0.4784120014635931,front:{x:0.01395096502924808,y:0.47838424375283567},back:{x:-0.006632999423686435,y:0.47895646158284116}},{x:0.3969996341017199,y:0.04665203073545554,front:{x:0.5525064032199052,y:-0.216794731064764},back:{x:0.23966337358214418,y:0.31009879253567507}},{x:0.27442371020856215,y:-0.4729235272594219,front:{x:0.10245151847786343,y:-0.46926454445664095},back:{x:0.4463959019392609,y:-0.4747530186608124}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"red"},isFill:{"layer1":true},fillOutline:{"layer1":"black"},isVisible:true},
		heartEmpty: {pos:{arr:{"layer1":[{x:0.012806439809732896,y:-0.27350896450786677,front:{x:0.0004117257226491054,y:-0.2749242205360408},back:{x:0.025201153896816687,y:-0.2728812445389682}},{x:-0.2671057446030004,y:-0.4747530186608123,front:{x:-0.43541895353091853,y:-0.4729235272594219},back:{x:-0.09696304427369187,y:-0.47658251006220276}},{x:-0.39517014270032935,y:0.035675082327113056,front:{x:-0.2360043907793634,y:0.29912184412733267},back:{x:-0.5543358946212953,y:-0.22960117087449686}},{x:0.0036589828027808226,y:0.4784120014635931,front:{x:0.01395096502924808,y:0.47838424375283567},back:{x:-0.006632999423686435,y:0.47895646158284116}},{x:0.3969996341017199,y:0.04665203073545554,front:{x:0.5525064032199052,y:-0.216794731064764},back:{x:0.23966337358214418,y:0.31009879253567507}},{x:0.27442371020856215,y:-0.4729235272594219,front:{x:0.10245151847786343,y:-0.46926454445664095},back:{x:0.4463959019392609,y:-0.4747530186608124}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"gray"},isFill:{"layer1":true},fillOutline:{"layer1":"black"},isVisible:true},
		heartSmall: {pos:{arr:{"layer1":[{x:0.012451653698230203,y:-0.2199362616709568,front:{x:0.002460598032717698,y:-0.22107706263329396},back:{x:0.022442709363742708,y:-0.2194302729803299}},{x:-0.2131782556545878,y:-0.3821538435586038,front:{x:-0.3488511423242562,y:-0.380679138268716},back:{x:-0.07603066369503164,y:-0.3836285488484916}},{x:-0.3164076259467268,y:0.029288932320064243,front:{x:-0.18810826572649697,y:0.24164649406389294},back:{x:-0.4447069861669566,y:-0.18454333471365214}},{x:0.005078127248791642,y:0.3861676124728873,front:{x:0.013374225618680846,y:0.3861452377064041},back:{x:-0.0032179711210975626,y:0.38660648757083954}},{x:0.3221397645746471,y:0.03813716405939038,front:{x:0.44748971421510153,y:-0.1742203976844382},back:{x:0.19531510964430487,y:0.250494725803219}},{x:0.22333451015217132,y:-0.380679138268716,front:{x:0.08471221290272757,y:-0.37772972768894064},back:{x:0.36195680740161484,y:-0.3821538435586038}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"red"},isFill:{"layer1":true},fillOutline:{"layer1":"black"},isVisible:true},
		heartSmallEmpty: {pos:{arr:{"layer1":[{x:0.012451653698230203,y:-0.2199362616709568,front:{x:0.002460598032717698,y:-0.22107706263329396},back:{x:0.022442709363742708,y:-0.2194302729803299}},{x:-0.2131782556545878,y:-0.3821538435586038,front:{x:-0.3488511423242562,y:-0.380679138268716},back:{x:-0.07603066369503164,y:-0.3836285488484916}},{x:-0.3164076259467268,y:0.029288932320064243,front:{x:-0.18810826572649697,y:0.24164649406389294},back:{x:-0.4447069861669566,y:-0.18454333471365214}},{x:0.005078127248791642,y:0.3861676124728873,front:{x:0.013374225618680846,y:0.3861452377064041},back:{x:-0.0032179711210975626,y:0.38660648757083954}},{x:0.3221397645746471,y:0.03813716405939038,front:{x:0.44748971421510153,y:-0.1742203976844382},back:{x:0.19531510964430487,y:0.250494725803219}},{x:0.22333451015217132,y:-0.380679138268716,front:{x:0.08471221290272757,y:-0.37772972768894064},back:{x:0.36195680740161484,y:-0.3821538435586038}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"gray"},isFill:{"layer1":true},fillOutline:{"layer1":"black"},isVisible:true},
		heartBig: {pos:{arr:{"layer1":[{x:0.017234152485508414,y:-0.3640410712943386,front:{x:0.000826188503893821,y:-0.3659145691234852},back:{x:0.03364211646712301,y:-0.3632101036279719}},{x:-0.35331001719770194,y:-0.6304453762953396,front:{x:-0.5761208904712665,y:-0.6280235189771489},back:{x:-0.12807728660594675,y:-0.6328672336135307}},{x:-0.5228400294710664,y:0.04525281547992677,front:{x:-0.3121384427884566,y:0.3940002692994191},back:{x:-0.7335416161536767,y:-0.30591649565775636}},{x:0.005124865894554187,y:0.6313422864821288,front:{x:0.018749260332766138,y:0.631305541179646},back:{x:-0.008499528543658652,y:0.6320630358244117}},{x:0.5258241893056017,y:0.059783959389072105,front:{x:0.7316820613518298,y:-0.2889634944304199},back:{x:0.3175444599411821,y:0.40853141320856445}},{x:0.3635597489868101,y:-0.6280235189771489,front:{x:0.13590516107686357,y:-0.6231798043407667},back:{x:0.591214336896756,y:-0.6304453762953396}}]},"shape":"polygon"},lineWidth:{"layer1":0.08},color:{"layer1":"red"},isFill:{"layer1":true},fillOutline:{"layer1":"black"},isVisible:true},
		heartBigEmpty: {pos:{arr:{"layer1":[{x:0.017234152485508414,y:-0.3640410712943386,front:{x:0.000826188503893821,y:-0.3659145691234852},back:{x:0.03364211646712301,y:-0.3632101036279719}},{x:-0.35331001719770194,y:-0.6304453762953396,front:{x:-0.5761208904712665,y:-0.6280235189771489},back:{x:-0.12807728660594675,y:-0.6328672336135307}},{x:-0.5228400294710664,y:0.04525281547992677,front:{x:-0.3121384427884566,y:0.3940002692994191},back:{x:-0.7335416161536767,y:-0.30591649565775636}},{x:0.005124865894554187,y:0.6313422864821288,front:{x:0.018749260332766138,y:0.631305541179646},back:{x:-0.008499528543658652,y:0.6320630358244117}},{x:0.5258241893056017,y:0.059783959389072105,front:{x:0.7316820613518298,y:-0.2889634944304199},back:{x:0.3175444599411821,y:0.40853141320856445}},{x:0.3635597489868101,y:-0.6280235189771489,front:{x:0.13590516107686357,y:-0.6231798043407667},back:{x:0.591214336896756,y:-0.6304453762953396}}]},"shape":"polygon"},lineWidth:{"layer1":0.08},color:{"layer1":"gray"},isFill:{"layer1":true},fillOutline:{"layer1":"black"},isVisible:true},
		
		basicTree: {pos:{arr:{"base":[{x:-0.30008232711306276,y:-0.40911223929747553,front:{x:-0.1572883591926056,y:-0.48557346644076765},back:{x:-0.46953346160661996,y:-0.33531672881149344}},{x:0.19294633452250282,y:-0.4613648747255764,back:{x:0.07165622661489687,y:-0.4946863329419517},front:{x:0.3155693007587641,y:-0.42671055818054615}},{x:0.3864760290889133,y:-0.25364920554335896,back:{x:0.36810098792535695,y:-0.4171144346871572},front:{x:0.40285052140504923,y:-0.09018397639956072}},{x:0.12153334248079035,y:-0.04618267014270033,back:{x:0.2689937980241493,y:-0.08831422886937432},front:{x:-0.025927113062568608,y:-0.005671555982436884}},{x:-0.2892302573181373,y:-0.08596936219824818,front:{x:-0.4131751688623997,y:-0.20515783800791237},back:{x:-0.16528534577387485,y:0.034839558177826566}}],"trunk":[{x:-0.0267731923553923,y:0.479114277201423,front:{x:-0.08814558713929158,y:0.4799380677354351},back:{x:0.03459920242850697,y:0.47870238193441694}},{x:-0.17217222160852277,y:0.42268462562159614,front:{x:-0.20328637772817154,y:0.3682937374629795},back:{x:-0.13987676139996072,y:0.4770755137802128}},{x:-0.18113329363336997,y:0.12272436923710213,front:{x:-0.17386354827019768,y:-0.051231479364009846},back:{x:-0.18840303899654226,y:0.29754138851903167}},{x:-0.030788446761800224,y:-0.00891244511525796,front:{x:0.08426311745334794,y:-0.018635112513721186},back:{x:-0.14584001097694838,y:0.0024306668496158063}},{x:0.12994344978046107,y:0.07153452538419322,front:{x:0.1456941709659716,y:0.23560453773326012},back:{x:0.11550528869374317,y:-0.09253548696487378}},{x:0.11697825582971404,y:0.42762736882566865,front:{x:0.0668449418341048,y:0.4890752930710034},back:{x:0.1659302657364098,y:0.3649981404914208}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"#00ff00","trunk":"#884400"},isFill:true,fillOutline:"#000",isVisible:true},
		pineTree: {pos:{arr:{"trunk":[{x:-0.0860316155928631,y:0.27895660483882734,front:{x:-0.0679094087804073,y:0.2658221552278939},back:{x:-0.10214024387060139,y:0.2920910544497608}},{x:0.06700035304565133,y:0.27332755500557016,front:{x:0.07908182425395505,y:0.2864620046165036},back:{x:0.05491888183734761,y:0.2620694553390557}},{x:0.06297319597621676,y:0.4684679492251538,front:{x:0.046864567698478465,y:0.48347874878050645},back:{x:0.07706824571923776,y:0.4553334996142202}},{x:-0.08804519412758038,y:0.4703442991695729,front:{x:-0.10415382240531867,y:0.4553334996142203},back:{x:-0.07395014438455938,y:0.48535509872492544}}],"leaves":[{x:-0.26896445186875995,y:0.2005947936584015,front:{x:-0.10415603270008789,y:0.0687985455317125},back:{x:-0.43181086604732877,y:0.3394515550775916}},{x:-0.12431465775987549,y:0.06692906111947206,front:{x:-0.33497269485536496,y:0.05379461150853848},back:{x:-0.061639539285184286,y:0.07068176100831025}},{x:-0.21310440893235438,y:-0.053157335323348764,front:{x:-0.07034441685111381,y:-0.19388358115477922},back:{x:-0.3558644010135954,y:0.09132161039692}},{x:-0.08633368921131668,y:-0.19013088126594102,front:{x:-0.2642918887267267,y:-0.19575993109919843},back:{x:-0.05074204930823489,y:-0.18637818137710305}},{x:-0.1219253291143989,y:-0.3327334770417907,front:{x:-0.02473277399444429,y:-0.4509435235401923},back:{x:-0.220486793461395,y:-0.21452343054338896}},{x:0.002645410546388005,y:-0.48284147259531685,front:{x:0.017703412043845956,y:-0.48471782253973583},back:{x:-0.012412590951069724,y:-0.48284147259531685}},{x:0.11626487639084226,y:-0.3402388768194671,front:{x:0.2011372484674223,y:-0.2070180307657128},back:{x:0.03139250431426199,y:-0.47158337292880226}},{x:0.08341105494184364,y:-0.20889438071013178,front:{x:0.0505572334928448,y:-0.2070180307657128},back:{x:0.2846407113169609,y:-0.20889438071013178}},{x:0.19602483666632353,y:-0.07004448482312031,front:{x:0.3387848287475643,y:0.08006351073040563},back:{x:0.05326484458508274,y:-0.22202883032106535}},{x:0.06196972215101182,y:0.06505271117505307,front:{x:0.009740456755436,y:0.07255811095272924},back:{x:0.30222434297066103,y:0.0444128617864431}},{x:0.22938481561746293,y:0.1935342803659002,front:{x:0.43147132959809675,y:0.3559260860934277},back:{x:0.025336296646725875,y:0.03114247463837283}},{x:-0.0060557831949257235,y:0.3135630063384205,front:{x:-0.38472274628485104,y:0.3135630063384205},back:{x:0.37064917490489613,y:0.3135630063384205}}]},"shape":"polygon"},lineWidth:0.04,color:{"leaves":"darkGreen","trunk":"brown"},isFill:true,fillOutline:"#000",isVisible:true},
		
		trustworthyFace: {pos:{arr:{"base":[{x:-0.4482994152760186,y:0.08338494968009813,front:{x:-0.5324733712531767,y:-0.13200134943792385},back:{x:-0.3635065331519697,y:0.3006280272387929}},{x:-0.14688238174016577,y:-0.43279945682688586,front:{x:-0.007005072542829567,y:-0.474267508668574},back:{x:-0.2904732478188472,y:-0.390093552691416}},{x:0.2628467275015888,y:-0.3733825467253624,front:{x:0.3550667233883281,y:-0.30096818753913085},back:{x:0.17310243620241306,y:-0.4445590536178123}},{x:0.4120079289022879,y:0.0771956882111895,front:{x:0.2975065917274774,y:0.244305747871724},back:{x:0.5246524876364261,y:-0.08929544530245392}},{x:-0.041664936768718415,y:0.42750788735142087,front:{x:-0.33689270883566247,y:0.3649963465154431},back:{x:0.25232498300444395,y:0.48940050204050767}}],"layer1":[{x:-0.24926992773344991,y:-0.24933622984036047,front:{x:-0.18449584720805712,y:-0.3493991442850217},back:{x:-0.3118951443503334,y:-0.1526548323846671}},{x:-0.09763427948456593,y:-0.26571855705019193,front:{x:-0.05762272826342552,y:-0.16433927923950492},back:{x:-0.14301799047697983,y:-0.3586440423884595}}],"layer2":[{x:0.013606222969788077,y:-0.26148706109151665,front:{x:0.0633216981710304,y:-0.36399872373250874},back:{x:-0.03365222505283006,y:-0.16097432021512326}},{x:0.15677979976395984,y:-0.29630123163217376,front:{x:0.20540336458372332,y:-0.18232865465825276},back:{x:0.10953883016856569,y:-0.41058197187620904}}],"layer3":[{x:-0.27050099790482374,y:-0.05158371784409471,front:{x:-0.08075245194924463,y:-0.05324043994676886},back:{x:-0.458558785365919,y:-0.04885256378716624}},{x:0.14171199499487785,y:-0.07089681514852297,front:{x:0.22882377311243263,y:-0.07725141760619042},back:{x:0.05490838014743759,y:-0.06315961746648652}},{x:-0.10293284887784115,y:0.10118523569773219,front:{x:-0.17237905234871065,y:0.10215112041954089},back:{x:-0.03794259435019399,y:0.09976124556189847}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"lightyellow","layer1":"lightblue","layer2":"lightblue","layer3":"white"},isFill:true,fillOutline:"black",isVisible:true},
		enemyworthCreature: {pos:{arr:{"layer1":[{x:-0.21030649637468848,y:-0.4744136289277334,front:{x:-0.08317926913793264,y:-0.4975282787960138},back:{x:-0.3011116586866568,y:-0.4512989790594528}},{x:0.40172029760797845,y:-0.37964356446778263,front:{x:0.4434906722714841,y:-0.28949642998148833},back:{x:0.3635821294369518,y:-0.4536104440462807}},{x:0.09843105548600403,y:-0.039858211404057375,front:{x:-0.08681147563041139,y:-0.05834993129868188},back:{x:0.2782252768637016,y:-0.021366491509432872}}],"layer2":[{x:-0.17035222495742222,y:-0.08377604615379058,front:{x:0.16925908208933946,y:-0.07684165119330649},back:{x:-0.47727367357187533,y:-0.08608751114061869}},{x:0.4707322209650747,y:0.10345261777928261,front:{x:0.45257118850268097,y:0.1288787326343913},back:{x:0.48707715018122866,y:0.07802650292417385}},{x:0.17652349507429696,y:0.3946972061196186,front:{x:0.033051338621386955,y:0.4247462509483833},back:{x:0.30909903204977074,y:0.3692710912645099}},{x:-0.20304208338973098,y:0.4247462509483833,front:{x:-0.29747945219417804,y:0.3068615366201522},back:{x:-0.11223692107776242,y:0.5403195002897865}},{x:-0.47000926058691783,y:0.04104306313492484,front:{x:-0.49906691252674784,y:-0.009809166575292572},back:{x:-0.44639991838580595,y:0.08033796791100195}},{x:-0.41371005995349763,y:-0.1993492954951937,front:{x:-0.43913550540084867,y:-0.32879133475756545},back:{x:-0.3882846145061464,y:-0.07453018620647839}},{x:-0.35559475607383784,y:-0.32879133475756545,front:{x:-0.28295062622426304,y:-0.29411935995514443},back:{x:-0.4209744729384549,y:-0.36577477454681445}},{x:-0.2157548061134066,y:-0.2039722254688499,front:{x:-0.2084903931284491,y:-0.1577429257322886},back:{x:-0.22120311585212474,y:-0.23633273528444282}}],"layer3":[{x:0.245535418431393,y:-0.34728305465218995,front:{x:0.3508694067132764,y:-0.35421744961267404},back:{x:0.14928194638070633,y:-0.34266012467853374}},{x:0.2709608638787441,y:-0.2502015252054111,front:{x:0.17652349507429696,y:-0.2317098053107866},back:{x:0.3635821294369518,y:-0.2686932451000357}},{x:0.11840819119463716,y:-0.34266012467853374,front:{x:0.1819718048130151,y:-0.33341426473122154},back:{x:0.05484457757625924,y:-0.35421744961267404}}],"layer4":[{x:0.30183461906481324,y:-0.1785461106137412,front:{x:0.21466166324532363,y:-0.1808575756005693},back:{x:0.37811095540686657,y:-0.1762346456269131}},{x:-0.032328378243230343,y:-0.2386442002712708,front:{x:-0.0432249977206666,y:-0.24095566525809903},back:{x:-0.02506396525827284,y:-0.2386442002712708}},{x:0.15291415287318508,y:-0.08146458116696248,front:{x:0.16943338045122078,y:-0.06744789783314825},back:{x:0.1363949252951496,y:-0.09548126450077671}}],"layer5":[{x:0.003993686681556946,y:0.16123924244998428,front:{x:0.3254439612659251,y:0.10807554775293876},back:{x:-0.3011116586866568,y:0.20746854218654548}},{x:0.3490533034670368,y:0.19591121725240518,front:{x:0.28004138010994073,y:0.2490749119494507},back:{x:0.4144330203316541,y:0.14274752255535966}},{x:-0.0432249977206666,y:0.3669596262776818,front:{x:-0.09770809510784764,y:0.3669596262776818},back:{x:0.005809789927796322,y:0.3646481612908539}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"blue","layer2":"darkRed","layer3":"aqua","layer4":"white","layer5":"red"},isFill:true,fillOutline:"black",isVisible:true},
		
		alienBuilding: {pos:{arr:{"base":[{x:0.03407086291948279,y:-0.31612147556815645,front:{x:0.2968969754350115,y:-0.3161214755681565},back:{x:-0.22875524959604598,y:-0.3176063688592045}},{x:0.3013516553081559,y:0.03728312770131142,front:{x:0.30877612176339686,y:0.14865012452992526},back:{x:0.2939271888529149,y:-0.07259897583625423}},{x:0.44795368504005206,y:0.3106000113180955,front:{x:0.6311580044199989,y:0.31105760593395354},back:{x:0.26366687845093106,y:0.31014241670223747}},{x:0.017085168563182526,y:0.3119883865452256,front:{x:-0.21325923318695406,y:0.3138343563882137},back:{x:0.24742957031331891,y:0.3112249039114115}},{x:-0.43961009692488817,y:0.31495817312732194,front:{x:-0.2342772377691671,y:0.31447236553893393},back:{x:-0.644942956080609,y:0.3165264679248841}},{x:-0.2554833288349132,y:-0.0042938844480377505,front:{x:-0.24508907579757588,y:-0.12308534773189254},back:{x:-0.2658775818722505,y:0.11598247212686517}}],"door":[{x:-0.10523143139362058,y:0.3111835743814774,front:{x:-0.11117100455781338,y:0.24139358970221275},back:{x:-0.028016980259115046,y:0.3126684676725256}},{x:0.032585969628434505,y:0.15310480440306978,front:{x:0.15170740919918901,y:0.15508466212446742},back:{x:-0.0850505766512717,y:0.15112494668167226}},{x:0.16771125911381923,y:0.3105034932541773,front:{x:0.09676635743040606,y:0.3139682442666231},back:{x:0.16919615240486752,y:0.260017121358539}}],"window":[{x:0.02363594551435909,y:-0.20993346968242466,front:{x:0.11018293155665758,y:-0.2121724253559646},back:{x:-0.061653893356640635,y:-0.20769451400888472}},{x:0.15201433118612906,y:-0.0781333216622926,front:{x:0.1488313960041845,y:0.0006883354870020272},back:{x:0.15519726636807385,y:-0.15824713712551014}},{x:0.02151398872639597,y:0.03299229333507358,front:{x:-0.053815477246295554,y:0.03428445164899651},back:{x:0.09578247630510582,y:0.031700135021150815}},{x:-0.09519363461157683,y:-0.07684116334836973,front:{x:-0.09837656979352151,y:-0.1504941872419729},back:{x:-0.0930716778236136,y:-0.003188139454766488}}]},"shape":"polygon"},lineWidth:0.01,color:{"base":"brown","door":"lightblue","window":"lightblue"},isFill:true,fillOutline:"black",isVisible:true},
		
		trapdoor: {pos:{arr:{"base":[{x:-0.38242491767288705,y:-0.38498623765093304,front:{x:-0.3240889132821077,y:-0.44008135290889133},back:{x:-0.4391404774972559,y:-0.32989112239297474}},{x:0.012963556531284306,y:-0.47086979967069165,front:{x:0.15556267837541168,y:-0.4724902442371022},back:{x:-0.12963556531284307,y:-0.47086979967069165}},{x:0.3921475850713503,y:-0.40605201701427,front:{x:0.46344714599341397,y:-0.342854678924259},back:{x:0.31922757958287606,y:-0.469249355104281}},{x:0.47154936882546666,y:-0.0009408754116354955,front:{x:0.47082917124039525,y:0.11612620746432521},back:{x:0.4722695664105381,y:-0.12124884742041729}},{x:0.400249807903403,y:0.4009293770581779,front:{x:0.3338115806805709,y:0.46250627058177846},back:{x:0.46506759055982455,y:0.3393524835345773}},{x:0.012963556531284306,y:0.47546982711306274,front:{x:-0.10208800768386389,y:0.47546982711306274},back:{x:0.1280151207464325,y:0.4738493825466522}},{x:-0.3759431394072449,y:0.4057907107574095,front:{x:-0.4375200329308453,y:0.34097292810098806},back:{x:-0.315986690450055,y:0.470608493413831}},{x:-0.4650675905598245,y:0.008781791986827728,front:{x:-0.46344714599341397,y:-0.13381732985729963},back:{x:-0.4650675905598245,y:0.1513809138309551}}],"texture1":[{x:-0.4195150933040618,y:-0.2816029088913276,front:{x:-0.44672055708013203,y:-0.28330541026344547},back:{x:-0.39230962952799153,y:-0.2813588076289792}},{x:0.4231160812294185,y:-0.297807354555433,front:{x:0.40106003018660846,y:-0.29740120883644355},back:{x:0.44517213227222857,y:-0.2996719003841919}}],"texture2":[{x:-0.444812033479693,y:-0.08884999313940715,front:{x:-0.47252163556531324,y:-0.08593319291986817},back:{x:-0.41710243139407277,y:-0.09030839324917664}},{x:0.4462704335894625,y:-0.10780919456641047,front:{x:0.4229360318331507,y:-0.10780919456641047},back:{x:0.4696048353457743,y:-0.10635079445664099}}],"texture3":[{x:-0.4429215148188807,y:0.10910428100988014,front:{x:-0.46728219813391914,y:0.10871614023051744},back:{x:-0.41710243139407277,y:0.10803402167947336}},{x:0.4573254665203077,y:0.09830131723380989,front:{x:0.42669906421514847,y:0.09975971734357938},back:{x:0.48649346871569743,y:0.09684291712404039}}],"texture4":[{x:-0.41771459934138344,y:0.30355762897914484,front:{x:-0.4460363693743143,y:0.3021972214599358},back:{x:-0.3893928293084526,y:0.30345963638858436}},{x:0.4339190450054888,y:0.294555159165753,front:{x:0.4080099368825469,y:0.29496130488474254},back:{x:0.4583697530186612,y:0.2941490134467634}}],"handle":[{x:-0.0023626081778265664,y:-0.36251148173710224,front:{x:0.08184074727991227,y:-0.363468338049122},back:{x:-0.08560910732354565,y:-0.3615546254250825}},{x:0.09922954346871579,y:-0.2585567219127333,front:{x:0.09798563026309012,y:-0.21449348874422342},back:{x:0.09961228599352369,y:-0.30261995508124323}},{x:0.0011813040889132832,y:-0.15814587435510424,front:{x:-0.07087824533479696,y:-0.15578326617727767},back:{x:0.07324085351262359,y:-0.1593271784440175}},{x:-0.10159215164654235,y:-0.2526502014681669,front:{x:-0.10350586427058187,y:-0.2909244539489572},back:{x:-0.09967843902250284,y:-0.2153328052993963}}],"handleBack":[{x:-0.002583512042453351,y:-0.4198360346077527,front:{x:0.05970783387003299,y:-0.4203623055793636},back:{x:-0.06573602863575748,y:-0.4193097636361418}},{x:-0.0017223413616355673,y:-0.3294131131218854,front:{x:-0.06324820222450611,y:-0.32917389904388045},back:{x:0.05894234882041719,y:-0.3296523271998904}}],"leftPlank":[{x:-0.25440979692645466,y:-0.43846090834248097,front:{x:-0.18058954445664122,y:-0.4402614023051593},back:{x:-0.3282300493962681,y:-0.43846090834248097}},{x:-0.18725137211855117,y:0.008276619099891065,front:{x:-0.18365038419319443,y:0.4547991218441286},back:{x:-0.1908523600439079,y:-0.44004637760702475}},{x:-0.24144624039517035,y:0.4576449368825471,front:{x:-0.3195876783754119,y:0.45623951701427123},back:{x:-0.16492524698133929,y:0.45905035675082295}},{x:-0.3176071350164657,y:0.015263570252469971,front:{x:-0.328410098792536,y:-0.4206010428100982},back:{x:-0.308424615806806,y:0.4511281833150382}}],"rightPlank":[{x:0.25116890779363354,y:-0.45304490944017584,front:{x:0.32498916026344704,y:-0.4548454034028542},back:{x:0.1773486553238201,y:-0.45304490944017584}},{x:0.33705246981339215,y:-0.00904309824368812,front:{x:0.3406534577387489,y:0.43747940450054956},back:{x:0.3334514818880354,y:-0.45736609495060376}},{x:0.2657529088913284,y:0.44792226948408387,front:{x:0.18761147091108688,y:0.446516849615808},back:{x:0.3422739023051594,y:0.4493276893523597}},{x:0.1912124588364436,y:-0.0074226536772775825,front:{x:0.18040949506037324,y:-0.44328726673984553},back:{x:0.20039497804610326,y:0.42844195938529084}}]},"shape":"polygon"},lineWidth:{"base":0.04,"texture1":0.03,"texture2":0.03,"texture3":0.03,"handle":0.04,"handleBack":0.04,"texture4":0.03,"rightPlank":0.03,"leftPlank":0.03},color:{"base":"#840","handle":"#00000000","handleBack":"#222","leftPlank":"#840","rightPlank":"#840"},isFill:true,fillOutline:{"base":"#000","handle":"#222","handleBack":"#222","leftPlank":"#000","rightPlank":"#000"},isVisible:true},
		sign: {pos:{arr:{"pole":[{x:0.011343111964873767,y:-0.4772209248079034,front:{x:0.11019023051591659,y:-0.4756004802414929},back:{x:-0.08750400658616905,y:-0.4772209248079034}},{x:0.10370845225027443,y:0.004051111416026345,front:{x:0.10370845225027443,y:0.4415711443468716},back:{x:0.10370845225027443,y:-0.4318484769484084}},{x:0.009722667398463227,y:0.48046181394072457,front:{x:-0.08102222832052688,y:0.47884136937431404},back:{x:0.10046756311745336,y:0.48046181394072457}},{x:-0.0891244511525796,y:0.0024306668496158067,front:{x:-0.08750400658616905,y:-0.43022803238199786},back:{x:-0.09074489571899014,y:0.43346892151481886}}],"base":[{x:-0.46830847969264544,y:-0.13206623216245886,front:{x:-0.4650675905598244,y:0.020255557080131725},back:{x:-0.4715493688254665,y:-0.28600846597146}},{x:0.006481778265642152,y:0.10127778540065863,front:{x:0.45372447859495063,y:0.10451867453347971},back:{x:-0.43914047749725577,y:0.09803689626783753}},{x:0.4796515916575192,y:-0.14016845499451153,front:{x:0.4812720362239297,y:-0.29411068880351265},back:{x:0.47803114709110867,y:0.015394223380900112}},{x:0.011343111964873767,y:-0.38161469538968174,front:{x:-0.4261769209659715,y:-0.3783738062568606},back:{x:0.4504835894621295,y:-0.3864760290889134}}],"text1":[{x:-0.33777027814297483,y:-0.20428882261621847,front:{x:-0.33777027814297483,y:-0.2691066052726399},back:{x:-0.33614983357656425,y:-0.13947103995979696}},{x:-0.190414406091932,y:-0.24926106928114714,front:{x:-0.13693973540038423,y:-0.2476406247147366},back:{x:-0.24388907678347976,y:-0.24926106928114714}},{x:0.03923110879281011,y:-0.21864166729651485,front:{x:0.03923110879281011,y:-0.14572166180804064},back:{x:0.03761066422639957,y:-0.291561672784989}},{x:-0.09090134964187709,y:-0.18036741481572452,front:{x:-0.1459964648998354,y:-0.18198785938213505},back:{x:-0.037426678950329334,y:-0.178746970249314}}],"text2":[{x:0.11865018269045009,y:-0.21672795467247535,front:{x:0.11865018269045009,y:-0.28802751559453893},back:{x:0.11865018269045009,y:-0.1438079491840011}},{x:0.3176762955905599,y:-0.2454336440330681,front:{x:0.3776327445477498,y:-0.24705408859947864},back:{x:0.25771984663336994,y:-0.24219275490024705}},{x:0.4133619267925358,y:-0.20428882261621847,front:{x:0.4133619267925358,y:-0.13623015082697587},back:{x:0.4133619267925358,y:-0.27072704983905044}},{x:0.23060237119676186,y:-0.17558313325562575,front:{x:0.17064592223957195,y:-0.1739626886892152},back:{x:0.29055882015395174,y:-0.17558313325562575}}],"text3":[{x:-0.37108180570801325,y:-0.06724844950603732,front:{x:-0.37108180570801325,y:-0.13692756586169047},back:{x:-0.37108180570801325,y:0.004051111416026348}},{x:-0.21688743072447864,y:-0.10259626012211857,front:{x:-0.1634127600329309,y:-0.10421670468852912},back:{x:-0.27036210141602646,y:-0.10259626012211857}},{x:-0.1199128979143798,y:-0.0575257821075741,front:{x:-0.1199128979143798,y:0.01053288968166849},back:{x:-0.11829245334796924,y:-0.12558445389681672}},{x:-0.28174102520581784,y:-0.0324267972406696,front:{x:-0.3206316947996707,y:-0.03404724180708014},back:{x:-0.2412299110455544,y:-0.0324267972406696}}],"text4":[{x:-0.030188882272228323,y:-0.061034044593852914,front:{x:-0.03180932683863886,y:-0.12261093811745329},back:{x:-0.030188882272228323,y:0.000542848929747531}},{x:0.11944296899012076,y:-0.09384804706366631,front:{x:0.19884475274423707,y:-0.09384804706366631},back:{x:0.04004118523600439,y:-0.09222760249725577}},{x:0.38010428100987925,y:-0.06301728869374314,front:{x:0.38010428100987925,y:0.0018004939626783956},back:{x:0.38010428100987925,y:-0.1262146267837541}},{x:0.22969801728869374,y:-0.024282361827661914,front:{x:0.15029623353457736,y:-0.02266191726125138},back:{x:0.3058589119099891,y:-0.025902806394072445}}]},"shape":"polygon"},lineWidth:{"pole":0.04,"base":0.04,"text1":0.03,"text2":0.03,"text3":0.03,"text4":0.03},color:{"pole":"#840","base":"#840","text1":"#f0f0f0","text2":"#f0f0f0","text3":"#f0f0f0","text4":"#f0f0f0"},isFill:true,fillOutline:{"pole":"#000","base":"#000","text1":"#000","text2":"#000","text3":"#000","text4":"#000"},isVisible:true},
		sign2: {pos:{arr:{"pole":[{x:0.011343111964873767,y:-0.4772209248079034,front:{x:0.11019023051591659,y:-0.4756004802414929},back:{x:-0.08750400658616905,y:-0.4772209248079034}},{x:0.10370845225027443,y:0.004051111416026345,front:{x:0.10370845225027443,y:0.4415711443468716},back:{x:0.10370845225027443,y:-0.4318484769484084}},{x:0.009722667398463227,y:0.48046181394072457,front:{x:-0.08102222832052688,y:0.47884136937431404},back:{x:0.10046756311745336,y:0.48046181394072457}},{x:-0.0891244511525796,y:0.0024306668496158067,front:{x:-0.08750400658616905,y:-0.43022803238199786},back:{x:-0.09074489571899014,y:0.43346892151481886}}],"base":[{x:-0.46830847969264544,y:-0.13206623216245886,front:{x:-0.4650675905598244,y:0.020255557080131725},back:{x:-0.4715493688254665,y:-0.28600846597146}},{x:0.006481778265642152,y:0.10127778540065863,front:{x:0.45372447859495063,y:0.10451867453347971},back:{x:-0.43914047749725577,y:0.09803689626783753}},{x:0.4796515916575192,y:-0.14016845499451153,front:{x:0.4812720362239297,y:-0.29411068880351265},back:{x:0.47803114709110867,y:0.015394223380900112}},{x:0.011343111964873767,y:-0.38161469538968174,front:{x:-0.4261769209659715,y:-0.3783738062568606},back:{x:0.4504835894621295,y:-0.3864760290889134}}],"text1":[{x:-0.33777027814297483,y:-0.20428882261621847,front:{x:-0.33777027814297483,y:-0.2691066052726399},back:{x:-0.33614983357656425,y:-0.13947103995979696}},{x:-0.190414406091932,y:-0.24926106928114714,front:{x:-0.13693973540038423,y:-0.2476406247147366},back:{x:-0.24388907678347976,y:-0.24926106928114714}},{x:0.03923110879281011,y:-0.21864166729651485,front:{x:0.03923110879281011,y:-0.14572166180804064},back:{x:0.03761066422639957,y:-0.291561672784989}},{x:-0.09090134964187709,y:-0.18036741481572452,front:{x:-0.1459964648998354,y:-0.18198785938213505},back:{x:-0.037426678950329334,y:-0.178746970249314}}],"text2":[{x:0.11865018269045009,y:-0.21672795467247535,front:{x:0.11865018269045009,y:-0.28802751559453893},back:{x:0.11865018269045009,y:-0.1438079491840011}},{x:0.3176762955905599,y:-0.2454336440330681,front:{x:0.3776327445477498,y:-0.24705408859947864},back:{x:0.25771984663336994,y:-0.24219275490024705}},{x:0.4133619267925358,y:-0.20428882261621847,front:{x:0.4133619267925358,y:-0.13623015082697587},back:{x:0.4133619267925358,y:-0.27072704983905044}},{x:0.23060237119676186,y:-0.17558313325562575,front:{x:0.17064592223957195,y:-0.1739626886892152},back:{x:0.29055882015395174,y:-0.17558313325562575}}],"text3":[{x:-0.37108180570801325,y:-0.06724844950603732,front:{x:-0.37108180570801325,y:-0.13692756586169047},back:{x:-0.37108180570801325,y:0.004051111416026348}},{x:-0.21688743072447864,y:-0.10259626012211857,front:{x:-0.1634127600329309,y:-0.10421670468852912},back:{x:-0.27036210141602646,y:-0.10259626012211857}},{x:-0.1199128979143798,y:-0.0575257821075741,front:{x:-0.1199128979143798,y:0.01053288968166849},back:{x:-0.11829245334796924,y:-0.12558445389681672}},{x:-0.28174102520581784,y:-0.0324267972406696,front:{x:-0.3206316947996707,y:-0.03404724180708014},back:{x:-0.2412299110455544,y:-0.0324267972406696}}],"text4":[{x:-0.030188882272228323,y:-0.061034044593852914,front:{x:-0.03180932683863886,y:-0.12261093811745329},back:{x:-0.030188882272228323,y:0.000542848929747531}},{x:0.11944296899012076,y:-0.09384804706366631,front:{x:0.19884475274423707,y:-0.09384804706366631},back:{x:0.04004118523600439,y:-0.09222760249725577}},{x:0.38010428100987925,y:-0.06301728869374314,front:{x:0.38010428100987925,y:0.0018004939626783956},back:{x:0.38010428100987925,y:-0.1262146267837541}},{x:0.22969801728869374,y:-0.024282361827661914,front:{x:0.15029623353457736,y:-0.02266191726125138},back:{x:0.3058589119099891,y:-0.025902806394072445}}]},"shape":"polygon"},lineWidth:{"pole":0.04,"base":0.04,"text1":0.03,"text2":0.03,"text3":0.03,"text4":0.03},color:{"pole":"#840","base":"#840","text1":"#f0f0f0","text2":"#f0f0f0","text3":"#f0f0f0","text4":"#f0f0f0"},isFill:true,fillOutline:{"pole":"#000","base":"#000","text1":"#00000000","text2":"#00000000","text3":"#00000000","text4":"#00000000"},isVisible:true},
		sign3: {pos:{arr:{"pole":[{x:0.011343111964873767,y:-0.4772209248079034,front:{x:0.11019023051591659,y:-0.4756004802414929},back:{x:-0.08750400658616905,y:-0.4772209248079034}},{x:0.10370845225027443,y:0.004051111416026345,front:{x:0.10370845225027443,y:0.4415711443468716},back:{x:0.10370845225027443,y:-0.4318484769484084}},{x:0.009722667398463227,y:0.48046181394072457,front:{x:-0.08102222832052688,y:0.47884136937431404},back:{x:0.10046756311745336,y:0.48046181394072457}},{x:-0.0891244511525796,y:0.0024306668496158067,front:{x:-0.08750400658616905,y:-0.43022803238199786},back:{x:-0.09074489571899014,y:0.43346892151481886}}],"base":[{x:-0.46830847969264544,y:-0.13206623216245886,front:{x:-0.4650675905598244,y:0.020255557080131725},back:{x:-0.4715493688254665,y:-0.28600846597146}},{x:0.006481778265642152,y:0.10127778540065863,front:{x:0.45372447859495063,y:0.10451867453347971},back:{x:-0.43914047749725577,y:0.09803689626783753}},{x:0.4796515916575192,y:-0.14016845499451153,front:{x:0.4812720362239297,y:-0.29411068880351265},back:{x:0.47803114709110867,y:0.015394223380900112}},{x:0.011343111964873767,y:-0.38161469538968174,front:{x:-0.4261769209659715,y:-0.3783738062568606},back:{x:0.4504835894621295,y:-0.3864760290889134}}],"text1":[{x:-0.33777027814297483,y:-0.20428882261621847,front:{x:-0.33777027814297483,y:-0.2691066052726399},back:{x:-0.33614983357656425,y:-0.13947103995979696}},{x:-0.190414406091932,y:-0.24926106928114714,front:{x:-0.13693973540038423,y:-0.2476406247147366},back:{x:-0.24388907678347976,y:-0.24926106928114714}},{x:0.03923110879281011,y:-0.21864166729651485,front:{x:0.03923110879281011,y:-0.14572166180804064},back:{x:0.03761066422639957,y:-0.291561672784989}},{x:-0.0879415266190999,y:-0.18047701358397367,front:{x:-0.1430366418770582,y:-0.1820974581503842},back:{x:-0.03446685592755215,y:-0.17885656901756314}}],"text2":[{x:0.11865018269045009,y:-0.21672795467247535,front:{x:0.11865018269045009,y:-0.28802751559453893},back:{x:0.11865018269045009,y:-0.1438079491840011}},{x:0.3176762955905599,y:-0.2454336440330681,front:{x:0.3776327445477498,y:-0.24705408859947864},back:{x:0.25771984663336994,y:-0.24219275490024705}},{x:0.4133619267925358,y:-0.20428882261621847,front:{x:0.4133619267925358,y:-0.13623015082697587},back:{x:0.4133619267925358,y:-0.27072704983905044}},{x:0.23060237119676186,y:-0.17558313325562575,front:{x:0.17064592223957195,y:-0.1739626886892152},back:{x:0.29055882015395174,y:-0.17558313325562575}}],"text3":[{x:-0.37108180570801325,y:-0.06724844950603732,front:{x:-0.37108180570801325,y:-0.13692756586169047},back:{x:-0.37108180570801325,y:0.004051111416026348}},{x:-0.21688743072447864,y:-0.10259626012211857,front:{x:-0.1634127600329309,y:-0.10421670468852912},back:{x:-0.27036210141602646,y:-0.10259626012211857}},{x:-0.1199128979143798,y:-0.0575257821075741,front:{x:-0.1199128979143798,y:0.01053288968166849},back:{x:-0.11829245334796924,y:-0.12558445389681672}},{x:-0.28174102520581784,y:-0.0324267972406696,front:{x:-0.3206316947996707,y:-0.03404724180708014},back:{x:-0.2412299110455544,y:-0.0324267972406696}}],"text4":[{x:-0.030188882272228323,y:-0.061034044593852914,front:{x:-0.03180932683863886,y:-0.12261093811745329},back:{x:-0.030188882272228323,y:0.000542848929747531}},{x:0.11944296899012076,y:-0.09384804706366631,front:{x:0.19884475274423707,y:-0.09384804706366631},back:{x:0.04004118523600439,y:-0.09222760249725577}},{x:0.38010428100987925,y:-0.06301728869374314,front:{x:0.38010428100987925,y:0.0018004939626783956},back:{x:0.38010428100987925,y:-0.1262146267837541}},{x:0.22969801728869374,y:-0.024282361827661914,front:{x:0.15029623353457736,y:-0.02266191726125138},back:{x:0.3058589119099891,y:-0.025902806394072445}}]},"shape":"polygon"},lineWidth:{"pole":0.04,"base":0.04,"text1":0.02,"text2":0.02,"text3":0.02,"text4":0.02},color:{"pole":"#840","base":"#840","text1":"#f0f0f0","text2":"#f0f0f0","text3":"#f0f0f0","text4":"#f0f0f0"},isFill:true,fillOutline:{"pole":"#000","base":"#000","text1":"#000","text2":"#000","text3":"#000","text4":"#000"},isVisible:true},
		
		basicStar: {pos:{arr:{"star":[{x:-0.014401904383081005,y:-0.5},{x:0.08934830398957083,y:-0.0939485053097432},{x:0.5,y:0.004584363014164927},{x:0.09808265808671031,y:0.10582090990968843},{x:-0.0012496789489277182,y:0.5},{x:-0.10189962501866481,y:0.10776105587519258},{x:-0.5,y:-0.001991749702911716},{x:-0.10685135224914247,y:-0.09193764635910706}]},"shape":"polygon"},lineWidth:{"star":0.01},color:{"star":"#fff"},isFill:true,fillOutline:{"star":"#000"},isVisible:true},
		basicStarRotated: {pos:{arr:{"star":[{x:0.34499628390607673,y:-0.35851652345305174},{x:0.13123699438948222,y:0.0019677178431816156},{x:0.35193833398261676,y:0.36201557615950936},{x:-0.0038451927744771464,y:0.14940214702988464},{x:-0.35281046948828676,y:0.35789028552567975},{x:-0.1466259116441555,y:0.009365208897605726},{x:-0.35051843330783883,y:-0.34974121892313004},{x:-0.008919005003386049,y:-0.13534449754967748}]},"shape":"polygon"},lineWidth:{"star":0.01},color:{"star":"#fff"},isFill:true,fillOutline:{"star":"#000"},isVisible:true},
		basicMoon: {pos:{arr:{"base":[{x:0.3309955663047601,y:-0.1806233436850493,front:{x:0.26438512944119674,y:-0.1099813360239904},back:{x:0.39760600316832373,y:-0.24981776922190602}},{x:0.058870031986473226,y:-0.21654788543674974,front:{x:-0.10095752239587585,y:-0.22111505892273142},back:{x:0.22091242345310014,y:-0.21198071195076817}},{x:-0.1743195781900071,y:-0.0037599503694208947,front:{x:-0.1714976590546824,y:0.11782853352409772},back:{x:-0.17714149732533246,y:-0.12390085213873758}},{x:0.06722926556842324,y:0.21770176683562048,front:{x:0.24970530554871218,y:0.21074959960451034},back:{x:-0.1152467744118657,y:0.22305268288659708}},{x:0.3407429413382239,y:0.13900278933875765,front:{x:0.41046094350507456,y:0.19980123855524268},back:{x:0.2726848916039173,y:0.07820434012227262}},{x:0.06569158702803857,y:0.3769884653098281,front:{x:-0.21101971971469125,y:0.3949416584021911},back:{x:0.34406284620331196,y:0.35903527221746523}},{x:-0.36191492335767894,y:0.009315802602981482,front:{x:-0.36307689006045973,y:-0.19394109922770786},back:{x:-0.36075295665489815,y:0.21402028655787275}},{x:0.05668614297410901,y:-0.3758628551945534,front:{x:0.34717781866932085,y:-0.35704428757992723},back:{x:-0.2338055327211026,y:-0.39323384068497746}}]},"shape":"polygon"},lineWidth:{"base":0.01},color:{"base":"#fff"},isFill:true,fillOutline:{"base":"#000"},isVisible:true},
		
		pictureNight: {pos:{arr:{"sky":[{x:-0.5,y:-0.5},{x:0.5,y:-0.5},{x:0.5,y:0.5},{x:-0.5,y:0.5}],"hills":[{x:-0.5,y:0.03750457372850348,front:{x:-0.45852579582875963,y:0.0018004939626783756}},{x:-0.22685693377241128,y:-0.010062202707647275,front:{x:-0.15550676911818517,y:-0.0027442371020856204},back:{x:-0.296377607025247,y:-0.01738016831320893}},{x:0.06403219904866447,y:0.057628979143798026,front:{x:0.13443688254665206,y:0.04021103183315039},back:{x:-0.007572813757775354,y:0.07624725576289791}},{x:0.30003658982802783,y:0.03750457372850348,front:{x:0.34800402488108306,y:0.04440075009147457},back:{x:0.2520691547749726,y:0.029408068057080135}},{x:0.43651207464324904,y:0.0905018294914014,front:{x:0.4801317233809001,y:0.10382848518111966},back:{x:0.39409275521405024,y:0.07597484449323089}},{x:0.5,y:0.08873033296743506},{x:0.5,y:0.5},{x:-0.5,y:0.5}],"path":[{x:-0.1860510428100988,y:0.5,front:{x:-0.1956536772777168,y:0.46759110867178927}},{x:-0.1620444566410538,y:0.40511114160263445,front:{x:-0.14403951701427004,y:0.37630323819978045},back:{x:-0.17764873765093306,y:0.43391904500548845}},{x:-0.06961909989023052,y:0.32588940724478593,front:{x:-0.0346761800219539,y:0.3127524698133919},back:{x:-0.10456201975850714,y:0.3403600439077936}},{x:0.009848035126234906,y:0.2667851920965972,front:{x:0.024006586169045007,y:0.24073271130625687},back:{x:-0.004310515916575195,y:0.2941713721185511}},{x:0.059680373216245884,y:0.18584698682766193,front:{x:0.07680907244785949,y:0.165771479143798},back:{x:0.04255167398463228,y:0.2049502277716795}},{x:0.13267155823271132,y:0.13312528271130625,front:{x:0.16388012025246979,y:0.11872133100987925},back:{x:0.10266332552140504,y:0.14752923441273325}},{x:0.200080251701427,y:0.07745929083424806,front:{x:0.20368123962678372,y:0.07025731498353457},back:{x:0.1976795930845225,y:0.08466126668496154}},{x:0.24722978710208562,y:0.08060943507135016,front:{x:0.25083077502744233,y:0.09141239884742042},back:{x:0.2436287991767289,y:0.07100680060373214}},{x:0.2175640083424808,y:0.12786736020856204,front:{x:0.210680239791438,y:0.13878561561470915},back:{x:0.22366024083424807,y:0.11694910480241494}},{x:0.1746185063117454,y:0.1655664628979143,front:{x:0.15786575021953905,y:0.1732319459110866},back:{x:0.19137126240395172,y:0.15868851594401753}},{x:0.1445341727222832,y:0.20289082277716797,front:{x:0.1417991023600439,y:0.22110443965422616},back:{x:0.146481707025247,y:0.18467720590010978}},{x:0.13216959385290888,y:0.2778762349066959,front:{x:0.1243007683863886,y:0.3096849615806805},back:{x:0.14003841931942917,y:0.24740120746432492}},{x:0.06188364434687157,y:0.383905323819978,front:{x:0.03547639956092206,y:0.41871487376509325},back:{x:0.08709055982436884,y:0.34909577387486274}},{x:0.04988035126234916,y:0.5}],"houseBase":[{x:0.1698056659165752,y:-0.09295518210757411},{x:0.3376292280461032,y:-0.0906571516465423},{x:0.33155268095499457,y:0.09253548696487379},{x:0.16144489215148194,y:0.08938534272777171}],"houseRoof":[{x:0.1130357311745335,y:-0.06826770913830958},{x:0.23505520702524707,y:-0.19204698778814489},{x:0.2996331638858399,y:-0.1904719156695939},{x:0.3898303493413832,y:-0.060577079226125125}],"houseDoor":[{x:0.19571729473106472,y:0.09090694017563117},{x:0.19863409495060372,y:-0.011026963229967074},{x:0.2403182813413831,y:-0.010054696490120751},{x:0.23934601460153682,y:0.09187920691547749}],"houseWindow":[{x:0.2751360866713502,y:-0.0020093982552414932},{x:0.3167692679489572,y:-0.0024330489031284303},{x:0.3149200457777717,y:0.061143118338062574},{x:0.2733736684746982,y:0.06053789687650933}],"star":[{x:-0.2586931942919868,y:-0.42319017563117434},{x:-0.2393677362908637,y:-0.35009027688147415},{x:-0.16506750823271127,y:-0.33076481888035114},{x:-0.23745982800742468,y:-0.3138400194961326},{x:-0.25629253567508226,y:-0.23953979143798013},{x:-0.2746640395344857,y:-0.3119321112126936},{x:-0.3475175631174533,y:-0.3319651481888034},{x:-0.2756179936762053,y:-0.3481823685980351}]},"shape":"polygon"},lineWidth:0.04,color:{"sky":"#111","hills":"#018310","houseBase":"yellow","houseRoof":"red","houseDoor":"#555","houseWindow":"#10bde0","path":"#27221c","star":"#fff"},isFill:true,fillOutline:false,isVisible:true},
		
		circles: {pos:{arr:{"layer0":[{x:-0.14999999999999997,y:-0.14999999999999997,back:{x:-0.15999999999999998,y:-0.14999999999999997},front:{x:-0.13999999999999996,y:-0.14999999999999997}},{x:-0.14999999999999997,y:-0.13499999999999995,front:{x:-0.15999999999999998,y:-0.13499999999999995},back:{x:-0.13999999999999996,y:-0.13499999999999995}}],"layer1":[{x:-0.04999999999999999,y:-0.14999999999999997,back:{x:-0.05999999999999999,y:-0.14999999999999997},front:{x:-0.03999999999999999,y:-0.14999999999999997}},{x:-0.04999999999999999,y:-0.13499999999999995,front:{x:-0.05999999999999999,y:-0.13499999999999995},back:{x:-0.03999999999999999,y:-0.13499999999999995}}],"layer2":[{x:0.04999999999999999,y:-0.14999999999999997,back:{x:0.03999999999999999,y:-0.14999999999999997},front:{x:0.05999999999999999,y:-0.14999999999999997}},{x:0.04999999999999999,y:-0.13499999999999995,front:{x:0.03999999999999999,y:-0.13499999999999995},back:{x:0.05999999999999999,y:-0.13499999999999995}}],"layer3":[{x:0.15000000000000008,y:-0.14999999999999997,back:{x:0.14000000000000007,y:-0.14999999999999997},front:{x:0.1600000000000001,y:-0.14999999999999997}},{x:0.15000000000000008,y:-0.13499999999999995,front:{x:0.14000000000000007,y:-0.13499999999999995},back:{x:0.1600000000000001,y:-0.13499999999999995}}],"layer4":[{x:-0.14999999999999997,y:-0.04999999999999999,back:{x:-0.15999999999999998,y:-0.04999999999999999},front:{x:-0.13999999999999996,y:-0.04999999999999999}},{x:-0.14999999999999997,y:-0.03499999999999999,front:{x:-0.15999999999999998,y:-0.03499999999999999},back:{x:-0.13999999999999996,y:-0.03499999999999999}}],"layer5":[{x:-0.04999999999999999,y:-0.04999999999999999,back:{x:-0.05999999999999999,y:-0.04999999999999999},front:{x:-0.03999999999999999,y:-0.04999999999999999}},{x:-0.04999999999999999,y:-0.03499999999999999,front:{x:-0.05999999999999999,y:-0.03499999999999999},back:{x:-0.03999999999999999,y:-0.03499999999999999}}],"layer6":[{x:0.04999999999999999,y:-0.04999999999999999,back:{x:0.03999999999999999,y:-0.04999999999999999},front:{x:0.05999999999999999,y:-0.04999999999999999}},{x:0.04999999999999999,y:-0.03499999999999999,front:{x:0.03999999999999999,y:-0.03499999999999999},back:{x:0.05999999999999999,y:-0.03499999999999999}}],"layer7":[{x:0.15000000000000008,y:-0.04999999999999999,back:{x:0.14000000000000007,y:-0.04999999999999999},front:{x:0.1600000000000001,y:-0.04999999999999999}},{x:0.15000000000000008,y:-0.03499999999999999,front:{x:0.14000000000000007,y:-0.03499999999999999},back:{x:0.1600000000000001,y:-0.03499999999999999}}],"layer8":[{x:-0.14999999999999997,y:0.04999999999999999,back:{x:-0.15999999999999998,y:0.04999999999999999},front:{x:-0.13999999999999996,y:0.04999999999999999}},{x:-0.14999999999999997,y:0.06499999999999999,front:{x:-0.15999999999999998,y:0.06499999999999999},back:{x:-0.13999999999999996,y:0.06499999999999999}}],"layer9":[{x:-0.04999999999999999,y:0.04999999999999999,back:{x:-0.05999999999999999,y:0.04999999999999999},front:{x:-0.03999999999999999,y:0.04999999999999999}},{x:-0.04999999999999999,y:0.06499999999999999,front:{x:-0.05999999999999999,y:0.06499999999999999},back:{x:-0.03999999999999999,y:0.06499999999999999}}],"layer10":[{x:0.04999999999999999,y:0.04999999999999999,back:{x:0.03999999999999999,y:0.04999999999999999},front:{x:0.05999999999999999,y:0.04999999999999999}},{x:0.04999999999999999,y:0.06499999999999999,front:{x:0.03999999999999999,y:0.06499999999999999},back:{x:0.05999999999999999,y:0.06499999999999999}}],"layer11":[{x:0.15000000000000008,y:0.04999999999999999,back:{x:0.14000000000000007,y:0.04999999999999999},front:{x:0.1600000000000001,y:0.04999999999999999}},{x:0.15000000000000008,y:0.06499999999999999,front:{x:0.14000000000000007,y:0.06499999999999999},back:{x:0.1600000000000001,y:0.06499999999999999}}],"layer12":[{x:-0.14999999999999997,y:0.15000000000000008,back:{x:-0.15999999999999998,y:0.15000000000000008},front:{x:-0.13999999999999996,y:0.15000000000000008}},{x:-0.14999999999999997,y:0.1650000000000001,front:{x:-0.15999999999999998,y:0.1650000000000001},back:{x:-0.13999999999999996,y:0.1650000000000001}}],"layer13":[{x:-0.04999999999999999,y:0.15000000000000008,back:{x:-0.05999999999999999,y:0.15000000000000008},front:{x:-0.03999999999999999,y:0.15000000000000008}},{x:-0.04999999999999999,y:0.1650000000000001,front:{x:-0.05999999999999999,y:0.1650000000000001},back:{x:-0.03999999999999999,y:0.1650000000000001}}],"layer14":[{x:0.04999999999999999,y:0.15000000000000008,back:{x:0.03999999999999999,y:0.15000000000000008},front:{x:0.05999999999999999,y:0.15000000000000008}},{x:0.04999999999999999,y:0.1650000000000001,front:{x:0.03999999999999999,y:0.1650000000000001},back:{x:0.05999999999999999,y:0.1650000000000001}}],"layer15":[{x:0.15000000000000008,y:0.15000000000000008,back:{x:0.14000000000000007,y:0.15000000000000008},front:{x:0.1600000000000001,y:0.15000000000000008}},{x:0.15000000000000008,y:0.1650000000000001,front:{x:0.14000000000000007,y:0.1650000000000001},back:{x:0.1600000000000001,y:0.1650000000000001}}]},"shape":"polygon"},lineWidth:0.1,color:"#222222",isFill:false,fillOutline:false,isVisible:true},
		
		glitch: {pos:{arr:{"base":[{x:-0.434403145680718,y:-0.028382957121699717,front:{x:-0.4308569975527122,y:-0.34930936270623014},back:{x:-0.43794929380872377,y:0.29077037439882786}},{x:-0.2535495911524191,y:-0.31562095549017444,front:{x:-0.12588825854420807,y:-0.14717891940989608},back:{x:-0.38121092376063015,y:-0.48228991750644984}},{x:-0.2535495911524191,y:0.1365129308305728,front:{x:-0.4184454791046916,y:0.23757815247873984},back:{x:-0.0939729253921554,y:0.03544770918240578}},{x:-0.4450415900647356,y:0.24112430060674572,front:{x:0.31915333152052755,y:0.04785922763042627},back:{x:-1.2056903635219929,y:0.42197785513504465}},{x:0.27128033179244837,y:-0.1666827341139283,front:{x:-0.021276888768035167,y:-0.35462858489823895},back:{x:0.5549721820329172,y:0.02126311667038233}},{x:-0.09397292539215532,y:-0.2482441410580631,front:{x:-0.0691498884961143,y:0.26594733750278676},back:{x:-0.11879596228819635,y:-0.7659817677469188}},{x:0.19681122110432528,y:0.15424367147060214,front:{x:0.7180949959211869,y:-0.03724832744171439},back:{x:-0.3156071833925217,y:0.33509722599890107}},{x:0.6649027740010989,y:-0.19327884507397225,front:{x:0.03900762940806447,y:0.19147822681466364},back:{x:1.2553364373140745,y:-0.5461205838105554}},{x:-0.8315717360173744,y:0.5017661880151765,front:{x:0.5815682929929612,y:-0.019517586801685076},back:{x:-2.24471176502771,y:0.9946807778079911}},{x:0.25709573928042495,y:-0.38831699211429466,front:{x:0.12411518448020514,y:0.5531853358712615},back:{x:0.3936224422086506,y:-1.3174078016518302}},{x:0.36170710905659786,y:0.9007078524158358,front:{x:-0.5709298486089436,y:-0.04256754963372319},back:{x:1.2872517704661277,y:1.8049756250573306}},{x:-0.5638375523529319,y:-0.32094017768218325,front:{x:0.3599340349925949,y:-0.10817129000183162},back:{x:-1.2659748816980922,y:-0.4521476584184001}},{x:0.9822830314576235,y:0.06736304233445853,front:{x:0.4875953676008059,y:0.5478661136792528},back:{x:1.4237784733943533,y:-0.38299776992228574}},{x:-0.5000068860488264,y:0.4716239289271267,front:{x:-0.39894166440065937,y:0.2003435971346783},back:{x:-0.5904336633129759,y:0.7411311866555721}},{x:0.3758917015686213,y:-0.200371141329984,front:{x:0.2145419617443546,y:-0.22696725229002798},back:{x:0.5283760710728733,y:-0.17554810443394295}},{x:0.18971892484831357,y:-0.21278265977800448,front:{x:-0.03546148128005861,y:0.5194969286552058},back:{x:0.4007147384646623,y:-0.9308776556991913}},{x:-0.11170366603218462,y:0.41133941075102703,front:{x:-0.04432685160007326,y:-0.028382957121699717},back:{x:-0.17730740640029305,y:0.8510617786237538}},{x:-0.12056903635219927,y:-0.17732117849794593,front:{x:-0.2730534058564513,y:0.08332070891048489},back:{x:0.03191533315205276,y:-0.4042746586903211}},{x:0.02659611096004396,y:0.3155934112948688,front:{x:0.017730740640029306,y:0.4698508548631238},back:{x:0.014184592512023447,y:0.1595628936626109}},{x:-0.42021855316869455,y:0.2765857818868043,front:{x:0.4184454791046916,y:-0.005332994289661637},back:{x:-1.1329943268978726,y:0.5319084471032263}},{x:0.5957528855049847,y:-0.08334825310579058,front:{x:0.11879596228819636,y:-0.14717891940989608},back:{x:1.0691636605937673,y:-0.017744512737682128}},{x:-0.4397223678727268,y:0.04785922763042627,front:{x:-0.06205759224010257,y:0.3971548182390036},back:{x:-0.8014294769293246,y:-0.2961171407861423}},{x:0.014184592512023444,y:0.41133941075102703,front:{x:-0.21808810987236046,y:0.03190156105439991},back:{x:0.2322727023843839,y:0.7517696310395896}},{x:0.04432685160007326,y:-0.008879142417667482,front:{x:0.3262456277765392,y:-0.09575977155381107},back:{x:-0.23936499864039562,y:0.0584976720144439}},{x:0.17021511014428134,y:-0.05143291995373783,front:{x:-0.0017730740640029305,y:0.25353581905476624},back:{x:0.34397636841656853,y:-0.3564016589622419}},{x:-0.05496529598409085,y:0.26772041156678966,front:{x:-0.38830322001664175,y:0.04608615356642335},back:{x:0.32269947964853335,y:0.46630470673511787}},{x:0.2092227395523458,y:-0.06561751246576127,front:{x:0.22163425800036632,y:-0.23051340041803384},back:{x:0.1560305176322579,y:0.0709091904624644}},{x:-0.23049962832038096,y:-0.28902484453013055,front:{x:0.09929214758416412,y:0.24289737467074862},back:{x:-0.5141914785608499,y:-0.7961240268349687}},{x:0.4609992566407619,y:0.41843170700703874,front:{x:-0.2606418874084308,y:0.20920896745469297},back:{x:1.07093673465777,y:0.5868737430873171}},{x:-0.4680915528967737,y:0.12764756051055814,front:{x:0.45568003444875316,y:-0.20923651164999865},back:{x:-1.3723593255382682,y:0.4503470401590915}},{x:0.44326851600073264,y:-0.26597488169809247,front:{x:-0.19681122110432528,y:0.05849767201444387},back:{x:1.0496598458897348,y:-0.5496667319385614}},{x:-0.23049962832038096,y:0.40779326262302124,front:{x:-0.4184454791046916,y:0.3191395594228747},back:{x:-0.042553777536070314,y:0.4946738917591649}},{x:-0.16134973982426667,y:0.10459759767852006,front:{x:0.663129699937096,y:-0.008879142417667482},back:{x:-0.9876022536496323,y:0.21452818964670176}},{x:-0.1615467480536004,y:0.23166790559872988,front:{x:-0.04925205733341475,y:0.1430142023985833},back:{x:-0.27187135648044947,y:0.32032160879887644}},{x:0.2580807804270933,y:0.21590724725203717,front:{x:0.07880329173346359,y:-0.06384443840175862},back:{x:0.4432685160007328,y:0.49565893290583296}},{x:-0.41765744618735706,y:0.003138359571685435,front:{x:0.2856619325338055,y:0.17256543679863215},back:{x:-1.1209768249085197,y:-0.16431863536192473}},{x:0.18912790016031264,y:0.4286761349323889,front:{x:-0.8944173611748119,y:0.211967082665364},back:{x:1.2707030792021003,y:0.6453851871994137}},{x:-0.7013492964278261,y:0.519299920425872,front:{x:0.24232012208040057,y:0.36169333695894484},back:{x:-1.6469887972293893,y:0.6749364215994627}},{x:0.571323865067611,y:-0.0027718873083243415,front:{x:-0.3329439075738837,y:-0.1662887176552613},back:{x:1.4677113085357594,y:0.16665518991862238}},{x:0.16942707722694675,y:0.1272535440518906,front:{x:-0.4097771170140107,y:0.7557097956262628},back:{x:0.7446911068812311,y:-0.5012027075224816}},{x:-0.4944906556274841,y:0.7832909477329751,front:{x:0.317183249227191,y:-0.1288571540818661},back:{x:-1.312074807362169,y:1.6954390495478164}},{x:0.0985041146668295,y:-0.1268870717885295,front:{x:0.4787299972807914,y:0.8226925935997069},back:{x:-0.24035003978706398,y:-1.0784368194701026}},{x:0.6186058401076893,y:0.6099237059193552,front:{x:-1.014592381068344,y:0.2612191399987787},back:{x:2.2458938144037126,y:0.9546881072532585}},{x:-0.7821226704546262,y:0.21787732954537373,front:{x:0.6599775682677576,y:0.10952280341186128},back:{x:-2.2183126622970004,y:0.3183515265055398}},{x:0.5654136181876013,y:0.07406132213180268,front:{x:-0.8372849746680509,y:0.475958109972467},back:{x:1.9622019641632436,y:-0.3278354657088617}},{x:-0.8471353861347337,y:0.44640687557241815,front:{x:0.13987584282689788,y:0.1489244492785931},back:{x:-1.8302064505096922,y:0.7360089726928969}},{x:0.04728197504007816,y:-0.21751085728201264,front:{x:0.18912790016031264,y:0.6079536236260186},back:{x:-0.0965340323734929,y:-1.003573692323312}},{x:0.02167090522670249,y:0.6355347757327309,front:{x:0.4472086805874059,y:0.011018688745031794},back:{x:-0.35855497738725933,y:1.25414061584042}},{x:0.6284562515743721,y:-0.09536575509514407,front:{x:0.02955123440004885,y:0.05830066378510995},back:{x:1.1268870717885293,y:-0.20963052810866628}},{x:-0.4944906556274841,y:0.34396259631891546,front:{x:0.3881062117873082,y:0.856183992586429},back:{x:-1.2766133260821104,y:-0.19978011664198347}},{x:0.44326851600073275,y:0.48777860373248655,front:{x:-0.19897831162699559,y:0.11543305029187106},back:{x:1.052023944641739,y:0.8463335811197459}},{x:-0.4314480222407132,y:0.09573222735850517,front:{x:0.3723455534406155,y:0.9310471197332194},back:{x:-1.2253911864553588,y:-0.7395826650162091}},{x:0.42356769306736686,y:0.6118937882126918,front:{x:0.2974824262938251,y:-0.036263286295046375},back:{x:0.5220718077341964,y:1.2423201220804008}},{x:-0.21079880538701515,y:0.09967239194517835,front:{x:-0.12608526677354176,y:0.6256843642660479},back:{x:-0.283691850240469,y:-0.36723711157559347}}]},"shape":"polygon"},lineWidth:0.04,color:"#222222",isFill:{"base":true},fillOutline:false,isVisible:true},
		drunkSlug: {pos:{arr:{"base":[{x:0.5,y:0.4450803507546752,front:{x:0.5284136258359071,y:0.4682129602647014},back:{x:0.4713268753422688,y:0.4227983850533267}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07757270722151066,y:0.05659180287623544},back:{x:0.07791774718016264,y:0.03225949632318076}},{x:0.5,y:0.4484325588697263,front:{x:0.5144404605376196,y:0.48213525875604646},back:{x:0.48530004064055676,y:0.41558050279208336}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.0783615147588359,y:0.05758497830877635},back:{x:0.07712893964283718,y:0.03126632089064035}},{x:0.5,y:0.5,front:{x:0.4940156186659346,y:0.533710677716493},back:{x:0.5057248825122409,y:0.4671399660921842}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.0788878357343632,y:0.0602557750899978},back:{x:0.0768651052291085,y:0.026917902760736523}},{x:0.5,y:0.5,front:{x:0.49248248838313335,y:0.5175957353931872},back:{x:0.5082920309743164,y:0.48338880071000945}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.08028956119986153,y:0.05934318053514209},back:{x:0.0754633797636104,y:0.027830497315592173}},{x:0.5,y:0.5,front:{x:0.48059724498351564,y:0.5107512727123769},back:{x:0.5183687368372087,y:0.4891148349931044}},{x:0.07792044288402389,y:-0.34133978762538975,front:{x:0.08230016103774052,y:-0.3472046653486064},back:{x:0.07345277992573096,y:-0.33692438261214186}},{x:0.07792044288402389,y:-0.38398821936385774,front:{x:0.07948862299516035,y:-0.42418414484887523},back:{x:0.0767026941392619,y:-0.3440204425175546}},{x:0.07792044288402389,y:-0.3455982791573212,front:{x:0.07975650096468123,y:-0.363367668076679},back:{x:0.07617232960794307,y:-0.32637941752799604}},{x:0.5,y:-0.5,front:{x:0.5147635930878347,y:-0.5237314243900111},back:{x:0.48497690809034033,y:-0.4754179318013113}},{x:0.07792044288402389,y:-0.3453541748399559,front:{x:0.07572721417733908,y:-0.357486834674811},back:{x:0.0800257267861324,y:-0.3346709877150683}},{x:-0.5,y:-0.5,front:{x:-0.47180610190567385,y:-0.5113814219735802},back:{x:-0.5289684174517764,y:-0.48960311412961577}},{x:0.07792044288402389,y:-0.34157267443221717,front:{x:0.07353843338202526,y:-0.3459520638225957},back:{x:0.08261784061575961,y:-0.3373986188166809}},{x:-0.19049508781558722,y:-0.5,front:{x:-0.14524983253329726,y:-0.5003310302909474},back:{x:-0.2347063249186031,y:-0.4995350774145342}},{x:0.07792044288402389,y:-0.3376260861335435,front:{x:0.07374245864006057,y:-0.3308378369688355},back:{x:0.08217757745210585,y:-0.3431098098592812}},{x:0.5,y:-0.5,front:{x:0.5418717705985694,y:-0.48927266077814136},back:{x:0.45709421122215677,y:-0.5108612315163775}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07456644409921642,y:0.05267278896158695},back:{x:0.08095905343909426,y:0.03615569537395835}}],"base2":[{x:0.5,y:-0.5,front:{x:0.5271439017744224,y:-0.4888848504738652},back:{x:0.47368475612151384,y:-0.5110078487945983}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07617098175601256,y:0.05750439743109159},back:{x:0.07940741745023705,y:0.03279637447829298}},{x:0.5,y:0.44954823816514466,front:{x:0.5202782141659261,y:0.47343293456757884},back:{x:0.4799297471175419,y:0.42498183932960076}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07660935792696333,y:0.058725721502345674},back:{x:0.0785306651083355,y:0.030353726335785647}},{x:0.5,y:0.5,front:{x:0.49645509646723385,y:0.5200912727547671},back:{x:0.5037528648162342,y:0.47922702481212376}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07879854307785616,y:0.05278026290144522},back:{x:0.07713028749476791,y:0.037292360369226674}},{x:0.5,y:0.5,front:{x:0.48164645413896734,y:0.5146271389725215},back:{x:0.5191822037569689,y:0.485480161759015}},{x:0.07792044288402389,y:-0.3409473864077065,front:{x:0.08457863884514061,y:-0.34528221054327},back:{x:0.07135019172748391,y:-0.3351630895621739}},{x:0.07792044288402389,y:-0.39266176617265325,front:{x:0.07764582565485001,y:-0.44521850013123987},back:{x:0.07828300491777407,y:-0.3386555595040992}},{x:0.07792044288402389,y:-0.34469284968096237,front:{x:0.07660261866731033,y:-0.3604089008518949},back:{x:0.0788878357343632,y:-0.3287486498713168}},{x:-0.5,y:-0.5,front:{x:-0.4769642614779712,y:-0.5226602860338608},back:{x:-0.5232952373438537,y:-0.4764890701574632}},{x:0.07792044288402389,y:-0.34263869068521957,front:{x:0.07423889175919518,y:-0.3492821891966019},back:{x:0.08152284368473395,y:-0.33729971761280864}},{x:-0.19049508781558722,y:-0.5,front:{x:-0.1540250671790423,y:-0.5138467511466576},back:{x:-0.22593109027285785,y:-0.48601935655882395}},{x:0.07792044288402389,y:-0.3408582361250826,front:{x:0.07522332763974005,y:-0.34154317833900594},back:{x:0.08033370872154455,y:-0.3399884935138008}},{x:0.5,y:-0.5,front:{x:0.5335674240113364,y:-0.5008331255404028},back:{x:0.46622461470519516,y:-0.4984851720264879}},{x:0.07792044288402389,y:-0.33783058426401513,front:{x:0.07599374429492922,y:-0.3335627470117962},back:{x:0.07993508627769508,y:-0.34064894880626695}}],"base3":[{x:0.5,y:-0.5,front:{x:0.5303139558448793,y:-0.4993292542266401},back:{x:0.4695496007570372,y:-0.5002234808069974}},{x:0.07792044288402389,y:-0.33702527374759705,front:{x:0.07511699195302746,y:-0.3352000846378861},back:{x:0.08107432518139501,y:-0.33907861149602236}},{x:0.5,y:0.5,front:{x:0.5239020968965162,y:0.5169085670441195},back:{x:0.47623434650156726,y:0.48264416798951815}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07827356995425983,y:0.056135505598807756},back:{x:0.0772168844474137,y:0.03271579360060872}},{x:0.5,y:0.5,front:{x:0.5092175078121901,y:0.5235103186742834},back:{x:0.4903752531403689,y:0.4759720163493927}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.07943949417464391,y:0.05515893799136584},back:{x:0.07621713624269777,y:0.0335841721719109}},{x:0.5,y:0.5,front:{x:0.49195820410031565,y:0.5189507935137535},back:{x:0.5081782392977674,y:0.48060194151988367}},{x:0.07792044288402389,y:-0.33619004370199934,front:{x:0.07869780901266465,y:-0.3304681886977848},back:{x:0.07719500728303741,y:-0.34105599956570465}},{x:0.07792044288402389,y:0.04431157528035162,front:{x:0.08704109337327659,y:0.08056198702388773},back:{x:0.06871184759019489,y:0.006611690826847927}},{x:0.07792044288402389,y:-0.34100961184351986,front:{x:0.08422820747876592,y:-0.3451162873403706},back:{x:0.07170062309385838,y:-0.3354534636367028}},{x:0.07792044288402389,y:-0.34364794849981184,front:{x:0.08078680310105835,y:-0.37956466906720177},back:{x:0.07511819442952583,y:-0.3066745623268555}},{x:0.07792044288402389,y:-0.34625016467537195,front:{x:0.07797224094498278,y:-0.35793843859324614},back:{x:0.077549068594442,y:-0.3354522360054414}},{x:0.07792044288402389,y:-0.39141728567652756,front:{x:0.07727342975431828,y:-0.42834183841152573},back:{x:0.07831199154764268,y:-0.3543264125839072}},{x:0.07792044288402389,y:-0.3461789087908228,front:{x:0.07887150545430388,y:-0.35780324932466},back:{x:0.07671391584765708,y:-0.3343882478993636}},{x:0.5,y:0.11559719505653332,front:{x:0.5117190420266189,y:0.10261082406347488},back:{x:0.48743228146895956,y:0.1290538267180309}},{x:0.07792044288402389,y:-0.34495344867734434,front:{x:0.07625353515286615,y:-0.35441531173097895},back:{x:0.07923691924880694,y:-0.3352634369849975}},{x:0.5,y:-0.5,front:{x:0.5278091253504344,y:-0.5149963760227756},back:{x:0.4715867830434268,y:-0.4850818462105143}},{x:0.07792044288402389,y:-0.34340397540361234,front:{x:0.076895799955359,y:-0.3443383561529948},back:{x:0.0789918232875777,y:-0.34169928542777206}},{x:-0.5,y:-0.5,front:{x:-0.554192041712404,y:-0.5000378018660812},back:{x:-0.445807958287596,y:-0.4983417535675083}},{x:0.07792044288402389,y:-0.34008153869972324,front:{x:0.06680270451910686,y:-0.33419938201920685},back:{x:0.08935356947867801,y:-0.34616902915508285}}]},"shape":"polygon"},lineWidth:0.04,color:{"base":"#080","base2":"#0b0","base3":"#0d0"},isFill:true,fillOutline:false,isVisible:true},
		cloningTest: {pos:{arr:{"layer2":[{x:0.16698834091544615,y:0.15684765500454265,front:{x:0.0999550856496684,y:0.0831777120679241},back:{x:0.24653262385135224,y:0.2639890196762842}},{x:-0.12709005856320696,y:0.27063408134428646,front:{x:-0.32583535051856083,y:0.16455920805136018},back:{x:0.06436098109738556,y:0.3518515017309819}},{x:-0.24546007681489743,y:0.00470855792663729,front:{x:0.015863436567978312,y:0.2059267678796339},back:{x:-0.49094859945661473,y:-0.1853114925487999}}],"layer3":[{x:0.20223530949634774,y:0.2229451642523916,front:{x:0.0981522645136487,y:0.20239440920342863},back:{x:0.33956710495963105,y:0.2627622521597577}},{x:0.05189313341022686,y:0.47597633579274956,front:{x:-0.17795692425990003,y:0.5029492017945134},back:{x:0.25861362552864275,y:0.43359040350426326}},{x:-0.22710725105728566,y:0.3334054726405683,front:{x:0.11839063437139533,y:0.34624969454617016},back:{x:-0.5523667666282199,y:0.3205612507349662}}],"layer4":[{x:0.21864006610639444,y:0.01945558628068724,front:{x:0.2893619931850119,y:-0.05143953402877408},back:{x:0.11282618237906564,y:0.10683550662206262}},{x:0.04382257372294143,y:-0.21948736980687508,front:{x:0.1287909876194331,y:-0.4111514935682437},back:{x:-0.014755502719075081,y:-0.03831556920317928}},{x:0.3194937176360978,y:-0.3670823002876897,front:{x:0.13923159416536515,y:-0.1048852366090606},back:{x:0.48993701189728245,y:-0.6135555155704782}}],"layer5":[{x:0.15108107871932855,y:0.06124621070338695,front:{x:0.15672587307592914,y:-0.03335523225558904},back:{x:0.12953353612361465,y:0.18816260725813036}},{x:-0.15459913429669633,y:-0.028767840528922152,front:{x:-0.22245345542466208,y:-0.22574464758216858},back:{x:-0.07345034921852897,y:0.1453973937157522}},{x:-0.042355318236909495,y:-0.2967822027839956,front:{x:0.00037480180215168635,y:0.008108562898733317},back:{x:-0.08174722368232576,y:-0.5839373597364819}}]},"shape":"polygon"},lineWidth:0.02,color:{"layer2":"red","layer3":"red","layer4":"green","layer5":"red"},isFill:{"layer2":true,"layer3":true,"layer4":true,"layer5":true},fillOutline:"black",isVisible:true},
		
		cursorWithPlusSymbol: {pos:{arr:{"cursor":[{x:-0.2989514817004526,y:0.19688114742099072,front:{x:-0.31017445813209776,y:0.11366922935449719},back:{x:-0.28627004572804093,y:0.28009306548748436}},{x:-0.2852297370404937,y:-0.2216504467546493,front:{x:-0.281299058312682,y:-0.26524273328328307},back:{x:-0.2906188753090724,y:-0.17680199590761037}},{x:0.1705151866035084,y:0.15669833613452933,front:{x:0.1419807246839475,y:0.2004329266230812},back:{x:0.19904964852306883,y:0.11532744042753418}},{x:-0.018838145786162608,y:0.15051706425630196,front:{x:-0.03260172267504702,y:0.16490154976249727},back:{x:-0.006444865094640706,y:0.13613257875010654}},{x:0.05475891741852146,y:0.465539557930401,front:{x:-0.03738918397818236,y:0.4863708076233626},back:{x:0.14690701881522528,y:0.44258098293403847}},{x:-0.161511068649137,y:0.17102854441075366,front:{x:-0.18343580780693514,y:0.1618084369795525},back:{x:-0.13958632949133887,y:0.179068422195085}}],"plus":[{x:0.18740228174607132,y:-0.45549708952928386,front:{x:0.2731272925311322,y:-0.45476785975890077},back:{x:0.10021881142024369,y:-0.4562263192996671}},{x:0.24975592853218032,y:-0.322543197566064,front:{x:0.26875191390883246,y:-0.2987126888968708},back:{x:0.22930148361476232,y:-0.34637370623525715}},{x:0.3753635057715393,y:-0.26107182877375174,front:{x:0.3766779199255631,y:-0.16890978976864046},back:{x:0.3755075511582814,y:-0.3532338677788631}},{x:0.24975592853218032,y:-0.19907829545449823,front:{x:0.23229042538966682,y:-0.174743627931707},back:{x:0.2672214316746947,y:-0.2248714225180563}},{x:0.18518758392490697,y:-0.06333352412314452,front:{x:0.10016479440021497,y:-0.06422480495361305},back:{x:0.2702103734495992,y:-0.06390070283344268}},{x:0.12250983501862744,y:-0.19684559195999135,front:{x:0.09440297893051997,y:-0.22186447506980905},back:{x:0.15061669110673515,y:-0.17328516839094027}},{x:0.001187608034855063,y:-0.2544637466569448,front:{x:0.002988175369134642,y:-0.33909041136809526},back:{x:0.001187608034855063,y:-0.1698370819457945}},{x:0.11998904075063599,y:-0.3191311224676037,front:{x:0.14483686996369716,y:-0.34206134746965705},back:{x:0.09368275199680787,y:-0.2962008974655504}}]},"shape":"polygon"},lineWidth:0.04,color:{"cursor":"#ffffff","plus":"#ffffff"},isFill:{"cursor":true},fillOutline:{"cursor":"#000000"},isVisible:true},
		selectionSymbol: {pos:{arr:{"corner1":[{x:-0.16919136480058541,y:-0.30929656055616545,front:{x:-0.17159202341748994,y:-0.2432784485912916},back:{x:-0.1667907061836809,y:-0.374114343212587}},{x:-0.25921606293450417,y:-0.254681577021588,front:{x:-0.2758873033296743,y:-0.23460940358580318},back:{x:-0.24254482253933402,y:-0.27608744968898646}},{x:-0.3128307720453714,y:-0.16519035858031467,front:{x:-0.37378082693011344,y:-0.16512367361873398},back:{x:-0.2518807171606293,y:-0.16392334431028174}},{x:-0.33323637028905967,y:-0.3359705451884376,front:{x:-0.30322813757775346,y:-0.3695797658251006},back:{x:-0.3620442736919136,y:-0.3023613245517746}}],"dot1":[{x:0.11755396999634107,y:-0.31196395901939267,front:{x:0.11820343944383473,y:-0.24513172338090022},back:{x:0.11690450054884742,y:-0.3804427369191365}},{x:-0.10644081595316494,y:-0.31356439809732894,front:{x:-0.10504043175997062,y:-0.37918240029271866},back:{x:-0.10784120014635927,y:-0.24661269667032568}}],"corner2":[{x:0.32410629345042097,y:-0.16437660751677358,front:{x:0.258088181485547,y:-0.1667772661336781},back:{x:0.38892407610684254,y:-0.16197594889986902}},{x:0.26949130991584347,y:-0.2544013056506923,front:{x:0.24941913648005865,y:-0.2710725460458625},back:{x:0.29089718258324193,y:-0.23773006525552218}},{x:0.1800000914745702,y:-0.3080160147615596,front:{x:0.1799334065129895,y:-0.36896606964630163},back:{x:0.17873307720453724,y:-0.24706595987681748}},{x:0.3507802780826931,y:-0.32842161300524786,front:{x:0.384389498719356,y:-0.2984133802939416},back:{x:0.31717105744603014,y:-0.35722951640810174}}],"dot2":[{x:0.32677369191364813,y:0.12236872728015288,front:{x:0.25994145627515575,y:0.12301819672764655},back:{x:0.395252469813392,y:0.12171925783265922}},{x:0.3283741309915844,y:-0.10162605866935312,front:{x:0.3939921331869741,y:-0.1002256744761588},back:{x:0.26142242956458117,y:-0.10302644286254745}}],"corner3":[{x:0.17812479928527863,y:0.3279397315930801,front:{x:0.18052545790218316,y:0.26192161962820626},back:{x:0.1757241406683741,y:0.3927575142495018}},{x:0.2681494974191974,y:0.2733247480585026,front:{x:0.2848207378143675,y:0.2532525746227178},back:{x:0.2514782570240273,y:0.29473062072590106}},{x:0.3217642065300646,y:0.18383352961722915,front:{x:0.38271426141480674,y:0.18376684465564846},back:{x:0.26081415164532246,y:0.1825665153471963}},{x:0.342169804773753,y:0.3546137162253522,front:{x:0.3121615720624467,y:0.38822293686201526},back:{x:0.37097770817660686,y:0.32100449558868915}}],"dot3":[{x:-0.1086205355116478,y:0.3306071300563074,front:{x:-0.10927000495914146,y:0.2637748944178149},back:{x:-0.10797106606415413,y:0.39908590795605126}},{x:0.11537425043785815,y:0.33220756913424354,front:{x:0.11397386624466394,y:0.39782557132963337},back:{x:0.11677463463105259,y:0.2652558677072403}}],"corner4":[{x:-0.31517285896572783,y:0.18301977855368817,front:{x:-0.24915474700085388,y:0.1854204371705927},back:{x:-0.3799906416221494,y:0.18061911993678365}},{x:-0.2605578754311501,y:0.273044476687607,front:{x:-0.2404857019953654,y:0.2897157170827772},back:{x:-0.28196374809854857,y:0.2563732362924368}},{x:-0.17106665698987683,y:0.3266591857984743,front:{x:-0.17099997202829614,y:0.38760924068321634},back:{x:-0.169799642719844,y:0.26570913091373216}},{x:-0.3418468435979997,y:0.34706478404216257,front:{x:-0.37545606423466266,y:0.3170565513308563},back:{x:-0.3082376229613368,y:0.37587268744501656}}],"dot4":[{x:-0.3178402574289549,y:-0.10372555624323825,front:{x:-0.2510080217904624,y:-0.10437502569073191},back:{x:-0.3863190353286989,y:-0.10307608679574458}},{x:-0.31944069650689116,y:0.1202692297062678,front:{x:-0.38505869870228077,y:0.11886884551307347},back:{x:-0.2524889950798878,y:0.12166961389946213}}]},"shape":"polygon"},lineWidth:0.04,color:"#ffffff",isFill:true,fillOutline:"#000000",isVisible:true},
		scalingSymbol: {pos:{arr:{"layer1":[{x:-0.004689403780600898,y:-0.3302245572319534,front:{x:0.33043313459955825,y:-0.33251062450522395},back:{x:-0.3384552256781068,y:-0.3279384899586828}},{x:0.3222928357036392,y:0.0025983467101085567,front:{x:0.3236495521862923,y:0.33635060144278783},back:{x:0.3209361192209861,y:-0.3297971915399177}},{x:0.005912749295816422,y:0.34234661831266655,front:{x:-0.32674793490384446,y:0.34155905276927945},back:{x:0.3385734334954773,y:0.34177746737340053}},{x:-0.32601648047424603,y:0.006635331977380976,front:{x:-0.3302877924525347,y:-0.32572704209195813},back:{x:-0.32174516849595736,y:0.3403544225293732}}],"layer3":[{x:-0.08431234908624075,y:-0.16172249957011303,front:{x:0.16716021606142029,y:-0.1634379413428097},back:{x:-0.33476684789995637,y:-0.16000705779741636}},{x:0.16105181805775248,y:0.08802444314151142,front:{x:0.16206988439169678,y:0.33846876129188774},back:{x:0.16003375172380752,y:-0.16140180867492054}},{x:-0.07635660059166938,y:0.34296811173911607,front:{x:-0.3259818152484264,y:0.34237713051662133},back:{x:0.17326861406508764,y:0.34254102662766633}},{x:-0.32543293923850847,y:0.0910537560774044,front:{x:-0.32863808856960985,y:-0.15834760967308664},back:{x:-0.32222778990740686,y:0.34147318816183997}}],"layer2":[{x:-0.16244329294730253,y:0.001915853121412403,front:{x:0.008596494071585026,y:0.0007490904756619066},back:{x:-0.33279063922687224,y:0.003082615767162844}},{x:0.0044418496356780635,y:0.17178195308715616,front:{x:0.005134290374995909,y:0.3421223749593325},back:{x:0.003749408896360329,y:0.0021339719542974867}},{x:-0.15703216777232254,y:0.34518262108107284,front:{x:-0.3268154740521365,y:0.3447806635062246},back:{x:0.012751138507491655,y:0.3448921379166038}},{x:-0.32644215445848235,y:0.1738423489759261,front:{x:-0.3286221459761789,y:0.004211294172250912},back:{x:-0.3242621629407858,y:0.34416584451891924}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"#222222","layer2":"#ffffff","layer3":"#555555"},isFill:true,fillOutline:"#000000",isVisible:true},
		rotationSymbol: {pos:{arr:{"layer1":[{x:-0.004689403780600898,y:-0.3302245572319534,front:{x:0.33043313459955825,y:-0.33251062450522395},back:{x:-0.3384552256781068,y:-0.3279384899586828}},{x:0.3222928357036392,y:0.0025983467101085567,front:{x:0.3236495521862923,y:0.33635060144278783},back:{x:0.3209361192209861,y:-0.3297971915399177}},{x:0.005912749295816422,y:0.34234661831266655,front:{x:-0.32674793490384446,y:0.34155905276927945},back:{x:0.3385734334954773,y:0.34177746737340053}},{x:-0.32601648047424603,y:0.006635331977380976,front:{x:-0.3302877924525347,y:-0.32572704209195813},back:{x:-0.32174516849595736,y:0.3403544225293732}}],"layer3":[{x:0.17817307364676285,y:-0.28231142765253087,front:{x:0.46528537642526163,y:-0.10945638020766472},back:{x:-0.10778170574332166,y:-0.4544587892775748}},{x:0.2835418385986335,y:0.17220578181161417,front:{x:0.11060865031072423,y:0.4576642211812362},back:{x:0.45576734106672007,y:-0.11209513416959431}},{x:-0.16360566165241328,y:0.29704311657804916,front:{x:-0.4470143017889909,y:0.12284985101474624},back:{x:0.12051066430398685,y:0.4700788587529384}},{x:-0.2716884716853795,y:-0.16251883520213994,front:{x:-0.10196694283138139,y:-0.44831175751912905},back:{x:-0.4421176863592004,y:0.12443161050326326}}]},"shape":"polygon"},lineWidth:0.04,color:{"layer1":"#000000","layer3":"#ffffff"},isFill:{"layer1":true,"layer3":true},fillOutline:"#000000",isVisible:{}},
		vertexTypesSymbol: {pos:{arr:{"layer1":[{x:-0.3656531284302961,y:-0.34055342114892023,front:{x:-0.1602634467618001,y:-0.4965962312477126},back:{x:-0.36608122941822147,y:-0.32921697768020464}},{x:0.2825246981339187,y:-0.34855561653860195,front:{x:0.2875960482985729,y:-0.3390962312477129},back:{x:0.08780461031833148,y:-0.16183772411269645}},{x:0.3572118551042807,y:-0.17917581412367334,front:{x:0.1904994511525794,y:-0.005794914013903973},back:{x:0.3649835345773873,y:-0.18761434321258671}},{x:-0.32297475301866047,y:-0.18984540797658225,front:{x:-0.3347969264544454,y:-0.19749359678009498},back:{x:-0.11358397365532358,y:-0.35655781192828356}}],"layer2":[{x:-0.3458946212952797,y:-0.00301225759238917,front:{x:-0.14050493962678368,y:-0.15905506769118163},back:{x:-0.35126234906695913,y:0.0017380168313209793}},{x:0.3022832052689351,y:-0.01101445298207089,front:{x:0.30699231613611405,y:-0.0037532016099523433},back:{x:0.2989077936333697,y:-0.01827570435418944}},{x:0.37697036223929714,y:0.1583653494328577,front:{x:0.36700878155872624,y:0.1656266008049763},back:{x:0.38559824368825446,y:0.15110409806073913}},{x:-0.30321624588364404,y:0.1476957555799488,front:{x:-0.31009879253567485,y:0.148280278082693},back:{x:-0.09382546652030715,y:-0.0190166483717525}}],"layer3":[{x:-0.32412367361873384,y:0.23024789608488835},{x:0.32405415294548096,y:0.22224570069520663},{x:0.398741309915843,y:0.3916255031101353},{x:-0.2814452982070982,y:0.3809559092572264}]},"shape":"polygon"},lineWidth:0.04,color:"#ffffff",isFill:true,fillOutline:"#000000",isVisible:true},
		
		deleteSelectedSymbol: {pos:{arr:{"corner1":[{x:-0.16919136480058541,y:-0.30929656055616545,front:{x:-0.17159202341748994,y:-0.2432784485912916},back:{x:-0.1667907061836809,y:-0.374114343212587}},{x:-0.25921606293450417,y:-0.254681577021588,front:{x:-0.2758873033296743,y:-0.23460940358580318},back:{x:-0.24254482253933402,y:-0.27608744968898646}},{x:-0.3128307720453714,y:-0.16519035858031467,front:{x:-0.37378082693011344,y:-0.16512367361873398},back:{x:-0.2518807171606293,y:-0.16392334431028174}},{x:-0.33323637028905967,y:-0.3359705451884376,front:{x:-0.30322813757775346,y:-0.3695797658251006},back:{x:-0.3620442736919136,y:-0.3023613245517746}}],"dot1":[{x:0.11755396999634107,y:-0.31196395901939267,front:{x:0.11820343944383473,y:-0.24513172338090022},back:{x:0.11690450054884742,y:-0.3804427369191365}},{x:-0.10644081595316494,y:-0.31356439809732894,front:{x:-0.10504043175997062,y:-0.37918240029271866},back:{x:-0.10784120014635927,y:-0.24661269667032568}}],"corner2":[{x:0.32410629345042097,y:-0.16437660751677358,front:{x:0.258088181485547,y:-0.1667772661336781},back:{x:0.38892407610684254,y:-0.16197594889986902}},{x:0.26949130991584347,y:-0.2544013056506923,front:{x:0.24941913648005865,y:-0.2710725460458625},back:{x:0.29089718258324193,y:-0.23773006525552218}},{x:0.1800000914745702,y:-0.3080160147615596,front:{x:0.1799334065129895,y:-0.36896606964630163},back:{x:0.17873307720453724,y:-0.24706595987681748}},{x:0.3507802780826931,y:-0.32842161300524786,front:{x:0.384389498719356,y:-0.2984133802939416},back:{x:0.31717105744603014,y:-0.35722951640810174}}],"dot2":[{x:0.32677369191364813,y:0.12236872728015288,front:{x:0.25994145627515575,y:0.12301819672764655},back:{x:0.395252469813392,y:0.12171925783265922}},{x:0.3283741309915844,y:-0.10162605866935312,front:{x:0.3939921331869741,y:-0.1002256744761588},back:{x:0.26142242956458117,y:-0.10302644286254745}}],"corner3":[{x:0.17812479928527863,y:0.3279397315930801,front:{x:0.18052545790218316,y:0.26192161962820626},back:{x:0.1757241406683741,y:0.3927575142495018}},{x:0.2681494974191974,y:0.2733247480585026,front:{x:0.2848207378143675,y:0.2532525746227178},back:{x:0.2514782570240273,y:0.29473062072590106}},{x:0.3217642065300646,y:0.18383352961722915,front:{x:0.38271426141480674,y:0.18376684465564846},back:{x:0.26081415164532246,y:0.1825665153471963}},{x:0.342169804773753,y:0.3546137162253522,front:{x:0.3121615720624467,y:0.38822293686201526},back:{x:0.37097770817660686,y:0.32100449558868915}}],"dot3":[{x:-0.1086205355116478,y:0.3306071300563074,front:{x:-0.10927000495914146,y:0.2637748944178149},back:{x:-0.10797106606415413,y:0.39908590795605126}},{x:0.11537425043785815,y:0.33220756913424354,front:{x:0.11397386624466394,y:0.39782557132963337},back:{x:0.11677463463105259,y:0.2652558677072403}}],"corner4":[{x:-0.31517285896572783,y:0.18301977855368817,front:{x:-0.24915474700085388,y:0.1854204371705927},back:{x:-0.3799906416221494,y:0.18061911993678365}},{x:-0.2605578754311501,y:0.273044476687607,front:{x:-0.2404857019953654,y:0.2897157170827772},back:{x:-0.28196374809854857,y:0.2563732362924368}},{x:-0.17106665698987683,y:0.3266591857984743,front:{x:-0.17099997202829614,y:0.38760924068321634},back:{x:-0.169799642719844,y:0.26570913091373216}},{x:-0.3418468435979997,y:0.34706478404216257,front:{x:-0.37545606423466266,y:0.3170565513308563},back:{x:-0.3082376229613368,y:0.37587268744501656}}],"dot4":[{x:-0.3178402574289549,y:-0.10372555624323825,front:{x:-0.2510080217904624,y:-0.10437502569073191},back:{x:-0.3863190353286989,y:-0.10307608679574458}},{x:-0.31944069650689116,y:0.1202692297062678,front:{x:-0.38505869870228077,y:0.11886884551307347},back:{x:-0.2524889950798878,y:0.12166961389946213}}],x:[{x:0.14999766068491954,y:0.15407877926824373,front:{x:0.08527786377773022,y:0.21770677079180697},back:{x:0.2158092629757355,y:0.08935898236105408}},{x:0.003790092830647962,y:0.10122731125343773,front:{x:-0.028269896119420157,y:0.09760817859289841},back:{x:0.03694188716434205,y:0.10375463853035125}},{x:-0.1362575360073614,y:0.1492397899753811,front:{x:-0.20623417365052982,y:0.08123109783850166},back:{x:-0.06737270374781873,y:0.2183402874958865}},{x:-0.08863595057091395,y:0.00880126785187571,front:{x:-0.08726673984632267,y:-0.03375411635565311},back:{x:-0.09000516129550522,y:0.0530031943206559}},{x:-0.1419187491076464,y:-0.14115348391163235,front:{x:-0.07760332456476277,y:-0.20413447965230583},back:{x:-0.20514236826690374,y:-0.07708068278733218}},{x:0.004949293608325245,y:-0.08812678787229364,front:{x:0.04471931563782888,y:-0.09043844988824343},back:{x:-0.033728923037552205,y:-0.08472332047271733}},{x:0.14423917575057682,y:-0.14248426486085966,front:{x:0.20624293827751067,y:-0.0777846865718855},back:{x:0.08088750534262285,y:-0.20583593526881372}},{x:0.09837952838124714,y:0.0015293048337716997,front:{x:0.09694400648796048,y:0.037296040456645446},back:{x:0.10090685565816021,y:-0.035329236172728734}}]},"shape":"polygon"},lineWidth:0.04,color:{"corner1":"#ffffff","dot1":"#ffffff","corner2":"#ffffff","dot2":"#ffffff","corner3":"#ffffff","dot3":"#ffffff","corner4":"#ffffff","dot4":"#ffffff",x:"#dd0000"},isFill:true,fillOutline:"#000000",isVisible:true},
		moveSelectedToEdgeSymbol: {pos:{arr:{"corner":[{x:0.3007919875305398,y:-0.2693189667550687,front:{x:0.2979462847528056,y:-0.19106214036737634},back:{x:0.30363769030827403,y:-0.346152941753894}},{x:-0.18710551031865286,y:-0.20457922856161415,front:{x:-0.20686733516402966,y:-0.1807859914477804},back:{x:-0.16734368547327594,y:-0.22995341166307792}},{x:-0.2506595390213848,y:0.3248444505626637,front:{x:-0.3229087706560825,y:0.3249234978620452},back:{x:-0.17841030738668706,y:0.3263463492509124}},{x:-0.2748480126321261,y:-0.3009378865076715,front:{x:-0.23927672791044785,y:-0.3407777253959514},back:{x:-0.30899644596493725,y:-0.2610980476193919}}],"arrow":[{x:-0.09590795230483151,y:-0.12553000195580077,front:{x:-0.08543773416393352,y:-0.13556869777957847},back:{x:-0.10506939317811714,y:-0.11692540553541986}},{x:0.19006158674985563,y:-0.06508502372996738,front:{x:0.19398791855269226,y:-0.02923253864504738},back:{x:0.186135254947019,y:-0.0995034094114906}},{x:0.12331394610163149,y:0.029565536894221478,front:{x:0.11677005976357013,y:0.046774729734983145},back:{x:0.12854905517208048,y:0.012356344053459811}},{x:0.2822279575329769,y:0.301721916290088,front:{x:0.22856808956087526,y:0.35334949481237277},back:{x:0.33588782550507856,y:0.25152843717120005}},{x:0.03693464643922373,y:0.11130920288783908,front:{x:0.022538096495489324,y:0.11417740169463275},back:{x:0.051331196382958355,y:0.10700690467764873}},{x:-0.06384120316691844,y:0.16723907962031437,front:{x:-0.0952518575896123,y:0.15863448319993356},back:{x:-0.032430548744224685,y:0.1744095766372984}}]},"shape":"polygon"},lineWidth:0.04,color:"#ffffff",isFill:true,fillOutline:"#000000",isVisible:true},
		
		emptyBox: {pos:{arr:{"base":[{x:-0.5,y:-0.5},{x:0.5,y:-0.5},{x:0.5,y:0.5},{x:-0.5,y:0.5}]},"shape":"polygon"},lineWidth:{"base":0.01},color:"#222222",isFill:false,fillOutline:false,isVisible:true},
	};
	
</script>

<script src="GameData.js"></script>
<script src="GameDataExtra.js"></script>
<script> //Current Game States
	
	for (let i in gameData){
		if (!currentGame.states.includes(i) && i != "Game Selection"){
			currentGame.states.push(i);
		}
	}
	
</script>

<script> //General
	
	let t = 0;
	function slowLog(...text){ //so console.log won't stop the browser
		if (t % Math.floor(fps/2) == 0){
			console.log(...text);
		}
	}
	function log(...text){
		console.log(...text);
	}
	
	
	function modulo(n, m){ //https://stackoverflow.com/a/17323608
		return ((n % m) + m) % m;
	}
	
	function getNumInRange(num, min, max, type){ //could be more clever
		if (type == "loop"){
			if (num < min){ num = max; }
			if (num > max){ num = min; }
		} else{
			if (num < min){ num = min; }
			if (num > max){ num = max; }
		}
		
		return num;
	}
	
	
	function insertIntoArray(arr, value, index){
		arr.splice(index, 0, value);
	}
	
	
	function objectLength(arr){
		let length = 0;
		
		if (arr != undefined){
			length = Object.keys(arr).length;
		}
		return length;
	}
	
	function getElementsOfObject(arr){
		let elements = [];
		
		for (let i in arr){
			elements.push({name: i, value: arr[i]});
		}
		return elements;
	}
	
	function getElementOfObjectByIndex(arr, index){
		let element;
		
		let name = Object.keys(arr)[index];
		
		return {name: name, value: arr[name]};
	}
	
	
	function range(size){ //example: for (let i of range(10))
		return [...Array(size).keys()];
	}
	
	
	function getSlicedString(s, span){
		return s.slice(span.start, span.end + 1);
	}
	
	function getReversedString(s){ //https://stackoverflow.com/a/959004 (doesn't work on double characters like ðŒ†)
		return s.split("").reverse().join("");
	}
	
	function getCharacterOccurrenceInString(c, s){ //https://stackoverflow.com/a/10671743
		return (s.match(new RegExp(c, "g")) || []).length;
	}
	
	
	function containsExcludedWords(text, exclusionArray = []){
		return exclusionArray.some(word => text.includes(word));
	}
	
	
	function getTextWithoutPunctuation(text){
		return text.replace(/[^\p{L}0-9'-]+/gu, ' ').trim();
	}
	
	function getWordsOfTextWithoutPunctuation(text){
		return text.match(/[\p{L}0-9'-]+/gu) || [];
	}
	
	
	function getNumWithTruncatedDecimals(num, decimalsAmount){ //https://stackoverflow.com/a/11818658 (modified)
		let result = num;
		
		if (isNumberWithoutInfinity(num)){
			let regex = new RegExp('^-?\\d+(?:\.\\d{0,' + decimalsAmount + '})?');
			
			let arr = (num + "").split("e");
			
			
			result = arr[0].toString().match(regex)[0];
			
			result = result.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, ''); //turns 1.000 to 1
			
			result += (arr[1] != undefined ? "e" + arr[1] : "");
		}
		return result;
	}
	
	
	function removeExtraSpacesFromText(text){ //https://www.geeksforgeeks.org/how-to-replace-multiple-spaces-with-single-space-in-javascript/
		return text.trim().replace(/\s+/g, " ");
	}
	
	
	function getEvaluatedText(text, isCurlyBrackets = true, quoteInfinity = false, args){
		let evalText = "";
		
		let symbols = {
			open: (isCurlyBrackets) ? "{{" : "<<",
			close: (isCurlyBrackets) ? "}}" : ">>"
		}
		
		if ((text + "").includes(symbols.open) && shouldEvalText){
			let regex = new RegExp("(?=" + symbols.open + ")"); //split before symbols.open
			let arr = text.split(regex);
			
			let currentArr = [];
			let currentText = "";
			let depth = 1;
			for (let i in arr){ //undo symbols.open splits if they're nested
				currentText += arr[i];
				
				let num = getCharacterOccurrenceInString(symbols.close, currentText);
				if (num >= depth || !currentText.startsWith(symbols.open)){
					currentArr.push(currentText);
					
					currentText = "";
					depth = 1;
				} else{
					depth++;
				}
			}
			
			let splitArr = [];
			for (let i in currentArr){ //split at last symbols.close and remove starting symbols.open
				let lastSymbolIndex = currentArr[i].lastIndexOf(symbols.close);
				if (lastSymbolIndex != -1){
					currentText = currentArr[i].slice(0, lastSymbolIndex);
					
					if (currentText.startsWith(symbols.open)){
						currentText = currentText.slice(symbols.open.length);
					}
					
					splitArr.push({shouldEval: true, text: currentText});
					splitArr.push({shouldEval: false, text: currentArr[i].slice(lastSymbolIndex + symbols.close.length)});
				} else{
					splitArr.push({shouldEval: false, text: currentArr[i]});
				}
			}
			
			evalText = "";
			for (let i = 0; i < splitArr.length; i++){
				if (splitArr[i].shouldEval){
					let evaledValue = functionEval(splitArr[i].text, {...args, shouldEval: false});
					
					//remove quotes around replaced numbers
					let isNumberFunction = (quoteInfinity) ? isNumberWithoutInfinity : isNumber;
					
					//if number surrounded by "" then remove quotes
					if (isNumberFunction(evaledValue) && i > 0){
						if (evalText[evalText.length - 1] == '"' && (splitArr[i + 1] ?? {text: ""}).text[0] == '"'){
							evalText = evalText.slice(0, -1);
							splitArr[i + 1].text = splitArr[i + 1].text.slice(1);
							
							shouldLoop = true;
						}
					}
					
					evalText += evaledValue;
				} else{
					evalText += splitArr[i].text;
				}
			}
		} else{
			evalText = text;
		}
		
		return evalText;
	}
	
	function getEvaluatedObject(arr, isCurlyBrackets = true){
		return parse(getEvaluatedText(stringify(arr), isCurlyBrackets));
	}
	
	
	function functionEval(text, args = {}){
		let argsText = "";
		
		if (args != undefined){
			argsText = "let args = " + stringify(args) + ";";
		}
		
		if (args.shouldEval){
			text = getEvaluatedText(text, false);
		}
		
		text = text.replaceAll('\\"', '"').replaceAll('\n', '').replaceAll('\t', '');
		
		//the eval version can return the final value all the time and it doesn't need the curly bracket trick ( `<<{}>>` )		//clarification: if you have a code like "let a = 1; a", the eval would log the value of a. Both methods support multi-line codes but sometimes the function method needed curly brackets around them, except for when the code started out with an if or for statement (for some reason I couldn't reproduce these recently though *thinking emoji*)
		if (true){
			let returnValue;
			
			try {
				returnValue = eval(argsText + text);
			} catch(e){
				returnValue = eval(argsText + "let returnText = " + text + "; returnText"); //can return things like: "{a1: 1, a2: 2}"
			}
			
			return returnValue;
		} else{
			let returnValue;
			
			try {
				returnValue = (new Function(argsText + "return " + text)());
			} catch (e){
				returnValue = (new Function(argsText + text)());
			}
			
			return returnValue;
		}
	}
	
	
	function getRandomElementOfArray(arr){
		return arr[Math.floor(Math.random() * arr.length)];
	}
	function getRandomElementNameOfObject(arr){ //https://stackoverflow.com/a/15106541/12777947
		let keys = Object.keys(arr);
		
		return keys[keys.length * Math.random() << 0];
	}
	function getRandomElementOfObject(arr){
		return arr[getRandomElementNameOfObject(arr)];
	}
	
	function getRandomElementWithoutRepeats(arr, startingValue, f){
		let value = startingValue;
		let i = 0;
		
		f ??= getRandomElementOfArray;
		
		while (value == startingValue && i < 100){
			value = f(arr);
			i++;
		}
		return value;
	}
	
	function getRandomElementOfArrayWithoutRepeats(arr, startingValue){
		return getRandomElementWithoutRepeats(arr, startingValue, getRandomElementOfArray);
	}
	function getRandomElementOfObjectWithoutRepeats(arr, startingValue){
		return getRandomElementWithoutRepeats(arr, startingValue, getRandomElementOfObject);
	}
	function getRandomElementNameOfObjectWithoutRepeats(arr, startingValue){
		return getRandomElementWithoutRepeats(arr, startingValue, getRandomElementNameOfObject);
	}
	
	function getRandomElementOfArrayWithWeights(arr){
		let overallWeights = 0;
		
		for (let i in arr){
			overallWeights += arr[i].weight;
		}
		
		let num = getRandomNumWithDecimals({min: 0, max: overallWeights});
		let counter = 0;
		
		let elementNum = -1;
		
		for (let i = 0; i < arr.length; i++){
			counter += arr[i].weight;
			
			if (counter >= num){
				elementNum = i;
				
				i = arr.length;
			}
		}
		
		return arr[elementNum];
	}
	
	
	function getBiggestLengthOfArray(arr){
		let biggestLength = 0;
		
		for (let i in arr){
			let length = (arr[i] + "").length;
			
			if (biggestLength < length){
				biggestLength = length;
			}
		}
		return biggestLength;
	}
	
	
	function areArraysEqual(a, b){ //https://stackoverflow.com/a/16436975/12777947
		if (a === b) return true;
		if (a == null || b == null) return false;
		if (a.length !== b.length) return false;
		
		for (var i = 0; i < a.length; ++i){
			if (a[i] !== b[i]) return false;
		}
		return true;
	}
	
	function compareObjects1D(a, b){ //https://stackoverflow.com/a/68091909
		return (Object.entries(a).sort().toString() === Object.entries(b).sort().toString());
	}
	
	
	function getArrayWithoutValue(arr, value){ //https://stackoverflow.com/a/5767357
		let index = arr.indexOf(value);
		
		if (index > -1){
			arr.splice(index, 1);
		}
	}
	
	function getArrayWithoutRemoveArrayElements(arr, removeArr){ //https://stackoverflow.com/a/19957433
		return arr.filter( function (el){
			return !removeArr.includes(el);
		});
	}
	
	
	function removeDuplicateObjectsInArray(arr){
		let currentArr = [];
		let includeArr = {};
		
		for (let i in arr){
			let value = "";
			for (let j in arr[i]){
				value += j + ":" + arr[i][j] + ",";
			}
			
			if (!includeArr[value]){
				includeArr[value] = true;
				
				currentArr.push(arr[i]);
			}
		}
		
		return currentArr;
	}
	
	
	function calculateObjectsByOperator(a, b, operatorType){
		let c = {};
		
		if (isArray(a) && isArray(b)){
			c = [];
		}
		
		let arrs = [a, b];
		
		for (let arrNum in arrs){
			let arr = arrs[arrNum];
			let otherArr = arrs[1 - arrNum];
			
			for (let i in arr){
				if (c[i] == undefined){
					if (isNumber(arr[i])){
						c[i] = arr[i];
						
						if (isNumber(otherArr[i])){
							switch (operatorType){
								case "+": c[i] += otherArr[i]; break;
								case "-": c[i] -= otherArr[i]; break;
								case "*": c[i] *= otherArr[i]; break;
								case "/": c[i] /= otherArr[i]; break;
							}
						}
					} else{
						if (arr[i] != undefined){
							if (isArrayOrObject(arr[i])){
								if (isArrayOrObject(otherArr[i])){
									c[i] = calculateObjectsByOperator(arr[i], otherArr[i] ?? [], operatorType);
								} else{
									c[i] = structuredClone(arr[i]);
								}
							} else{
								c[i] = arr[i];
							}
						}
					}
				}
			}
		}
		return c;
	}
	
	function addObjects(a, b){ return calculateObjectsByOperator(a, b, "+");}
	function subtractObjects(a, b){ return calculateObjectsByOperator(a, b, "-");}
	function multiplyObjects(a, b){ return calculateObjectsByOperator(a, b, "*");}
	function divideObjects(a, b){ return calculateObjectsByOperator(a, b, "/");}
	
	function combineValues(value1, value2){
		let combinedValue;
		
		if (isArrayOrObject(value1) && isArrayOrObject(value2)){
			combinedValue = calculateObjectsByOperator(value1, value2);
		} else{
			if (!isArrayOrObject(value2)){
				combinedValue = value2;
			}
			if (!isArrayOrObject(value1)){
				combinedValue = value1;
			}
		}
		return combinedValue;
	}
	
	
	function shuffleArray(arr){ //https://stackoverflow.com/a/3718452/12777947
		for (let i = 0; i < arr.length - 1; i++){
			let j = i + Math.floor(Math.random() * (arr.length - i));
			
			let temp = arr[j];
			arr[j] = arr[i];
			arr[i] = temp;
		}
		return arr;
	}
	
	function shuffleObject(arr){
		let values = Object.values(arr);
		
		let shuffledArray = shuffleArray(values);
		
		let num = 0;
		for (let i in arr){
			arr[i] = shuffledArray[num];
			
			num++;
		}
	}
	
	
	function sortObjectByValue(arr, valueName, isSmallToBig){ //https://stackoverflow.com/a/1063027/1277794
		if (isSmallToBig){
			arr.sort((a,b) => a[valueName] - b[valueName]);
		} else{
			arr.sort((a,b) => b[valueName] - a[valueName]);
		}
	}
	
	function sortObjectBy2DValue(arr, valueName1, valueName2, isSmallToBig){
		if (isSmallToBig){
			arr.sort((a,b) => a[valueName1][valueName2] - b[valueName1][valueName2]);
		} else{
			arr.sort((a,b) => b[valueName1][valueName2] - a[valueName1][valueName2]);
		}
	}
	
	
	function getObjectKeyWithHighestValue(arr){ //https://stackoverflow.com/a/27376421
		return Object.keys(arr).reduce((a, b) => arr[a] > arr[b] ? a : b);
	}
	
	
	function getAverageOfArray(arr){
		return arr.reduce((a, b) => a + b) / arr.length;
	}
	
	
	function toggleWindowBoolean(name){
		window[name] = !window[name];
	}
	
	
	function capitalizeFirstLetter(s){ //https://stackoverflow.com/a/1026087/12777947
		return s.charAt(0).toUpperCase() + s.slice(1);
	}
	
	
	function getCurrentTime(){
		return new Date().getTime();
	}
	
	
	function copyTextToClipboard(text){
		navigator.clipboard.writeText(text);
	}
	
	
	function isArray(arr){
		return Array.isArray(arr);
	}
	function isArrayOrObject(arr){
		return (typeof arr === 'object' && arr !== null);
	}
	function isObject(arr){
		return (isArrayOrObject(arr) && !isArray(arr));
	}
	
	function isObjectInArray(obj, arr){
		let isTrue = false;
		
		for (let i in arr){
			if (compareObjects1D(arr[i], obj)){
				isTrue = true;
				
				break;
			}
		}
		return isTrue;
	}
	
	
	function incrementValueInArray(i, arr, num = 1){
		if (arr[i] == undefined){
			arr[i] = 0;
		}
		
		arr[i] += num;
		
		return arr;
	}
	
	
	function isArrInArr(includeArr, arr){
		let doesInclude = false;
		
		for (let i = 0; i < arr?.length; i++){
			if (isArray(includeArr)){
				doesInclude = areArraysEqual(arr[i], includeArr);
			}
			if (isObject(includeArr)){
				doesInclude = compareObjects1D(arr[i], includeArr);
			}
			
			if (doesInclude){
				i = arr.length;
			}
		}
		return doesInclude;
	}
	
	
	function isPosInArr(pos, arr){
		let isInArr = false;
		
		if (arr[pos.y] != undefined){
			if (arr[pos.y][pos.x] != undefined){
				isInArr = true;
			}
		}
		return isInArr;
	}
	
	function getPosInArr(pos, arr){
		let value;
		
		if (arr[pos.y] != undefined){
			if (arr[pos.y][pos.x] != undefined){
				value = arr[pos.y][pos.x];
			}
		}
		return value;
	}
	
	
	function setValueInArrAtPos(value, arr, pos){
		if (arr[pos.y] == undefined){
			arr[pos.y] = [];
		}
		
		arr[pos.y][pos.x] = value;
		
		return arr;
	}
	
	
	function getMirroredArray(arr){
		return arr.reverse();
	}
	
	function getMirroredArray2D(arr){
		for (let i in arr){
			arr[i] = arr[i].reverse();
		}
		return arr;
	}
	
	function getRotatedArray2D(arr, radians){
		let positionArr = [];
		
		let min = {x: 0, y: 0};
		
		for (let i = 0; i < arr.length; i++){
			for (let j = 0; j < arr[i].length; j++){
				let pos = {
					x: Math.round((Math.cos(radians) * j) + (Math.sin(radians) * i)),
					y: Math.round((Math.cos(radians) * i) - (Math.sin(radians) * j)),
					i: i,
					j: j
				};
				
				positionArr.push(pos);
				
				if (pos.x < min.x){ min.x = pos.x };
				if (pos.y < min.y){ min.y = pos.y };
			}
		}
		
		let rotatedArr = [];
		
		for (let i in positionArr){
			let pos = positionArr[i];
			
			pos.x -= min.x;
			pos.y -= min.y;
			
			if (rotatedArr[pos.y] == undefined){
				rotatedArr[pos.y] = [];
			}
			rotatedArr[pos.y][pos.x] = arr[pos.i][pos.j];
		}
		return rotatedArr;
	}
	
	
	function getRandomNumberFromPercentages(percentages){
		let num = 0;
		let randomNum = Math.random();
		let result = 0;
		
		for (let i in percentages){
			if (randomNum < num + percentages[i]){
				result = Number(i);
				
				break;
			} else{
				num += percentages[i];
			}
		}
		return result;
	}
	
	function getRandomOccurrencesFromPercentages(percentages, attempts){ //Mostly AI Generated, isn't perfect past Number.MAX_SAFE_INTEGER
		let results = [];
		
		let sum = 0;
		for (let i = 0; i < percentages.length; i++){
			let mean = attempts * percentages[i];
			let stdDev = Math.sqrt(attempts * percentages[i] * (1 - percentages[i]));
			
			let randomOccurrences = Math.round(mean + (Math.random() * 2 - 1) * stdDev);
			
			results.push(Math.max(0, Math.min(attempts, randomOccurrences)));
			
			sum += results[i];
		}
		
		sum = Math.max(sum, 1);
		
		let scalingFactor = attempts / sum;
		for (let i = 0; i < results.length; i++){
			results[i] = Math.floor(results[i] * scalingFactor);
		}
		
		
		let currentSum = results.reduce((acc, value) => acc + value, 0);
		
		if (attempts < Number.MAX_SAFE_INTEGER){
			for (let i = 0; i < attempts - currentSum; i++){
				results[getRandomNumberFromPercentages(percentages)]++;
			}
		} else if (attempts >= Number.MAX_VALUE){
			for (let i in results){
				results[i] = Infinity;
			}
		}
		
		return results;
	}
	
	
	function stringify(value){
		return JSON.stringify(value, (key, value) => {
			if (value === Infinity){ return 'Infinity'; }
			
			if (value === -Infinity){ return '-Infinity'; }
			
			if (Number.isNaN(value)){ return 'NaN'; }
			
			if (value instanceof RegExp || typeof value === 'function' || typeof value === 'symbol'){
				return value.toString();
			}
			
			if (typeof value === 'bigint'){ return value.toString() + "n"; }
			
			return value;
		});
	}
	
	function parse(text){ //this and the stringify was made with AI
		try {
			text = text.replace(/\n/g, '\\n').replace(/\t/g, '\\t');
			
			let result = JSON.parse(text, (key, value) => {
				if (value === 'Infinity'){ return Infinity; }
				
				if (value === '-Infinity'){ return -Infinity; }
				
				if (value === 'NaN'){ return NaN; }
				
				if (typeof value === 'string' && /^\/.*\/$/.test(value)){
					try {
						return new RegExp(value.slice(1, -1));
					} catch (e){
						return value;
					}
				}
				
				if (typeof value === 'string' && value.startsWith('function')){
					try {
						return new Function('return ' + value)();
					} catch (e){
						return value;
					}
				}
				
				if (typeof value === 'string' && /^Symbol\((.*)\)$/.test(value)){
					let symbolText = value.match(/^Symbol\((.*)\)$/)[1];
					return Symbol(symbolText);
				}
				
				if (typeof value === 'string' && /^[0-9]+n$/.test(value)){
					return BigInt(value.slice(0, -1));
				}
				
				return value;
			});
			
			return result;
		} catch (e){
			return text;
		}
	}
	
	
	function isNaNOrInfinity(value){
		return isNaN(value) || value == Infinity || value == -Infinity;
	}
	
	function isNumber(value){
		return !isNaN(value) && value !== "";
	}
	function isNumberWithoutInfinity(value){
		return isNumber(value) && value != Infinity && value != -Infinity;
	}
	
	
</script>
<script> //General 2 (Events Functions)
	
	function getArrayWithReplacedValues(arr, values){
		let text = stringify(arr);
		
		let args = {...values};
		let valuesText = stringify(values ?? "");
		
		let savedValues = {};
		
		if (isObject(values)){
			for (let i in values){
				if (isNumberWithoutInfinity(values[i])){
					text = text.replaceAll("\"{{" + i + "}}\"", values[i]);
					valuesText = valuesText.replaceAll("\"{{" + i + "}}\"", values[i]);
				}
				text = text.replaceAll("{{" + i + "}}", values[i]);
				valuesText = valuesText.replaceAll("{{" + i + "}}", values[i]);
			}
		}
		arr = parse(text);
		values = parse(valuesText);
		
		if (isObject(values)){
			for (let i in values){
				if (isObject(values[i])){
					if (values[i].f != undefined || values[i].event != undefined){
						values[i] = runEvent({name: values[i]});
						
						if (values[i] != undefined){
							savedValues[i] = values[i];
						}
					}
				}
			}
		}
		
		for (let i in savedValues){
			if (isObject(arr[i])){ arr[i] = savedValues[i]; }
			
			if (arr.args != undefined){ if (isObject(arr.args[i])){ arr.args[i] = savedValues[i]; } }
			if (arr.extraArgs != undefined){ if (isObject(arr.extraArgs[i])){ arr.extraArgs[i] = savedValues[i]; } }
		}
		
		text = getEvaluatedText(stringify(arr), false, true, args);
		arr = parse(text);
		
		return arr;
	}
	
	function replaceValuesInArray(args){
		window[args.arrName] = getArrayWithReplacedValues(window[args.arrName]);
	}
	
	
	
	function getConditionalArrayValue(arr, args){
		let isArr = isArray(arr);
		
		let result = {};
		
		if (isArr){
			for (let i in arr){
				if (typeof arr[i] != "string"){
					let currentResult = getConditionalArrayValue(arr[i], args);
					
					result = {...result, ...currentResult};
				} else{
					getEvaluatedText(arr[i], false, false, args);
				}
			}
		} else if (arr != undefined){
			for (let i in arr){
				if (i != "value" && i != "isTrue" && i != "isFalse" && i != "f" && i != "event" && i != "args" && i != "extraArgs"){
					result[i] = arr[i];
				}
			}
			
			if (arr.f != undefined || arr.event != undefined){
				runEvent([arr], args);
			}
			
			if (arr.value != undefined){
				let isTrue = false;
				
				if (isObject(arr.value)){
					isTrue = (args[arr.value.name] == arr.value.value);
				} else{
					isTrue = functionEval(arr.value.replaceAll("<<","").replaceAll(">>",""), args)
				}
				
				if (isTrue && arr.isTrue != undefined){
					result = {...result, ...getConditionalArrayValue(arr.isTrue, args)};
				}
				if (!isTrue && arr.isFalse != undefined){
					result = {...result, ...getConditionalArrayValue(arr.isFalse, args)};
				}
			}
		}
		
		return result;
	}
	
	
	
	function runEventOfArrayWithState(args){
		runEvent({name: window[args.eventArrName][window[args.stateVarName].currentState]}, args);
	}
	
	
	
	function setVariableToValue(args){
		window[args.varName] = args.value;
	}
	
	function addValueToVariable(args){
		window[args.varName] += args.value;
	}
	function subtractValueFromVariable(args){
		window[args.varName] -= args.value;
	}
	function multiplyVariableByValue(args){
		window[args.varName] *= args.value;
	}
	function divideVariableByValue(args){
		window[args.varName] /= args.value;
	}
	
	function addToValueOfArray(args){
		window[args.arrName][args.index] += args.value;
	}
	function subtractFromValueOfArray(args){
		window[args.arrName][args.index] -= args.value;
	}
	function multipleValueOfArray(args){
		window[args.arrName][args.index] *= args.value;
	}
	function divideValueOfArray(args){
		window[args.arrName][args.index] /= args.value;
	}
	
	function getArrayMultiple(args){
		return Object.values(args).reduce((acc, value) => acc * value, 1);
	}
	
	function addValueToArray(args){
		window[args.arrName].push(args.value);
	}
	function removeIndexFromArray(args){
		window[args.arrName].splice(args.index, 1);
	}
	function removeValueFromArray(args){
		let i = window[args.arrName].indexOf(args.value);
		
		if (i > -1){
			window[args.arrName].splice(i, 1);
		}
	}
	
	
	function resetArray(args){
		window[args.arrName] = [];
	}
	function resetButtons(args){
		if (args.state == undefined || args.state == "all"){
			buttons = {};
		} else{
			buttons[args.state] = [];
		}
	}
	
	
	function getArraySum(args){
		let num = 0;
		
		for (let i in window[args.arrName]){
			num += window[args.arrName][i];
		}
		return num;
	}
	function getArraySumWithoutIndex(args){
		return getArraySum(args) - window[args.arrName][args.index];
	}
	
	
	function addButtonToCurrentGameState(args){
		buttons[gameState.currentState] ??= [];
		
		buttons[gameState.currentState].push(args);
	}
	function addButtonToOverlay(args){
		buttons["overlay"] ??= [];
		
		buttons["overlay"].push(args);
	}
	
	function addButtonsFromStateArray(args){
		let arr = window[args.arrName];
		
		let pos = structuredClone(args.pos);
		
		for (let i in arr.states){
			let button = structuredClone(args);
			
			button.text = arr.states[i];
			button.pos.x = pos.x;
			button.pos.y = pos.y;
			button.stateNum = i;
			
			if ((arr.stateNum ?? 0) != i && args.shouldLockInactiveButtons != false){
				button.isLocked = true;
			}
			
			if ((arr.stateNum ?? 0) == i && arr.currentState != arr.states[i]){
				button.text = arr.currentState;
			}
			
			buttons[args.state ?? gameState.currentState].push(button);
			
			pos.x += args.offset.x ?? 0;
			pos.y += args.offset.y ?? 0;
		}
	}
	
	
	var lastValue = 0;
	var lastValueIndexLength = 0;
	function getButtonsOfButtonsArray(arr, originalArr, indexArr = []){
		let currentArr = [];
		originalArr ??= arr;
		
		for (let i in arr.buttons){
			let button = {value: arr.buttons[i].value, gameState: arr.value};
			
			if (button.value == undefined){
				let indexText = indexArr.slice(lastValueIndexLength).join(",");
				
				button.value = lastValue + indexText + ((indexText.length > 0) ? "," : "") + i;
				button.gameState = lastValue + indexText;
				
				lastValueText = arr.buttons[i].text;
			} else{
				lastValue = button.value;
				lastValueIndexLength = indexArr.length + 1;
			}
			
			
			
			for (let j in arr.buttons[i]){
				if (j != "buttons" && j != "label"){
					button[j] = arr.buttons[i][j];
				}
			}
			
			button.gameState ??= arr.args.initialState;
			
			if (arr.buttons[i].label != undefined){
				let labelButton = {...originalArr.labelArgs, ...button};
				
				labelButton.text = arr.buttons[i].label;
				
				if (arr.buttons[i].id != undefined){
					labelButton.id = arr.buttons[i].id + "Label";
				}
				
				currentArr.push(labelButton);
			}
			
			if (arr.buttons[i].isLabel){
				button = {...button, ...originalArr.labelArgs};
			}
			
			currentArr.push(button);
			
			if (arr.buttons[i].buttons != undefined){
				currentArr.push(...getButtonsOfButtonsArray(arr.buttons[i], originalArr, [...indexArr, i]));
			}
		}
		
		return currentArr;
	}
	
	function addButtonsFromButtonsArray(args){
		let arr = window[args.arrName];
		
		let pos = structuredClone(arr.buttonArgs.pos);
		
		buttonsArr = getButtonsOfButtonsArray(arr);
		
		
		let buttonNums = {};
		let isBacks = {};
		
		for (let i in buttonsArr){
			let state = buttonsArr[i].gameState;
			
			if (buttons[state] == undefined){ buttons[state] = []; }
			if (buttonNums[state] == undefined){ buttonNums[state] = 0; }
			
			if (buttonsArr[i].isBack || buttonsArr[i].isFullyBack){
				isBacks[state] = true;
				
				if (buttonsArr[i].isFullyBack){
					if (buttonsArr[i].onclickGameState == undefined){
						buttonsArr[i].onclickGameState = arr.args.initialState;
					} else{
						buttonsArr[i].savePreviousState ??= false;
					}
				} else{
					buttonsArr[i].onclickGameState = "Back";
				}
			}
		}
		
		if (arr.args.backButton != undefined){
			for (let i in buttonNums){
				if (!containsExcludedWords(i, arr.args.backButton.excludedStates) && !isBacks[i]){
					buttonsArr.push({gameState: i, ...arr.args.backButton});
				}
			}
		}
		
		
		for (let i in buttonsArr){
			let state = buttonsArr[i].gameState;
			
			
			let buttonArgs = structuredClone(arr.buttonArgs);
			
			for (let j in buttonsArr[i]){
				if (j != "onclick" && j != "isBack" && j != "isFullyBack"){
					buttonArgs[j] = buttonsArr[i][j];
				}
			}
			
			buttonArgs.text ??= buttonsArr[i].value;
			
			buttonArgs.pos.y += buttonArgs.pos.margin.h * buttonNums[state];
			
			
			if (buttonsArr[i].onclick != undefined){
				buttonArgs.onclick = [buttonsArr[i].onclick, buttonArgs.onclick].flat();
			}
			
			if (buttonsArr[i].isBack){
				buttonsArr[i].value = arr.args.backButton.value;
			}
			
			if (buttons[buttonsArr[i].value] != undefined){
				buttonArgs.onclickGameState = buttonsArr[i].value;
			}
			
			
			
			buttons[buttonsArr[i].gameState].push(buttonArgs);
			
			
			buttonNums[state]++;
		}
	}
	
	
	function getRandomNum(args){
		return Math.floor(Math.random() * (args.max - args.min + 1) + args.min);
	}
	function getRandomNumWithDecimals(args){
		return Math.random() * (args.max - args.min) + args.min;
	}
	
	
	function randomizeArrayState(args){
		if (args.canRepeat){
			window[args.arrName].currentState = getRandomElementOfArray(window[args.arrName].states);
		} else{
			window[args.arrName].currentState = getRandomElementOfArrayWithoutRepeats(window[args.arrName].states, window[args.arrName].currentState);
		}
	}
	function incrementArrayState(args){
		let arr = window[args.arrName];
		
		arr.stateNum ??= 0;
		arr.stateNum++;
		
		let stateNum = arr.stateNum;
		let statesSize = arr.states.length;
		
		if (stateNum >= statesSize || stateNum < 0){
			arr.stateNum = modulo(stateNum, statesSize);
		}
		
		arr.currentState = arr.states[arr.stateNum];
	}
	function setArrayState(args){
		window[args.arrName].currentState = args.value;
	}
	
	
	function runEval(args){
		return functionEval(args.text, args);
	}
	
	function changeArrayBooleansByEvalText(args){
		for (let i in window[args.arrName]){
			args.currentArr = window[args.arrName][i];
			
			let boolValue = runEval(args);
			
			if (boolValue && args.shouldTurnOn != false){
				window[args.arrName][i][args.boolName] = true;
			}
			if (!boolValue && args.shouldTurnOff != false){
				window[args.arrName][i][args.boolName] = false;
			}
		}
	}
	
	function modifyArrayByEvalArray(args){
		let evalArr = args.evalArr ?? window[args.evalArrName];
		
		if (args.evalArrIndex != undefined){
			evalArr = evalArr[args.evalArrIndex];
		}
		
		for (let i in evalArr){
			let indexText = "window[args.arrName]['" + i + "']";
			
			functionEval(indexText + " = " + indexText + evalArr[i], args);
		}
	}
	
		
</script>
<script> //Inventory
	
	function getIndexOfInventoryValue(args){
		return (args.arr ?? window[args.arrName]).findIndex(item => item.value === args.value);
	}
	
	function refreshInventory(args){
		let arr = args.arr ?? window[args.arrName];
		
		for (let i = 0; i < arr.length; i++){
			let index = getIndexOfInventoryValue({...args, value: arr[i].value});
			
			if (index != i){
				arr[index].amount += arr[i].amount;
				arr[i].amount = 0;
			}
			
			if (arr[i].amount == 0){
				arr.splice(i, 1);
				i--;
			}
		}
		
		if (args.arrName != undefined){ window[args.arrName] = arr; }
	}
	
	function removeValueFromInventory(args){
		let arr = args.arr ?? window[args.arrName];
		let index = getIndexOfInventoryValue(args);
		
		if (index != -1){
			if (arr[index].amount > 1){
				arr[index].amount--;
			} else{
				arr.splice(index, 1);
			}
		}
		
		if (args.arrName != undefined){ window[args.arrName] = arr; }
	}
	
	function addValueToInventory(args){
		let arr = args.arr ?? window[args.arrName];
		let index = getIndexOfInventoryValue(args);
		
		if (index == -1){
			let valueArr = {value: args.value, amount: Math.floor(args.amount ?? 1)};
			
			if (args.index == undefined || args.index == -1){
				arr.push(valueArr);
			} else{
				arr.splice(args.index, 0, valueArr);
			}
		} else{
			arr[index].amount += Math.floor(args.amount ?? 1);
		}
		
		if (args.arrName != undefined){ window[args.arrName] = arr; }
	}
	
	function operateValueOfInventory(args, operationType){
		let arr = args.arr ?? window[args.arrName];
		let currentValue = arr[args.index].value;
		
		let index = getIndexOfInventoryValue({...args, value: currentValue});
		
		if (operationType == "+"){ currentValue += args.value; }
		if (operationType == "-"){ currentValue -= args.value; }
		if (operationType == "*"){ currentValue *= args.value; }
		if (operationType == "/"){ currentValue /= args.value; }
		if (operationType == "**"){ currentValue **= args.value; }
		
		if (index != -1){
			arr[args.index].amount--;
		}
		
		if (args.arrName != undefined){ window[args.arrName] = arr; }
		
		addValueToInventory({...args, value: currentValue});
		
		refreshInventory(args);
	}
	
	function addToValueOfInventory(args){
		operateValueOfInventory(args, "+");
	}
	function subtractFromValueOfInventory(args){
		operateValueOfInventory(args, "-");
	}
	function multipleValueOfInventory(args){
		operateValueOfInventory(args, "*");
	}
	function divideValueOfInventory(args){
		operateValueOfInventory(args, "/");
	}
	function exponentiateValueOfInventory(args){
		operateValueOfInventory(args, "**");
	}
	
	function getInventoryValueSum(args){
		return Object.values(args.arr ?? window[args.arrName]).reduce((acc, value) => acc + (value.value * value.amount), 0);
	}
	function getInventoryValueSumWithoutIndex(args){
		let arr = args.arr ?? window[args.arrName];
		let num = 0;
		
		for (let i in arr){
			let value = arr[i];
			
			if (i == args.index){
				let currentNum = value.value * Math.max(value.amount - 1, 0);
				
				if (!isNaN(currentNum)){
					num += currentNum;
				}
			} else{
				num += value.value * value.amount;
			}
		}
		return num;
	}
	
	function addRandomValuesToInventory(args){
		let percentages = [];
		
		for (let i = args.min; i <= args.max; i++){
			percentages.push(1 / (args.max - args.min + 1));
		}
		
		
		let valuesArr = getRandomOccurrencesFromPercentages(percentages, args.amount);
		
		for (let i in valuesArr){
			if (valuesArr[i] > 0){
				addValueToInventory({...args, value: Number(i) + args.min, amount: valuesArr[i]});
			}
		}
	}
	
	function replaceInventoryValueWithVariable(args){
		let variableValue = window[args.varName];
		
		window[args.varName] = args.value;
		
		removeValueFromInventory(args);
		
		addValueToInventory({...args, value: variableValue});
		
		refreshInventory(args);
	}
	
	function changeInventoryValueToEvalText(args){
		let arr = args.arr ?? window[args.arrName];
		arr[args.index].amount--;
		
		if (args.arrName != undefined){ window[args.arrName] = arr; }
		
		let value = functionEval(args.text);
		
		addValueToInventory({...args, value: value});
		
		refreshInventory(args);
	}
	
</script>

<script> //General Hitbox Functions
	
	function isVertexInRect(v, r){
		return (v.x >= r.x && v.x <= r.x + r.w &&
				v.y >= r.y && v.y <= r.y + r.h);
	}
	
	function areRectsColliding(r1, r2){ //https://stackoverflow.com/a/16012490/12777947
		return (
			(r1.x < (r2.x + r2.w)) && (r1.y < (r2.y + r2.h)) &&
			(r2.x < (r1.x + r1.w)) && (r2.y < (r1.y + r1.h))
		);
	}
	
	function areLinesColliding1D(l1, l2){
		return (l1.end >= l2.start && l2.end >= l1.start);
	}
	
	function isVertexInPolygon(v, p){ //https://stackoverflow.com/a/36070256/12777947
		let j = p.length - 1;
		let odd = false;
		
		for (let i = 0; i < p.length; i++){
			if ((p[i].y < v.y && p[j].y >= v.y || p[j].y < v.y && p[i].y >= v.y) && (p[i].x <= v.x || p[j].x <= v.x)){
				odd ^= (p[i].x + (v.y - p[i].y) * (p[j].x - p[i].x) / (p[j].y - p[i].y)) < v.x;
			}
			j = i;
		}
		return odd;
	}
	
	function getVertexDistance(v1, v2){
		return Math.sqrt(Math.abs(v1.x - v2.x) ** 2 + Math.abs(v1.y - v2.y) ** 2);
	}
	
	function getVertexToRectDistance(v, r){ //https://stackoverflow.com/a/41286161
		let b = {left: r.x, right: r.x + r.w, top: r.y, bottom: r.y + r.h};
		
		let d = {x: 0, y: 0};
		
		if (v.x < b.left){
			d.x = b.left - v.x;
		} else if (v.x > b.right){
			d.x = b.right - v.x;
		}
		
		if (v.y < b.top){
			d.y = b.top - v.y;
		} else if (v.y > b.bottom){
			d.y = b.bottom - v.y;
		}
		
		return Math.sqrt(d.x ** 2 + d.y ** 2);
	}
	
	
	function getVertexToVertexRadians(v1, v2){
		let deltaX = v2.x - v1.x; 
		let deltaY = v2.y - v1.y;
		
		return Math.atan2(deltaY, deltaX);
	}
	
	function getVertexToVertexDirection(v1, v2){
		let radians = getVertexToVertexRadians(v1, v2);
		
		return {x: Math.cos(radians), y: Math.sin(radians)};
	}
	
	
	function isVertexInCircle(v, c){
		return (getVertexDistance(v, c) < c.w/2);
	}
	
	function areCirclesColliding(c1, c2){
		return (getVertexDistance(c1, c2) < (c1.w/2 + c2.w/2));
	}
	
	function isCircleFullyInsideCircle(c1, c2){
		return (getVertexDistance(c1, c2) < (c2.w/2 - c1.w/2));
	}
	
	
	function getRotatedVertex(pos, radians, center = {x: 0, y: 0}){ //https://stackoverflow.com/a/17411276/12777947
		return {
			x: (Math.cos(radians) * (pos.x - center.x)) - (Math.sin(radians) * (pos.y - center.y)) + center.x,
			y: (Math.cos(radians) * (pos.y - center.y)) + (Math.sin(radians) * (pos.x - center.x)) + center.y
		};
	}
	
	
	
	function isVertexInTopLeftHalfOfRect(v, rect = {x: 0, y: 0, w: 1, h: 1}){ //AI Generated
		let boundaryY = (-rect.h / rect.w) * (v.x - (rect.x + rect.w)) + rect.y;
		
		return v.y < boundaryY;
	}
	function isVertexInTopRightHalfOfRect(v, rect = {x: 0, y: 0, w: 1, h: 1}){ //AI Generated
		let boundaryY = (rect.h / rect.w) * (v.x - rect.x) + rect.y;
		
		return v.y < boundaryY;
	}
	function isVertexInBottomLeftHalfOfRect(v, rect){
		return !isVertexInTopRightHalfOfRect(v, rect);
	}
	function isVertexInBottomRightHalfOfRect(v, rect){
		return !isVertexInTopLeftHalfOfRect(v, rect);
	}
	
	
	function isRectInScreen(r){
		let screen = getScreenSize();
		
		return (areRectsColliding(r, screen.size.absolute));
	}
	
</script>

<script> //Grid
	
	function getGridFromArgs(args){
		let grid = args;
		
		if (grid.grid == undefined || grid.data == undefined){
			grid = (args.grid ?? window[args.gridName]) ?? window[args.arrName];
		}
		
		return grid;
	}
	
</script>
<script> //Grid Generation
	
	function generateEmptyGrid(args){
		let arr = getGridFromArgs(args);
		
		let gridShape = arr.data.gridShape ?? "rect";
		
		arr.grid = {};
		
		for (let i of arr.data.layers){
			arr.grid[i] = [];
			
			for (let y = 0; y < arr.data.gridSize.h; y++){
				arr.grid[i][y] = [];
				for (let x = 0; x < arr.data.gridSize.w; x++){
					arr.grid[i][y][x] = {};
				}
			}
		}
	}
	
	function generateGrids(){
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			generateEmptyGrid(grid);
			
			for (let j in grid.data.onload){
				arr = grid.data.onload[j];
				
				arr.args ??= {};
				arr.args.gridName ??= gridName;
				
				runEvent([arr]);
			}
			
			for (let j in grid.data.draw){
				grid.data.draw[j].args ??= {};
				grid.data.draw[j].args.gridName = gridName;
			}
			
			refreshGridDrawValues({gridName: gridName});
		}
	}
	
	
	function getGridMiddlePos(posArr, grid){
		let pos = {...posArr};
		
		if (pos.isMiddle){
			pos.y = Math.floor(grid.length/2) - Math.floor(pos.h/2);
			pos.x = Math.floor(grid[pos.y].length/2) - Math.floor(pos.w/2);
		}
		return pos;
	}
	
	function setValuesOnGridRandomly(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let exclusionPos = args.exclusionPos;
		
		let isExcluded = {};
		for (let k in exclusionPos){
			let pos = getGridMiddlePos(exclusionPos[k], grid);
			
			for (let i = 0; i < (pos.h ?? 1); i++){
				for (let j = 0; j < (pos.w ?? 1); j++){
					isExcluded[(pos.y + i) + ";" + (pos.x + j)] = true;
				}
			}
		}
		
		
		
		if (args.amount != undefined || args.amountRatio != undefined){
			let remainingAmount = args.amount ?? Math.floor(args.amountRatio * gridArr.data.gridSize.w * gridArr.data.gridSize.h);
			
			while (remainingAmount > 0){
				let randomPos = {
					x: getRandomNum({min: 0, max: grid[0].length - 1}),
					y: getRandomNum({min: 0, max: grid.length - 1})
				};
				
				if (!isExcluded[randomPos.y + ";" + randomPos.x]){
					isExcluded[randomPos.y + ";" + randomPos.x] = true;
					
					grid[randomPos.y][randomPos.x][args.value.name] = args.value.value;
					
					remainingAmount--;
				} else{
					if (grid.length * grid[0].length - objectLength(isExcluded) <= 0){
						remainingAmount = 0;
					}
				}
			}
		} else{
			for (let i in grid){
				for (let j in grid[i]){
					if (!isExcluded[i + ";" + j]){
						if (args.chance > Math.random()){
							grid[i][j][args.value.name] = args.value.value;
						}
					}
				}
			}
		}
	}
	
	function setValuesOnGridPositions(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let posArr = args.pos;
		
		if (isObject(posArr)){
			posArr = [posArr];
		}
		
		for (let k in posArr){
			let pos = getGridMiddlePos(posArr[k], grid);
			
			for (let i = 0; i < (pos.h ?? 1); i++){
				for (let j = 0; j < (pos.w ?? 1); j++){
					grid[pos.y + i][pos.x + j] = (!args.shouldReplace) ? {...grid[pos.y + i][pos.x + j], ...args.value} : {...args.value};
				}
			}
		}
	}
	
	function setValuesOnGridFromArray(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let arr = args.arr ?? window[args.arrName];
		
		let pos = {x: 0, y: 0};
		for (let i = 0; i < arr.length; i++){
			
			let value = arr[i];
			
			if (args.value != undefined){
				value = {[args.value.name]: arr[i]};
			}
			
			grid[pos.y][pos.x] = (!args.shouldReplace) ? {...grid[pos.y][pos.x], ...value} : {...value};
			
			
			pos.x++;
			
			if (grid[pos.y][pos.x] == undefined){
				pos.x = 0;
				pos.y++;
				
				if (grid[pos.y] == undefined){
					break;
				}
			}
		}
	}
	
	function setValuesOnGridFromLayout(args){
		let gridArr = getGridFromArgs(args);
		
		let layout = window[args.layoutName];
		let symbolsArr = (typeof layout.symbols == "string") ? window[layout.symbols] : layout.symbols;
		
		for (let i = 0; i < layout.arr.length; i++){
			for (let j = 0; j < layout.arr[i].length; j++){
				
				for (let k in gridArr.grid){
					gridArr.grid[k][i] ??= [];
					gridArr.grid[k][i][j] ??= {};
				}
				
				let layerArr = symbolsArr[layout.arr[i][j]];
				
				
				for (let layer in layerArr){
					if (layer != "data"){
						if (layer == "all"){
							for (let k in gridArr.grid){
								if (args.shouldOverlay){
									gridArr.grid[k][i][j] = {...gridArr.grid[k][i][j], ...layerArr[layer]};
								} else{
									gridArr.grid[k][i][j] = {...layerArr[layer]};
								}
							}
						} else{
							if (args.shouldOverlay){
								gridArr.grid[layer][i][j] = {...gridArr.grid[layer][i][j], ...layerArr[layer]};
							} else{
								gridArr.grid[layer][i][j] = {...layerArr[layer]};
							}
						}
					}
				}
			}
		}
	}
	
	function setValuesOnGridFromLayouts(args){
		for (let i in args.layoutNames){
			setValuesOnGridFromLayout({...args, layoutName: args.layoutNames[i], shouldOverlay: ((i == 0) ? args.shouldOverlay : true)});
		}
	}
	
	function getLayoutObjectByType(args){
		let arr;
		
		for (let i in args.symbols){
			if (args.symbols[i][args.layerName]?.type == args.type){
				arr = {...args.symbols[i][args.layerName]};
			}
		}
		return arr;
	}
	
	function countValuesInGrid(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let num = 0;
		
		for (let i in grid){
			for (let j in grid[i]){
				if (grid[i][j][args.value.name] == args.value.value){
					num++;
				}
			}
		}
		return num;
	}
	
	
	function refreshGridSize(args){
		let gridArr = getGridFromArgs(args);
		
		let maxSize = {w: 0, h: 0};
		
		for (let layer in gridArr.grid){
			let arr = gridArr.grid[layer];
			
			maxSize.h = Math.max(arr.length, maxSize.h);
			for (let i in arr){
				maxSize.w = Math.max(arr[i].length, maxSize.w);
			}
		}
		
		gridArr.data.gridSize = maxSize;
	}
	
</script>
<script> //Grid Neighbor
	
	/*
	rect
	0 1 2 3 4 5 6
	. . . . . . .
	. . . . . . .
	. . . . . . .
	. . . . . . .
	. . . . . . .
	
	hex (even indices are "pushed" 0.5 to the right)
	0 1 2 3 4 5 6
	 . . . . . . .
	. . . . . . .
	 . . . . . . .
	. . . . . . .
	 . . . . . . .
	
	tri (neighbors different, even indices start with upwards pointing triangles)
	0123456
	â–²â–¼â–²â–¼â–²â–¼â–²
	â–¼â–²â–¼â–²â–¼â–²â–¼
	â–²â–¼â–²â–¼â–²â–¼â–²
	â–¼â–²â–¼â–²â–¼â–²â–¼
	â–²â–¼â–²â–¼â–²â–¼â–²
	*/
	
	function getTileNeighborPositions(i, j, grid, gridShape = "rect"){
		let offsets = [];
		
		switch (gridShape){
			case "rect": {
				offsets = [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: -1, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}];
			} break;
			case "hex": {
				let horizontalOffset = (i % 2 == 0) ? 1 : -1;
				
				offsets = [{x: 0, y: -1}, {x: horizontalOffset, y: -1}, {x: -1, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: horizontalOffset, y: 1}];
			} break;
			case "tri": {
				let verticalOffset = ((i + j) % 2 == 0) ? 1 : -1;
				
				offsets = [{x: 0, y: verticalOffset}, {x: -1, y: 0}, {x: 1, y: 0}];
			} break;
			case "iso": {
				let horizontalOffset = (i % 2 == 0) ? 1 : -1;
				
				offsets = [{x: 0, y: -1}, {x: 0, y: 1}, {x: horizontalOffset, y: -1}, {x: horizontalOffset, y: 1}];
			} break;
		}
		
		
		let posArr = [];
		
		for (let offset of offsets){
			let pos = {x: j + offset.x, y: i + offset.y};
			
			if (grid[pos.y] != undefined){
				if (grid[pos.y][pos.x] != undefined){
					posArr.push(pos);
				}
			}
		}
		
		return posArr;
	}
	
	function incrementGridValuesFromNeighborValues(args){
		let arr = getGridFromArgs(args);
		
		let grid = arr.grid[args.layer ?? arr.data.layers[0]];
		
		for (let i = 0; i < grid.length; i++){
			for (let j = 0; j < grid[i].length; j++){
				let num = 0;
				
				let posArr = getTileNeighborPositions(i, j, grid, arr.data.gridShape);
				
				for (let pos of posArr){
					if (grid[pos.y][pos.x][args.neighborValue.name] == args.neighborValue.value){
						num++;
					}
				}
				
				if (!args.shouldReplace){
					grid[i][j][args.value] ??= 0;
					grid[i][j][args.value] += num;
				} else{
					grid[i][j][args.value] = num;
				}
			}
		}
	}
	
</script>
<script> //Grid Hitbox
	
	function getVertexPositionInGrid(v, grid, layerName, args = {}){
		let gridShape = grid.data.gridShape;
		
		let pos = {...grid.data};
		
		let offsets = getGridOffset(grid);
		
		if (grid.data.isCentered != false){
			pos.x -= offsets.w * grid.data.gridSize.w / 2;
			pos.y -= offsets.h * grid.data.gridSize.h / 2;
		}
		
		
		let tilePos = {...pos};
		
		if (gridShape == "hex"){
			tilePos.w += pos.gaps.left + pos.gaps.right
			tilePos.h += pos.gaps.up + pos.gaps.down;
			
			tilePos.y -= tilePos.h * 0.0775; //Same as: tilePos.h * 0.155 / 2
			tilePos.w /= 2;
			tilePos.h = tilePos.h * 0.86625; //Same as: tilePos.h / 2 * 1.155 * 1.5;
			tilePos.h /= 3;
		}
		if (gridShape == "tri"){
			tilePos.w /= 2;
		}
		if (gridShape == "iso"){
			tilePos.w /= 2;
			tilePos.h /= 2;
		}
		
		if (gridShape != "hex"){
			tilePos.w += pos.gaps.left + pos.gaps.right
			tilePos.h += pos.gaps.up + pos.gaps.down;
		}
		
		
		let vertexPos = {
			x: Math.floor((v.x - tilePos.x) / tilePos.w),
			y: Math.floor((v.y - tilePos.y) / tilePos.h)
		}
		
		if (gridShape == "hex"){
			vertexPos.x /= 2;
			vertexPos.y /= 3;
			
			vertexPos.x -= (Math.floor(vertexPos.y) % 2 == 0) ? 0.5 : 0;
		}
		if (gridShape == "iso"){
			vertexPos.x /= 2;
			
			vertexPos.x -= (Math.floor(vertexPos.y) % 2 == 0) ? 0.5 : 0;
		}
		
		if (gridShape == "hex"){
			if (vertexPos.y % 1 > 0){
				vertexPos.x = Math.floor(vertexPos.x);
				vertexPos.y = Math.floor(vertexPos.y);
			} else{
				let vertexPosInBox = {
					x: ((v.x - tilePos.x) / tilePos.w) % 1,
					y: ((v.y - tilePos.y) / tilePos.h) % 1
				}
				
				if (Math.abs(vertexPos.x) % 1 < 0.5){ //true is top left corner of hexagon, false is top right
					if (isVertexInTopLeftHalfOfRect(vertexPosInBox)){
						vertexPos.y--;
						
						if (Math.floor(vertexPos.y) % 2 == 0){
							vertexPos.x--;
						}
					}
				} else{
					if (isVertexInTopRightHalfOfRect(vertexPosInBox)){
						vertexPos.y--;
						
						if (Math.floor(vertexPos.y) % 2 != 0){
							vertexPos.x++;
						}
					}
				}
				
				vertexPos.x = Math.floor(vertexPos.x);
			}
		}
		if (gridShape == "tri"){
			let vertexPosInBox = {
				x: ((v.x - tilePos.x) / tilePos.w) % 1,
				y: ((v.y - tilePos.y) / tilePos.h) % 1
			}
			
			if ((vertexPos.x + vertexPos.y) % 2 == 0){
				if (isVertexInTopLeftHalfOfRect(vertexPosInBox)){
					vertexPos.x--;
				}
			} else{
				if (isVertexInBottomLeftHalfOfRect(vertexPosInBox)){
					vertexPos.x--;
				}
			}
		}
		if (gridShape == "iso"){
			let vertexPosInBox = {
				x: ((v.x - tilePos.x) / tilePos.w) % 1,
				y: ((v.y - tilePos.y) / tilePos.h) % 1
			}
			
			if (Math.abs(vertexPos.x) % 1 < 0.5){
				if (isVertexInTopLeftHalfOfRect(vertexPosInBox)){
					if (vertexPos.y % 2 != 0){
						vertexPos.x--;
					}
					vertexPos.y--;
				}
			} else{
				vertexPos.x = Math.floor(vertexPos.x);
				
				if (isVertexInTopRightHalfOfRect(vertexPosInBox)){
					if (vertexPos.y % 2 == 0){
						vertexPos.x++;
					}
					vertexPos.y--;
				}
			}
		}
		
		
		let isInGrid = false;
		if (grid.grid[layerName][vertexPos.y] != undefined){
			if (grid.grid[layerName][vertexPos.y][vertexPos.x] != undefined){
				isInGrid = true;
			}
		}
		
		if (!isInGrid && !args.allowOutOfBounds){
			vertexPos = {x: -1, y: -1};
		}
		
		return vertexPos;
	}
	
	
	function getGridOffset(grid){
		let pos = {...grid.data};
		
		let offsetX = pos.w;
		let offsetY = pos.h;
		
		if ((grid.data.gridShape == "tri")){
			offsetX = pos.w / 2;
		}
		if ((grid.data.gridShape == "hex")){
			offsetY = pos.h / 1.155;
		}
		if ((grid.data.gridShape == "iso")){
			offsetY = pos.h / 2;
		}
		
		return {
			w: offsetX + pos.gaps.left + pos.gaps.right,
			h: offsetY + pos.gaps.up + pos.gaps.down
		}
	}
	
	
	function getGridTilePos(args){
		let grid = window[args.gridName];
		let data = grid.data;
		
		let layerName = Object.keys(grid.grid)[0];
		let currentGrid = grid.grid[layerName];
		
		let pos = {...data};
		
		let offsets = getGridOffset(grid);
		
		if (data.isCentered != false){
			pos.x -= offsets.w * data.gridSize.w / 2;
			pos.y -= offsets.h * data.gridSize.h / 2;
		}
			
		let currentPos = {
			x: pos.x + offsets.w * args.x + pos.gaps.left,
			y: pos.y + offsets.h * args.y + pos.gaps.up,
			w: pos.w, h: pos.h, i: args.y, j: args.x
		}
		
		if (data.gridShape == "hex" || data.gridShape == "iso"){
			currentPos.x += (args.y % 2 == 0) * offsets.w/2;
		}
		
		return currentPos;
	}
	
</script>
<script> //Grid Click
	
	function gridClick(args){
		clickedGridTile = {gridName: "", layer: "", pos: {x: -1, y: -1}, isDown: false, mouseButton: args.mouseButton, lastOnDownPos: clickedGridTile.lastOnDownPos, isUp: args.isUp};
		
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (grid.data.gameState == gameState.currentState || grid.data.gameState == undefined){
				for (let layerName in grid.grid){
					let pos = getVertexPositionInGrid((args.currentMousePos ?? scaledMousePos), grid, layerName);
					
					if (pos.y != -1){
						if (args.isDown){
							clickedGridTile.lastOnDownPos = {...pos};
						}
						clickedGridTile = {...clickedGridTile, gridName: gridName, layer: layerName, pos: pos, isDown: args.isDown, mouseButton: args.mouseButton};
					}
				}
			}
		}
		
		let arr = clickedGridTile;
		
		if (arr.pos.y != -1){
			let grid = window[arr.gridName];
			
			let isClicked = (args.isUp && arr.pos.x == arr.lastOnDownPos.x && arr.pos.y == arr.lastOnDownPos.y);
			
			if (grid.data.isDragClick){
				arr.isDown = true;
			}
			if (grid.data.isFastClick){
				isClicked = (arr.isDown);
			}
			
			//GridEditor
			if (isClicked){
				let tile = grid.grid[arr.layer][arr.pos.y][arr.pos.x];
				let extraArgs = {layer: arr.layer, pos: arr.pos, mouseButton: arr.mouseButton};
				
				let fullArgs = {...args, ...tile, ...extraArgs};
				
				let value = getConditionalArrayValue(grid.data.onclick, fullArgs);
				
				for (let i in value){
					if ((value[i] + "").includes("<<")){
						value[i] = functionEval(value[i].replaceAll("<<","").replaceAll(">>",""), fullArgs);
					}
				}
				
				if (objectLength(value) > 0){
					grid.grid[arr.layer][arr.pos.y][arr.pos.x] = {...tile, ...value};
				}
				
				refreshGridDrawValues({gridName: clickedGridTile.gridName});
			}
		}
	}
	
</script>

<script> //Buttons
	
	function generateButtons(args){
		let arr = window[args.arrName];
		
		if (arr.states != undefined){
			let statesArr = arr.states;
			
			arr = [];
			for (let i in statesArr){
				arr[i] = {name: statesArr[i]};
			}
		}
		
		for (let i = 0; i < arr.length; i++){
			//todo: replace with getButtonPosInButtonGrid call
			let y = Math.floor(i / args.grid.w);
			let x = i % args.grid.w;
			
			let button = structuredClone(args.button) ?? {};
			
			
			let buttonSize = {
				w: args.pos.w + args.pos.margin.w,
				h: args.pos.h + args.pos.margin.h
			};
			
			button.pos = {
				x: args.pos.x + ((x > 0) ? buttonSize.w * x : 0), //works with Infinity buttonSize
				y: args.pos.y + ((y > 0) ? buttonSize.h * y : 0),
				w: args.pos.w,
				h: args.pos.h
			};
			
			if (args.isCentered){
				if (args.grid.w != undefined){
					button.pos.x = args.pos.x - (buttonSize.w * (args.grid.w - 1) / 2) + buttonSize.w * x;
				}
				
				if (args.grid.h != undefined){
					button.pos.y = args.pos.y - (buttonSize.h * (args.grid.h - 1) / 2) + buttonSize.h * y;
				}
			}
			
			let value = (isObject(arr[i])) ? arr[i].value : arr[i];
			
			let argsArr = {index: i, value: value};
			
			if (isObject(arr[i])){
				for (let j in arr[i]){
					if (argsArr[j] == undefined){
						argsArr[j] = arr[i][j];
					}
				}
			}
			
			button = getArrayWithReplacedValues(button, argsArr);
			
			let onclickArgs = button.onclick.args;
			
			if (onclickArgs != undefined){
				if (onclickArgs[0] == "{" && onclickArgs[onclickArgs.length - 1] == "}"){
					button.onclick.args = functionEval(onclickArgs);
				}
			}
			
			buttons[args.gameState] ??= [];
			buttons[args.gameState].push(button);
		}
	}
	
	
	function getButtonPosInButtonGrid(i, args){
		args.bounds ??= {x: 0, y: 0, w: 1, h: 1};
		args.marginRatio ??= {w: 1, h: 1};
		args.gridSize ??= {w: 1, h: 1};
		if (args.marginRatio.w == undefined){ args.marginRatio = {w: args.marginRatio, h: 1};}
		if (args.gridSize.w == undefined){ args.gridSize = {w: args.gridSize, h: 1};}
		
		let y = Math.floor(i / args.gridSize.w);
		let x = i % args.gridSize.w;
		
		let buttonSize = {
			w: args.bounds.w / args.gridSize.w,
			h: args.bounds.h / args.gridSize.h,
		};
		
		let pos = {
			x: args.bounds.x + buttonSize.w/2 + ((x > 0) ? buttonSize.w * x : 0), //works with Infinity buttonSize
			y: args.bounds.y + buttonSize.h/2 + ((y > 0) ? buttonSize.h * y : 0),
			w: buttonSize.w * (1 / (args.marginRatio.w + 1)),
			h: buttonSize.h * (1 / (args.marginRatio.h + 1))
		};
		
		if (args.isCentered){
			pos.x = args.bounds.x - (buttonSize.w * (args.gridSize.w - 1) / 2) + buttonSize.w * x;
			pos.y = args.bounds.y - (buttonSize.h * (args.gridSize.h - 1) / 2) + buttonSize.h * y;
		}
		
		return pos;
	}
	
	
	function changeButtonArgsById(id, args){
		for (let i in buttons){
			for (let j in buttons[i]){
				let hasId = false;
				
				let idArr = buttons[i][j].id;
				if (!isArray(idArr)){ idArr = [idArr]; }
				
				for (let k in idArr){
					if (idArr[k] == id){
						hasId = true;
					}
				}
				
				if (hasId){
					for (let k in args){
						buttons[i][j][k] = structuredClone(args[k]);
					}
				}
			}
		}
	}
	
	function removeButtonsById(id){
		for (let i in buttons){
			for (let j = 0; j < buttons[i].length; j++){
				let hasId = false;
				
				let idArr = buttons[i][j].id;
				if (!isArray(idArr)){ idArr = [idArr]; }
				
				for (let k in idArr){
					if (idArr[k] == id){
						hasId = true;
					}
				}
				
				if (hasId){
					buttons[i].splice(j, 1);
					
					j--;
				}
			}
		}
	}
	
</script>
<script> //Buttons Click
	
	function buttonsClick(isDown, isHover){
		closestButton = {i: "", j: 0, distance: -1};
		
		let i = gameState.currentState;
		
		let currentButtons = [...(buttons[i] ?? [])];
		
		if (buttons["overlay"] != undefined){
			currentButtons.push(...buttons["overlay"]);
		}
		
		for (let j = 0; j < currentButtons.length; j++){
			let button = {...currentButtons[j]};
			
			if (!button.disableClick && !(button.isLocked && button.hideLocked) && !(button.isHidden && button.lockHidden != false)){
				let scaledPos = getScaledPosition(button.pos, {isAbsolutePositioned: button.isAbsolutePositioned});
				
				if (button.isCentered != false){
					scaledPos = getCenteredPosition(scaledPos);
				}
				
				let distance = getVertexToRectDistance(mousePos, scaledPos);
				
				if (isVertexInRect(mousePos, scaledPos)){
					if (isHover){
						closestButton = {i: i, j: j, distance: distance, isHover: true, isLocked: button.isLocked};
					} else{
						if (!button.isLocked){
							if (isDown){
								clickedButton = {i: i, j: j};
							} else{
								if (clickedButton.i === i && clickedButton.j === j){
									
									if (button.toggle != undefined){
										let arr = (window[button.toggleArrName] ?? window);
										
										let boolValue = !arr[button.toggle.value];
										
										if (boolValue && button.toggle.shouldTurnOn != false){
											arr[button.toggle.value] = true;
										}
										if (!boolValue && button.toggle.shouldTurnOff != false){
											arr[button.toggle.value] = false;
										}
									}
									
									
									let arr = button.onclick;
									
									if (arr != undefined){
										if (!isArray(arr)){
											arr = [arr];
										}
										
										runEvent(arr);
										
										let multiplier = (button.hoverReleaseMultiplier ?? hoveredButtons.releaseMultiplier);
										
										hoveredButtons.arr[clickedButton.j] = hoveredButtons.maxSeconds * multiplier;
										
										closestButton = {i: i, j: j, distance: distance, isHover: true};
									}
									
									if (button.onclickGameState != undefined){
										
										let nextState = button.onclickGameState;
										
										gameState.previousStates ??= {};
										
										if (nextState == "Back"){
											nextState = gameState.previousStates[gameState.currentState] ?? gameState.states[0];
										} else if (button.savePreviousState != false){
											gameState.previousStates[nextState] = gameState.currentState;
										}
										
										gameState.currentState = nextState;
									}
								}
							}
						} else{
							closestButton = {i: i, j: j, distance: distance, isHover: true, isLocked: true};
						}
					}
				} else{
					if (distance < closestButton.distance || closestButton.distance == -1){
						closestButton = {i: i, j: j, distance: distance};
					}
				}
			}
		}
	}
	
</script>
<script> //Scrollbars
	
	function getScreenSize(){
		let screen = {
			pixelSize: {
				relative: getCanvasScaledPositions({x: 0, y: 0, w: 1, h: 1/camera.minWidthToHeightRatio}),
				absolute: {x: 0, y: 0, w: canvas.width, h: canvas.height}
			}
		};
		
		screen.size = {
			relative: {
				w: (1 / camera.zoom.level),
				h: ((1 / camera.zoom.level) / camera.minWidthToHeightRatio),
			}
		}
		
		screen.size.absolute = {
			w: (screen.pixelSize.absolute.w / screen.pixelSize.relative.w) * screen.size.relative.w,
			h: (screen.pixelSize.absolute.h / screen.pixelSize.relative.h) * screen.size.relative.h
		};
		
		if (!camera.areDimentionsEqual){
			screen.size.relative = {
				w: screen.size.absolute.w,
				h: screen.size.absolute.h
			};
		}
		
		screen.size.relative.x = (-camera.x) - screen.size.relative.w/2;
		screen.size.relative.y = (-camera.y) - screen.size.relative.h/2;
		
		screen.size.absolute.x = (-camera.x) - screen.size.absolute.w/2;
		screen.size.absolute.y = (-camera.y) - screen.size.absolute.h/2;
		
		return screen;
	}
	
	function refreshScrolledCamera(forceCalculate){
		if (!scrolledCamera.hasCalculated || forceCalculate){
			let state = gameState.currentState;
			
			scrolledCamera = {...camera};
			
			if (scrolledCameras[gameState.currentState] != undefined){
				scrolledCamera = {...scrolledCameras[gameState.currentState]};
			}
			
			scrolledCamera.hasCalculated = true;
			
			
			let scrollbar = scrollbarsArr[gameState.currentState];
			
			if (scrollbar != undefined){
				
				let screen = getScreenSize();
				
				if (scrollbar.x != undefined){
					let sectionSize = Math.abs(scrollbar.x.end - scrollbar.x.start);
					let size = screen.size.absolute.w / sectionSize;
					
					let middlePos = -(scrollbar.x.end + scrollbar.x.start) / 2;
					
					if (Math.abs(size) < 1){
						let cameraLeft = -(scrolledCamera.x + screen.size.absolute.w/2);
						let cameraRight = -(scrolledCamera.x - screen.size.absolute.w/2);
						
						if (cameraLeft < scrollbar.x.start){
							scrolledCamera.x = (-scrollbar.x.start - screen.size.absolute.w/2);
						}
						
						if (cameraRight > scrollbar.x.end){
							scrolledCamera.x = (-scrollbar.x.end + screen.size.absolute.w/2);
						}
					} else{
						if (scrolledCameras[gameState.currentState] != undefined){
							scrolledCameras[gameState.currentState].x = middlePos;
						}
						
						scrolledCamera.x = middlePos;
					}
				}
				
				if (scrollbar.y != undefined){
					let sectionSize = Math.abs(scrollbar.y.end - scrollbar.y.start);
					let size = screen.size.absolute.h / sectionSize;
					
					let middlePos = -(scrollbar.y.end + scrollbar.y.start) / 2;
					
					if (Math.abs(size) < 1){
						let cameraTop = -(scrolledCamera.y + screen.size.absolute.h/2);
						let cameraBottom = -(scrolledCamera.y - screen.size.absolute.h/2);
						
						if (cameraTop < scrollbar.y.start){
							scrolledCamera.y = (-scrollbar.y.start - screen.size.absolute.h/2);
						}
						
						if (cameraBottom > scrollbar.y.end){
							scrolledCamera.y = (-scrollbar.y.end + screen.size.absolute.h/2);
						}
					} else{
						if (scrolledCameras[gameState.currentState] != undefined){
							scrolledCameras[gameState.currentState].y = middlePos;
						}
						
						scrolledCamera.y = middlePos;
					}
				}
			}
		}
	}
	
	function getScrollbarsPos(){
		let pos = {};
		
		let scrollbar = scrollbarsArr[gameState.currentState];
		
		if (scrollbar != undefined){
			refreshScrolledCamera(true);
			
			let screen = getScreenSize();
			
			if (scrollbar.x != undefined){
				let sectionSize = Math.abs(scrollbar.x.end - scrollbar.x.start);
				let size = screen.size.absolute.w / sectionSize;
				
				if (Math.abs(size) < 1){
					let cameraLeft = -(scrolledCamera.x + screen.size.absolute.w/2);
					
					let x = ((cameraLeft - scrollbar.x.start) / (sectionSize + screen.size.absolute.w));
					
					x *= (1 + size);
					
					pos.x = {y: 1 - scrollbarsSize.h, x: x, h: scrollbarsSize.h, w: Math.abs(size)};
					
					pos.w = {y: 1 - scrollbarsSize.h, x: 0, h: scrollbarsSize.h, w: 1};
				}
			}
			
			if (scrollbar.y != undefined){
				let sectionSize = Math.abs(scrollbar.y.end - scrollbar.y.start);
				let size = screen.size.absolute.h / sectionSize;
				
				if (Math.abs(size) < 1){
					let cameraTop = -(scrolledCamera.y + screen.size.absolute.h/2);
					
					let y = ((cameraTop - scrollbar.y.start) / (sectionSize + screen.size.absolute.h));
					
					y *= (1 + size);
					
					pos.y = {x: 1 - scrollbarsSize.w, y: y, w: scrollbarsSize.w, h: Math.abs(size)};
					
					pos.h = {x: 1 - scrollbarsSize.w, y: 0, w: scrollbarsSize.w, h: 1};
				}
			}
		}
		
		for (let i of xyArr){
			if (pos[i] != undefined){
				pos[i].x += scrollbarMargin.x;
				pos[i].y += scrollbarMargin.y;
				pos[i].w -= scrollbarMargin.x * 2;
				pos[i].h -= scrollbarMargin.y * 2;
			}
		}
		return pos;
	}
	
	
	function getCameraPosFromScrollbarPos(pos){
		refreshScrolledCamera(true);
		let screen = getScreenSize();
		
		let scrollbar = scrollbarsArr[gameState.currentState];
		
		let cameraPos = {};
		
		for (let xy of xyArr){
			if (pos[xy] != undefined){
				let wh = xyToWH[xy];
				
				let startPos = -scrollbar[xy].start - screen.size.absolute[wh]/2;
				
				let sectionSize = Math.abs(scrollbar[xy].end - scrollbar[xy].start);
				
				let ratio = (pos[xy][xy] - pos[wh][xy] - scrollbarMargin[xy]) / (pos[wh][wh] - pos[xy][wh] - scrollbarMargin[xy]*2);
				
				cameraPos[xy] = startPos - ((sectionSize - screen.size.absolute[wh]) * ratio);
			}
		}
		return cameraPos;
	}
	
	
	
	function setScrollbarsToGrids(args){
		let arr = {x: {}, y: {}};
		
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (args.state == grid.data.gameState){
				let pos = structuredClone(grid.data);
				let offsets = getGridOffset(grid);
				
				if (grid.data.isCentered != false){
					pos.x -= offsets.w * grid.data.gridSize.w / 2;
					pos.y -= offsets.h * grid.data.gridSize.h / 2;
				}
				
				for (let layerName in grid.grid){
					let currentGrid = grid.grid[layerName];
					
					let gridBounds = {x: pos.x, y: pos.y, w: offsets.w * currentGrid[0].length, h: offsets.h * currentGrid.length};
					
					if (grid.data.gridShape == "tri"){
						gridBounds.w += pos.w/2;
					}
					if (grid.data.gridShape == "hex"){
						gridBounds.w += offsets.w/2;
						gridBounds.h += offsets.h/4 + offsets.h/10;
						gridBounds.y -= offsets.h/10;
					}
					
					arr.x.start ??= gridBounds.x;
					arr.y.start ??= gridBounds.y;
					arr.x.end ??= gridBounds.x + gridBounds.w;
					arr.y.end ??= gridBounds.y + gridBounds.h;
					
					arr.x.start = Math.min(gridBounds.x, arr.x.start);
					arr.y.start ??= Math.min(gridBounds.y, arr.y.start);
					arr.x.end ??= Math.max(gridBounds.x + gridBounds.w, arr.x.end);
					arr.y.end ??= Math.max(gridBounds.y + gridBounds.h, arr.y.end);
				}
			}
		}
		
		if (arr.x.start != undefined){
			let margin = args.margin ?? {left: 0.5, right: 0.5, up: 0.5, down: 0.5};
			
			arr.x.start -= margin.left;
			arr.y.start -= margin.up;
			arr.x.end += margin.right;
			arr.y.end += margin.down;
			
			scrollbarsArr[args.state] = arr;
		}
	}
	
</script>
<script> //Scrollbars Click
	
	function isScrollbarPosTouchingMouse(pos, xy){
		let isTouching = isVertexInRect(mousePosRatio, pos[xy]);
		
		if (!isTouching){
			let wh = xyToWH[xy];
			
			if ((scrollbarsMinSize[xy] ?? {})[wh] != undefined){
				let currentPos = getScrollbarsPosDrawSize(pos, xy);
				
				isTouching = isVertexInRect(mousePosRatio, currentPos);
			}
		}
		return isTouching;
	}
	
	function scrollbarsClick(isDown, isHover){
		let pos = getScrollbarsPos();
		
		for (let xy of xyArr){
			if (pos[xy] != undefined){
				if (isDown){
					if (isScrollbarPosTouchingMouse(pos, xy)){
						clickedScrollbar = {xy: xy, clickedPos: {...mousePosRatio}};
						
						hoveredScrollbars.arr[xy] = hoveredScrollbars.maxSeconds * hoveredScrollbars.releaseMultiplier;
					}
				} else{
					if (isHover){
						if (clickedScrollbar.xy == xy){
							let offset = {
								x: mousePosRatio.x - clickedScrollbar.clickedPos.x,
								y: mousePosRatio.y - clickedScrollbar.clickedPos.y
							}
							
							clickedScrollbar = {xy: xy, clickedPos: {...mousePosRatio}};
							
							pos[xy][xy] += offset[xy];
							
							if (scrolledCameras[gameState.currentState] == undefined){
								scrolledCameras[gameState.currentState] = structuredClone(camera);
							}
							
							scrolledCameras[gameState.currentState][xy] = getCameraPosFromScrollbarPos(pos)[xy];
						}
					}
				}
			}
		}
	}
	
</script>
<script> //Editable Polygons Click
	
	function savedPolygonsClick(isDown = true){
		let previousClickedPolygons = clickedPolygons;
		
		clickedPolygonVertex = {i: -1, layer: "", j: -1, type: ""};
		clickedPolygons = [];
		
		for (let i in savedPolygons){
			for (let layer in savedPolygons[i]){
				if (savedPolygons[i][layer].length > 0){
					if (isDown){
						if (savedPolygons[i][layer][0].args.isEditable && shouldEditPolygons){
							for (let j in savedPolygons[i][layer]){
								let posArr = {
									vertex: savedPolygons[i][layer][j],
									front: savedPolygons[i][layer][j].front,
									back: savedPolygons[i][layer][j].back
								};
								
								for (let k in posArr){
									if (posArr[k] != undefined){
										let pos = {
											x: posArr[k].x - 5,
											y: posArr[k].y - 5,
											w: 10,
											h: 10
										}
										
										if (isVertexInRect(mousePos, pos)){
											if (savedPolygons[i][layer][j].args.canEditEdges != false || k != "vertex" || (j != 0 && j != savedPolygons[i][layer].length - 1)){
												clickedPolygonVertex = {i: i, layer: layer, j: j, type: k};
											}
										}
									}
								}
							}
						}
					}
					
					if (savedPolygons[i][layer][0].args.isClickable && shouldClickPolygons){
						if (isVertexInPolygon(mousePos, savedPolygons[i][layer])){
							if (isDown){
								clickedPolygons.push({i: i, layer: layer, isDown: isDown});
							} else{
								for (let j in previousClickedPolygons){
									if (previousClickedPolygons[j].i == i){
										clickedPolygons.push({i: i, layer: layer, isDown: isDown});
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	function savedPolygonsMove(){
		let polygonArgs = savedPolygons[clickedPolygonVertex.i]?.[clickedPolygonVertex.layer]?.[clickedPolygonVertex.j]?.args;
		
		if (polygonArgs != undefined){
			let polygonArr = {base: [{x: mousePos.x, y: mousePos.y}]};
			
			let polygonPos = getCalculatedPolygonInverted(polygonArr, polygonArgs).base[0];
			
			for (let i in entities){
				if (entities[i].id == polygonArgs.id){
					let entityArr = entities[i].pos.arr;
					
					if ((entityArr[0] ?? {}).x != undefined){
						entityArr = entityArr[clickedPolygonVertex.j];
					} else{
						entityArr = entityArr[clickedPolygonVertex.layer][clickedPolygonVertex.j];
					}
					
					if (clickedPolygonVertex.type != "vertex"){
						let vertexPos = entityArr;
						let oppositeEntityArr = entityArr[(clickedPolygonVertex.type == "front") ? "back" : "front"];
						entityArr = entityArr[clickedPolygonVertex.type];
						
						if (((inputs["ControlLeft"] || inputs["ControlRight"]) ?? false) != isCurveSymmetryDefault){
							let changePos = {
								x: vertexPos.x - entityArr.x,
								y: vertexPos.y - entityArr.y
							};
							
							if (oppositeEntityArr != undefined){
								oppositeEntityArr.x = vertexPos.x + changePos.x;
								oppositeEntityArr.y = vertexPos.y + changePos.y;
							}
						}
					} else{
						let changePos = {
							x: polygonPos.x - entityArr.x,
							y: polygonPos.y - entityArr.y
						};
						
						if (entityArr.front != undefined){
							entityArr.front.x += changePos.x;
							entityArr.front.y += changePos.y;
						}
						if (entityArr.back != undefined){
							entityArr.back.x += changePos.x;
							entityArr.back.y += changePos.y;
						}
					}
					
					entityArr.x = polygonPos.x;
					entityArr.y = polygonPos.y;
				}
			}
		}
	}
	
</script>

<script> //Grid & Button Hover
	
	function gridHoverNextFrame(){
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (grid.data.gameState == gameState.currentState || grid.data.gameState == undefined){
				let arr = grid.data.hover;
				
				if (arr != undefined){
					let currentHoverPos = "";
					
					if (clickedGridTile.gridName == gridName){
						currentHoverPos = clickedGridTile.layer + ";" + clickedGridTile.pos.x + ";" + clickedGridTile.pos.y;
					}
					
					for (let j in arr.tiles){
						if (j != currentHoverPos || arr.tiles[j] > arr.time){
							arr.tiles[j] -= 1/fps * (arr.fadeOutMultiplier ?? 1);
							
							if (arr.tiles[j] <= 0){
								delete arr.tiles[j];
							}
						}
					}
					
					if (currentHoverPos != ""){
						arr.tiles[currentHoverPos] ??= 0;
						
						if (clickedGridTile.isDown){
							arr.tiles[currentHoverPos] = arr.time * arr.clickMultiplier;
						} else{
							if (arr.tiles[currentHoverPos] < arr.time){
								arr.tiles[currentHoverPos] += 1/fps * (arr.fadeInMultiplier ?? 1);
								
								arr.tiles[currentHoverPos] = Math.min(arr.tiles[currentHoverPos], arr.time);
							}
						}
					}
				}
			}
		}
	}
	
	function buttonHoverNextFrame(){
		if (hoveredButtons.gameState != gameState.currentState){
			hoveredButtons.gameState = gameState.currentState;
			hoveredButtons.arr = [];
		}
		
		let name = (clickedButton.i == "") ? closestButton.j : clickedButton.j;
		
		let hoveredIndex = -1;
		
		if (closestButton.isHover && closestButton.i == gameState.currentState){
			if (!(hoveredButtons.arr[name] > hoveredButtons.maxSeconds)){
				hoveredButtons.arr[name] ??= 0;
				
				hoveredButtons.arr[name] += 1/fps;
				
				hoveredButtons.arr[name] = Math.min(hoveredButtons.maxSeconds, hoveredButtons.arr[name]);
				
				hoveredIndex = name;
			}
		}
		
		for (let i in hoveredButtons.arr){
			if (hoveredButtons.arr[i] > 0 && i != hoveredIndex){
				hoveredButtons.arr[i] -= 1/fps;
				
				hoveredButtons.arr[i] = Math.max(0, hoveredButtons.arr[i]);
			}
		}
		
		if (clickedButton.i == gameState.currentState){
			let button = buttons[clickedButton.i][clickedButton.j];
			
			if (button == undefined){
				button = buttons["overlay"][clickedButton.j - buttons[clickedButton.i].length];
			}
			
			let multiplier = (button.clickHoverMultiplier ?? hoveredButtons.clickMultiplier);
			
			hoveredButtons.arr[name] = hoveredButtons.maxSeconds * multiplier;
		}
	}
	
</script>

<script> //Keyboard/Gamepad Axis Inputs
	
	function getKeyboardMovementAxes(axes){
		for (let xy of xyArr){
		
			for (let key of keyboardAxes[xy].negative){
				if (inputs[key]){
					axes[xy] = -1;
				}
			}
			
			for (let key of keyboardAxes[xy].positive){
				if (inputs[key]){
					axes[xy] = 1;
				}
			}
		}
		return axes;
	}
	
	function getGamepadDpadAxes(axes){
		for (let gamepad of gamepads){
			if (gamepad != null){
				for (let xy of xyArr){
					for (let key of gamepadDpadAxes[xy].negative){
						if (gamepad.buttons[key] != undefined){
							if (gamepad.buttons[key].pressed){
								axes[xy] = -1;
							}
						}
					}
					
					for (let key of gamepadDpadAxes[xy].positive){
						if (gamepad.buttons[key] != undefined){
							if (gamepad.buttons[key].pressed){
								axes[xy] = 1;
							}
						}
					}
				}
			}
		}
		return axes;
	}
	
	function getGamepadMovementAxes(axes){
		for (let gamepad of gamepads){
			if (gamepad != null){
				
				let directionSigns = {
					x: ((gamepad.axes[0] < 0) ? -1 : 1),
					y: ((gamepad.axes[1] < 0) ? -1 : 1)
				}
				
				let speeds = {
					x: Math.abs(gamepad.axes[0]) - gamepadAxisRange.min,
					y: Math.abs(gamepad.axes[1]) - gamepadAxisRange.min
				}
				
				let maxSpeed = (gamepadAxisRange.max - gamepadAxisRange.min);
				
				for (let xy of xyArr){
					if (speeds[xy] > maxSpeed){ speeds[xy] = maxSpeed; }
					
					if (speeds[xy] > 0){
						axes[xy] = (1 / maxSpeed) * speeds[xy] * directionSigns[xy];
					}
				}
			}
		}
		return axes;
	}
	
</script>
<script> //Keyboard/Gamepad Button Inputs
	
	function refreshButtonPressStates(){
		inputButtonStates = {};
		
		for (let buttonName in inputButtons){
			let button = inputButtons[buttonName];
			
			
			let isConditionFulfilled = true;
			
			if (button.condition != undefined){
				isConditionFulfilled = functionEval(button.condition);
			}
			
			
			if (isConditionFulfilled){
				let isPressed = false;
				
				let pressedNum;
				
				for (let i = 0; i < button.keyboard.length; i++){
					if (inputs[button.keyboard[i]]){
						isPressed = true;
						pressedNum = i;
					}
				}
				
				for (let gamepadNum in button.gamepads){
					let gamepad = gamepads[gamepadNum];
					
					if (gamepad != null){
						
						for (let i = 0; i < button.gamepads[gamepadNum].length; i++){
							
							if (gamepad.buttons[button.gamepads[gamepadNum][i]] != undefined){
								if (gamepad.buttons[button.gamepads[gamepadNum][i]].pressed){
									isPressed = true;
									pressedNum = i;
								}
							}
						}
					}
				}
				
				for (let i in button.requiredKeyboard){
					let currentKey = button.requiredKeyboard[i];
					
					if (currentKey == "Control" || currentKey == "Shift" || currentKey == "Alt"){
						let currentIsPressed = false;
						
						for (let leftRight of ["Left", "Right"]){
							if (inputs[currentKey + leftRight]){
								currentIsPressed = true;
							}
						}
						
						if (!currentIsPressed){
							isPressed = false;
							pressedNum = undefined;
						}
					} else{
						if (!inputs[currentKey]){
							isPressed = false;
							pressedNum = undefined;
						}
					}
				}
				
				let isDelayed = false;
				
				if (button.timer > 0){
					if (isPressed){
						isDelayed = true;
						
						button.timer--;
					} else{
						button.timer = 0;
					}
				}
				
				if (button.disableHold){
					if (pressedNum == button.previousPressedNum){
						isDelayed = true;
					}
				}
				
				if (!isDelayed && isPressed){
					inputButtonStates[buttonName] = true;
					
					if (button.maxTimer > 0){
						if (pressedNum != button.previousPressedNum && button.initialTimer != undefined){
							button.timer = button.initialTimer;
						} else{
							button.timer = button.maxTimer;
						}
					}
				} else{
					inputButtonStates[buttonName] = false;
				}
				
				if (inputButtonStates[buttonName]){
					let arr = button.onclick;
					
					if (arr != undefined){
						if (!isArray(arr)){
							arr = [arr];
						}
						
						runEvent(arr, {pressedNum: pressedNum});
					}
				}
				
				button.previousPressedNum = pressedNum;
			} else{
				button.previousPressedNum = undefined;
			}
		}
	}
	
</script>

<script> //Entity General
	
	function getEntityById(id){
		return entities.find(arr => arr.id == id);
	}
	function getEntityNumById(id){
		return entities.findIndex(arr => arr.id == id);
	}
	
	function getEntitiesByClassName(className){
		let arr = entities.filter(arr => arr.className == className);
		
		return (arr.length > 0) ? arr : undefined;
	}
	
	function removeEntities(id, type = "id"){
		for (let i = 0; i < entities.length; i++){
			let hasId = false;
			
			let idArr = entities[i][type];
			if (!isArray(idArr)){ idArr = [idArr]; }
			
			for (let j in idArr){
				if (idArr[j] == id){
					hasId = true;
				}
			}
			
			if (hasId){
				entities.splice(i, 1);
				
				i--;
			}
		}
	}
	function removeEntityById(id){ removeEntities(id, "id"); }
	function removeEntitiesByClassName(id){ removeEntities(id, "className"); }
	
	
	function getPlayerEntity(){
		return entities.find(arr => arr.isPlayer) ?? {pos: {x: 0, y: 0, w: 0, h: 0, shape: "rect"}};
	}
	
	function getTargetEntities(args){
		let currentPos;
		
		switch (args){
			case "player": {
				currentPos = getPlayerEntity();
			} break;
			case "playerDash": {
				let playerEntity = getPlayerEntity();
				
				currentPos = playerEntity.dash ?? playerEntity;
			} break;
		}
		
		if (objectLength(currentPos) == 0){
			currentPos = getEntityById(args);
		}
		
		if (objectLength(currentPos) == 0){
			currentPos = getEntitiesByClassName(args);
		} else{
			currentPos = [currentPos];
		}
		
		return currentPos ?? [args];
	}
	
	function getTargetEntity(args){
		return getTargetEntities(args)[0];
	}
	
	function getEntityPos(entity){
		let pos = entity.boxPos ?? entity.pos;
		
		return pos ?? entity;
	}
	
	function getTargetEntityPos(args){
		let currentEntity = getTargetEntity(args);
		
		return getEntityPos(currentEntity);
	}
	
	
	function getEntitiesWithArgs(args){
		let arr = [];
		
		for (let i in entities){
			let hasArgs = true;
			
			for (let j in args){
				if (entities[i][j] != args[j]){
					hasArgs = false;
				}
			}
			
			if (hasArgs){
				arr.push(entities[i]);
			}
		}
		return arr;
	}
	
	function getEntityHitboxVertices(entity){
		let arr = [];
		
		let entityShape = (entity.hitboxShape ?? entity.pos.shape);
		
		let pos = {
			x: entity.pos.x,
			y: entity.pos.y,
			w: entity.pos.w ?? entity.pos.h,
			h: entity.pos.h ?? entity.pos.w
		}
		
		pos.x -= pos.w/2;
		pos.y -= pos.h/2;
		
		switch (entityShape){
			case "rect": {
				arr = [
					{x: pos.x, y: pos.y},
					{x: pos.x + pos.w, y: pos.y},
					{x: pos.x + pos.w, y: pos.y + pos.h},
					{x: pos.x, y: pos.y + pos.h}
				];
			} break;
			case "circle": {
				let ratio = 0.7071067811865476; //from: Math.cos(Math.PI / 4)
				
				arr = [
					{x: pos.x + pos.w/2, y: pos.y},
					{x: pos.x + pos.w, y: pos.y + pos.h/2},
					{x: pos.x + pos.w/2, y: pos.y + pos.h},
					{x: pos.x, y: pos.y + pos.h/2},
					{x: pos.x + pos.w/2 + (pos.w/2 * ratio), y: pos.y + pos.h/2 - (pos.h/2 * ratio)},
					{x: pos.x + pos.w/2 + (pos.w/2 * ratio), y: pos.y + pos.h/2 + (pos.h/2 * ratio)},
					{x: pos.x + pos.w/2 - (pos.w/2 * ratio), y: pos.y + pos.h/2 + (pos.h/2 * ratio)},
					{x: pos.x + pos.w/2 - (pos.w/2 * ratio), y: pos.y + pos.h/2 - (pos.h/2 * ratio)},
				];
			} break;
			default: {
				arr = [{x: pos.x, y: pos.y}];
			} break;
		}
		return arr;
	}
	
</script>
<script> //Entity Generation
	
	function generateEntities(args){
		for (let i = 0; i < (args.amount ?? 1); i++){
			let entityData = structuredClone(args.entityData);
			
			entities.push(entityData);
		}
	}
	
	function generateEntitiesInsideRect(args){
		for (let i = 0; i < (args.amount ?? 1); i++){
			let pos = {
				x: Math.random() * args.rect.w + args.rect.x,
				y: Math.random() * args.rect.h + args.rect.y
			}
			
			let entityData = structuredClone(args.entityData);
			
			if (entityData.boxPos != undefined){
				entityData.boxPos.x = pos.x;
				entityData.boxPos.y = pos.y;
			} else{
				entityData.pos.x = pos.x;
				entityData.pos.y = pos.y;
				
				if (args.makeHitbox){
					entityData.hitbox = [{pos: {x: pos.x, y: pos.y, w: entityData.pos.w, shape: "circle"}}];
				}
			}
			
			entities.push(entityData);
		}
	}
	
	function generateSegmentedPathEntityFromLine(args){
		let segmentCount = args.segmentCount;
		
		let start = args.linePos.start;
		let end = args.linePos.end;

		let offset = {x: end.x - start.x, y: end.y - start.y};

		let arr = [];

		for (let i = 0; i < segmentCount; i++){
			let percentage = i / (segmentCount - 1);
			
			let currentArr = {
				x: start.x + offset.x * percentage,
				y: start.y + offset.y * percentage
			};
			
			if (i > 0){
				currentArr.back = {
					x: start.x + offset.x * percentage - offset.x * 1/segmentCount / 2,
					y: start.y + offset.y * percentage - offset.y * 1/segmentCount / 2
				};
			}
			if (i < segmentCount - 1){
				currentArr.front = {
					x: start.x + offset.x * percentage + offset.x * 1/segmentCount / 2,
					y: start.y + offset.y * percentage + offset.y * 1/segmentCount / 2
				};
			}
			arr.push(currentArr);
		}
		
		entities.push({...args.entityData, pos: {arr: arr, shape: "polygon"}});
	}
	
</script>
<script> //Entity Movement
	
	function moveEntityAlongDirection(entity, direction, speed, axes = {x: 1, y: 1}){
		entity.pos.x += Math.cos(direction) * speed * Math.abs(axes.x);
		entity.pos.y += Math.sin(direction) * speed * Math.abs(axes.y);
	}
	
	function isEntityInsideWalls(entity, shouldOverrideTouchedGridPos = true){
		let isInWalls = false;
		let isInsideInverseWalls = true;
		
		let entityVertices = getEntityHitboxVertices(entity);
		
		let walls = getEntitiesWithArgs({isWall: true}); //todo: these could be calculated once per frame instead
		let inverseWalls = getEntitiesWithArgs({isInverseWall: true});
		
		//Grid Wall Collision Check
		for (let i of gridNames){
			let gridArr = getGridFromArgs({gridName: i});
			
			if (gridArr.data.hasHitboxes){
				let touchedGridPos = [];
				
				for (let j in entityVertices){
					let gridPos = getVertexPositionInGrid(entityVertices[j], gridArr, gridArr.data.layers[0]);
					
					if (!isObjectInArray(gridPos, touchedGridPos)){
						touchedGridPos.push(gridPos);
					}
					
					for (let k in gridArr.grid){
						if ((gridArr.grid[k][gridPos.y]?.[gridPos.x] ?? {}).isWall){
							isInWalls = true;
						}
					}
				}
				
				entity.touchGridPos ??= {};
				if (shouldOverrideTouchedGridPos){
					entity.touchGridPos[i] = touchedGridPos;
				} else{
					for (let j in touchedGridPos){
						entity.touchGridPos[i] ??= [];
						
						if (!isArrInArr(touchedGridPos[j], entity.touchGridPos[i])){
							entity.touchGridPos[i].push(touchedGridPos[j]);
						}
					}
				}
			}
		}
		
		//Entity Wall Collision Check
		if (!isInWalls){
			if (inverseWalls.length > 0){
				isInsideInverseWalls = false;
				
				for (let i in inverseWalls){
					let inverseWallPos = {...inverseWalls[i].pos};
					
					inverseWallPos.w -= entity.pos.w * 2;
					
					if (inverseWallPos.shape == "circle"){
						if (areCirclesColliding(entity.pos, inverseWallPos)){
							isInsideInverseWalls = true;
						}
					} else{
						let overallPos = {x: 0, y: 0};
						for (let j in inverseWallPos.arr){
							overallPos.x += inverseWallPos.arr[j].x;
							overallPos.y += inverseWallPos.arr[j].y;
						}
						let middlePos = {x: overallPos.x / inverseWallPos.arr.length, y: overallPos.y / inverseWallPos.arr.length};
						
						let currentPos = [];
						
						let w = entity.pos.w/2;
						for (let j in inverseWallPos.arr){
							currentPos[j] = {...inverseWallPos.arr[j]};
							
							for (let xy of xyArr){
								if (currentPos[j][xy] != middlePos[xy]){
									currentPos[j][xy] += (currentPos[j][xy] < middlePos[xy]) ? w : -w;
								}
							}
						}
						
						if (isVertexInPolygon(entity.pos, currentPos)){
							isInsideInverseWalls = true;
						}
					}
				}
			}
			
			if (isInsideInverseWalls){
				for (let i in walls){
					if (((entity.hitboxShape ?? entity.pos.shape) == "rect") && ((walls[i].hitboxShape ?? walls[i].pos.shape) == "rect")){
						if (areRectsColliding(entity.pos, walls[i].pos)){
							isInWalls = true;
						}
					} else{
						if (areCirclesColliding(entity.pos, walls[i].pos)){
							isInWalls = true;
						}
					}
				}
			}
		}
		return (!isInsideInverseWalls || isInWalls);
	}
	
	
	function getMovementInput(entity = {}){
		let movementAxes = {x: 0, y: 0};
		
		movementAxes = getKeyboardMovementAxes(movementAxes);
		movementAxes = getGamepadDpadAxes(movementAxes);
		movementAxes = getGamepadMovementAxes(movementAxes);
		
		entity.previousMovementAxes = movementAxes;
		
		entity.lastInputAxes ??= {x: 0, y: 0};
		if (movementAxes.x != 0){ entity.lastInputAxes.x = movementAxes.x; }
		if (movementAxes.y != 0){ entity.lastInputAxes.y = movementAxes.y; }
		
		for (let i in entity.disabledMovementAxis){
			if (entity.disabledMovementAxis[i]){
				movementAxes[i] = 0;
			}
		}
		return movementAxes;
	}
	
	function moveEntityByInputDistance(entity, distance, movementAxes, overrideTouchedGrid = false){
		if (movementAxes == undefined){
			movementAxes = getMovementInput(entity);
		}
		
		if (movementAxes.x != 0 || movementAxes.y != 0){
			let stepsNum = 10;
			
			for (let step = 0; step < stepsNum; step++){ //todo: should probably remake this for better performance
				
				for (let xy of xyArr){
					if (movementAxes[xy] != 0){
						let currentAxes = {[xy]: movementAxes[xy], [xywhInverse[xy]]: 0};
						
						let directionAngle = getVertexToVertexRadians({x: 0, y: 0}, currentAxes);
						
						moveEntityAlongDirection(entity, directionAngle, distance/stepsNum, currentAxes);
						
						if (entity.isStoppedByWalls != false){
							if (isEntityInsideWalls(entity, overrideTouchedGrid)){
								moveEntityAlongDirection(entity, directionAngle + Math.PI, distance/stepsNum);
							}
						}
					}
				}
			}
		}
	}
	
	
	function createEntityDashMovement(args){
		let dash = args.dash;
		
		if (dash.charge > 0){
			moveEntityByInputDistance(args, dash.maxDistance * (dash.charge / dash.maxCharge) + dash.minDistance);
			
			dash.charge = 0;
		}
	}
	
	function dashEntity(args){
		let dash = args.dash;
		
		if (dash != undefined){
			if (inputButtonStates.dash){
				dash.charge++;
				
				if (dash.charge > dash.maxCharge){
					dash.charge = dash.maxCharge;
				}
			} else{
				createEntityDashMovement(args);
			}
			
			
			let dashPos = structuredClone(args);
			
			createEntityDashMovement(dashPos);
			
			args.dash.pos = dashPos.pos;
		}
	}
	
	function isEntityOnGround(args){
		let isOnGround = false;
		
		args.pos.x += args.jump.groundDistance * (args.gravity?.direction?.x > defaultValues.minGravityJumpRatio ? 1 : 0);
		args.pos.y += args.jump.groundDistance * (args.gravity?.direction?.y > defaultValues.minGravityJumpRatio ? 1 : 0);
		
		if (isEntityInsideWalls(args, false)){
			isOnGround = true;
		}
		
		args.pos.x -= args.jump.groundDistance * (args.gravity?.direction?.x > defaultValues.minGravityJumpRatio ? 1 : 0);
		args.pos.y -= args.jump.groundDistance * (args.gravity?.direction?.y > defaultValues.minGravityJumpRatio ? 1 : 0);
		
		return isOnGround;
	}
	
	function jumpEntities(){
		let arr = getEntitiesWithArgs({canJump: true});
		
		for (let i in arr){
			arr[i].jump ??= {value: 0, time: 0, speed: 0, groundDistance: 0};
			
			if (isEntityOnGround(arr[i])){
				arr[i].jump.time = 1;
			}
		}
	}
	
	
	function movePlayer(args){
		let speed = args.speed * ((inputButtonStates.run) ? args.runMultiplier : 1);
		
		if (!inputButtonStates.dash){
			moveEntityByInputDistance(args, speed, undefined, true);
		}
	}
	
	
	function moveEntityByGravity(args){
		args.jump ??= {value: 0, time: 0, speed: 0, groundDistance: 0};
		
		if (args.jump.time > 0){
			moveEntityByInputDistance(args, args.jump.value * args.jump.time, {x: -args.gravity.direction.x, y: -args.gravity.direction.y});
		}
		
		moveEntityByInputDistance(args, args.gravity.value, args.gravity.direction);
		
		if (args.jump.time > 0){
			if (isEntityOnGround(args)){
				args.jump.time = 0;
			} else{
				args.jump.time -= 1/fps * (args.jump.speed ?? 1);
				
				args.jump.time = Math.max(args.jump.time, 0);
			}
		}
	}
	
	
	function teleportEntityToOppositePos(args){
		let target = getTargetEntityPos(args.movement.target);
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = target.x * -1;
		pos.y = target.y * -1;
	}
	
	function teleportEntityToTargetEdge(args){
		let target = getTargetEntityPos(args.movement.target);
		
		let radians = getVertexToVertexRadians({x: 0, y: 0}, target);
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = Math.cos(radians) * args.movement.num;
		pos.y = Math.sin(radians) * args.movement.num;
	}
	
	
	function moveEntityAlongPath(args){
		let target = getTargetEntity(args.movement.target);
		
		args.pathPercent ??= 0;
		
		let currentPos = getPolygonPosAtPercentage(target.pos.arr, target, args.pathPercent, args.movement.layer);
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = currentPos.x;
		pos.y = currentPos.y;
		
		
		args.pathPercent += args.speed ?? 0;
		
		if (args.pathPercent > 1){
			if (args.movement.shouldLoop){
				args.pathPercent = 0;
			} else{
				args.pathPercent = 1;
			}
			
			if (args.movement.onFinishEvent != undefined){
				runEvent(args.movement.onFinishEvent);
			}
			
			if (args.movement.destroyOnFinish){
				args.shouldDestroy = true;
			}
		}
		
		args.changedArgs = ["pathPercent", "shouldDestroy"];
	}
	
	
	function rotateEntityAroundTarget(args){
		let target = getTargetEntityPos(args.movement.target) ?? {x: 0, y: 0};
		
		let radians = args.movement.radians ?? 0;
		let radius = args.movement.radius ?? 1;
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = Math.cos(radians) * (radius.x ?? radius) + target.x;
		pos.y = Math.sin(radians) * (radius.y ?? radius) + target.y;
	}
	
	
	function faceEntityTowardsClosestTargetInRadius(args){
		let targets = getTargetEntities(args.movement.target);
		
		args.foundTarget = false;
		
		if ((targets ?? []).length > 0 && targets[0] != args.movement.target){
			let pos = args.boxPos ?? args.pos;
			
			let radius = args.movement.radius;
			
			let closestTarget = {};
			
			for (let i in targets){
				let distance = getVertexDistance(pos, targets[i].boxPos ?? targets[i].pos);
				
				closestTarget.distance ??= distance;
				closestTarget.i ??= i;
				
				if (closestTarget.distance > distance){
					closestTarget = {distance: distance, i: i};
				}
			}
			
			let targetPos = targets[closestTarget.i].boxPos ?? targets[closestTarget.i].pos;
			
			if (closestTarget.distance <= args.movement.radius/2 + targetPos.w/2 || args.movement.radius == undefined){
				args.radians = getVertexToVertexRadians(pos, targetPos);
				
				args.foundTarget = true;
			}
		}
		
		args.changedArgs = ["radians", "foundTarget"];
	}
	
	
	function moveEntities(){
		for (let i = 0; i < entities.length; i++){
			let entity = entities[i];
			
			if (entity.touchGridPos != undefined){
				entity.touchGridPos = {};
			}
			
			if (entity.gridPos != undefined){
				moveEntityToGridPos(entity);
				
				refreshEntityGridConnections(entity);
			} else{
				if (entity.isPlayer){
					movePlayer(entity);
					
					dashEntity(entity);
				} else{
					if (entity.movement != undefined){
						let entityArgs = structuredClone(entity);
						
						if (entityArgs.shouldEval != false){
							entityArgs = getEvaluatedObject(entityArgs, false);
						}
						
						window[entity.movement.type](entityArgs);
						
						if (entity.boxPos != undefined){
							entity.boxPos = entityArgs.boxPos;
						} else{
							entity.pos = entityArgs.pos;
						}
						
						if (entityArgs.changedArgs != undefined){
							for (let i of entityArgs.changedArgs){
								entity[i] = entityArgs[i];
							}
						}
					}
				}
				
				if (entity.gravity != undefined){
					moveEntityByGravity(entity);
				}
				
				if (entity.shouldDestroy){
					entities.splice(i, 1);
					i--;
				}
			}
		}
	}
	
</script>
<script> //Entity Grid Movement
	
	function moveEntityToGridPos(args){
		let pos = getGridTilePos(args.gridPos);
		
		args.pos.x = pos.x + pos.w/2;
		args.pos.y = pos.y + pos.h/2;
	}
	
	function refreshEntityGridConnections(args){
		if (args.gridPos != undefined && args.gridPos?.gridName != undefined){
			args.gridPos.connections = window[args.gridPos.gridName].grid[args.gridPos.layer ?? "tilesLayer"][args.gridPos.y][args.gridPos.x].connections;
		}
	}
	
</script>
<script> //Entity Actions
	
	function growEntitySize(entity, action, args = {}){
		for (let wh of whArr){
			if (entity[wh] != undefined){
				entity[wh] += action.speed;
			}
			
			if (entity.pos != undefined){
				if (entity.pos[wh] != undefined){
					entity.pos[wh] += action.speed;
				}
			}
		}
	}
	
	function moveEntityTowardsTarget(entity, action, args = {}){
		if (action.direction == undefined){
			action.direction = getVertexToVertexRadians(entity.pos, action.target);
		}
		
		moveEntityAlongDirection(entity, action.direction, action.speed);
	}
	
	function moveEntityAtAngle(entity, action, args = {}){
		action.radians ??= args.radians ?? 0;
		
		if (action.radians == "random"){
			action.radians = Math.random() * Math.PI*2;
		}
		
		
		moveEntityAlongDirection(entity, action.radians, action.speed);
	}
	
</script>
<script> //Entity Attacks
	
	function createBullet(pos, type, entity){
		let bullet = structuredClone(bullets[type]);
		
		if (bullet.shouldEval != false){
			bullet = getEvaluatedObject(bullet, false);
		}
		
		if (bullet.isMultiple){
			let data = bullet.data;
			
			if (bullet.formation.type == "arcAngle"){
				let targetAngle = bullet.formation.target;
				
				if (isNaN(targetAngle)){
					targetAngle = getVertexToVertexRadians(pos, getTargetEntityPos(targetAngle));
				}
				
				let amount = bullet.formation.amount;
				
				for (let i = 0; i < amount; i++){
					entities.push({
						...data,
						hitbox: [
							{
								pos: {x: pos.x, y: pos.y, w: data.w, shape: "circle"}, isHitboxHole: data.isHitboxHole,
								action: {type: "moveEntityAtAngle", radians: targetAngle + (i - amount/2 + 0.5) * bullet.formation.angleGap, speed: data.speed}
							}
						],
						pos: {x: pos.x, y: pos.y, w: data.w, shape: "circle"},
					});
				}
			}
			
		} else{
			let savedBullet = structuredClone(bullet);
			
			for (let i in bullet.hitbox){
				bullet.hitbox[i].pos = structuredClone(pos);
				bullet.hitbox[i].pos.w = savedBullet.hitbox[i].w;
				
				if (bullet.hitbox.length > 1){
					bullet.hitbox[i].pos.shape = "hollowCircle";
				}
			}
			
			bullet.pos = structuredClone(pos);
			bullet.pos.w = savedBullet.hitbox[0].w;
			
			if (entity.radians != undefined){
				bullet.radians = entity.radians;
			}
			
			entities.push(bullet);
		}
	}
	
	function createEntityAttacks(){
		for (let entity of entities){
			if (entity.attacks != undefined){
				
				if (entity.attackCooldown == undefined){
					entity.attackCooldown = {time: 0, phaseNum: 0, bulletNum: 0, repeatNum: 0};
					
					entity.attackType = getRandomElementOfArray(entity.attacks);
				}
				
				entity.attackCooldown.time--;
				
				
				let arr = entity.attackCooldown;
				
				let attack = attacks[entity.attackType];
				if (attack.shouldEval != false){
					attack = getEvaluatedObject(attack, false);
				}
				
				let phase = attack[arr.phaseNum];
				
				
				if (arr.time <= 0 && (!entity.onlyShootIfFoundTarget || entity.foundTarget)){
					if (arr.phaseNum < attack.length){
						
						let pos = phase.pos ?? entity.pos;
						
						createBullet(pos, phase.bullets[arr.bulletNum], entity);
						
						
						arr.time = attack[arr.phaseNum].time;
						
						arr.bulletNum++;
						
						if (arr.bulletNum >= phase.bullets.length){
							arr.bulletNum = 0;
							
							arr.repeatNum++;
							
							if (arr.repeatNum >= phase.repeatAmount){
								arr.repeatNum = 0;
								
								arr.phaseNum++;
							}
						}
						
						entity.attackCooldown = arr;
						
					} else{
						entity.attackCooldown = undefined;
					}
				}
			}
		}
	}
	
	
	function doBulletActions(){
		for (let entity of entities){
			if (entity.hitbox != undefined){
				
				for (let hitbox of entity.hitbox){
					let action = hitbox.action;
					
					if (action != undefined){
						if (window[action.type] != undefined){
							if (action.target != undefined){
								action.target = getTargetEntityPos(action.target);
							}
							
							window[action.type](hitbox, action, entity);
							
							entity.pos = hitbox.pos;
						}
					}
				}
				
			}
		}
	}
	
	function attacksNextFrame(){
		for (let i in entities){
			let entity = entities[i];
			
			if (entity.time != undefined){
				entity.time++;
				
				if (entity.time > entity.maxTime){
					entities.splice(i, 1);
				}
			}
		}
		
		createEntityAttacks();
		
		doBulletActions();
	}
	
</script>
<script> //Damage Entities
	
	function damageEntities(){
		let destroyedIndexes = [];
		
		for (let entityNum = 0; entityNum < entities.length; entityNum++){
			let entity = entities[entityNum];
			
			if (entity.invincibility > 0){ entity.invincibility--; }
			if (entity.shield?.time > 0){ entity.shield.time--; entity.shield.time = Math.max(entity.shield.time, 0); }
			
			if ((entity.invincibility ?? 0) <= 0 && entity.health != undefined){
				
				for (let attackerNum = 0; attackerNum < entities.length; attackerNum++){
					let attacker = entities[attackerNum];
					
					if (attacker.hitbox != undefined){
						if ((entity.isPlayer && attacker.canHitPlayers) || (!entity.isPlayer && attacker.canHitNotPlayers)){
							
							let isEntityAttacked;
							
							for (let hitbox of attacker.hitbox){
								
								if (isEntityAttacked != false){
									
									if (hitbox.isHitboxHole){
										if (isCircleFullyInsideCircle(entity.pos, hitbox.pos)){
											isEntityAttacked = false;
										}
									} else{
										if (areCirclesColliding(entity.pos, hitbox.pos)){
											isEntityAttacked = true;
										}
									}
								}
							}
							
							if (isEntityAttacked == true){
								let shieldMultiplier = 1;
								
								if (entity.shield?.time > 0){
									shieldMultiplier = (entity.shield?.damageMultiplier ?? 1);
								}
								
								entity.health -= (attacker.damage ?? 0) * shieldMultiplier;
								entity.invincibility = entity.maxInvincibility;
								
								if (attacker.onHit != undefined){
									if ((entity.shield?.time ?? 0) <= 0 || attacker.canHitThroughShield != false){
										runEvent(attacker.onHit, {entityNum: entityNum, attackerNum: attackerNum});
									}
								}
								
								if (attacker.destroyOnHit){
									entities.splice(attackerNum, 1);
									
									if (entityNum > attackerNum){
										entityNum--;
									}
									attackerNum--;
								}
								
								if (entity.health <= 0){
									entities.splice(entityNum, 1);
									
									entityNum--;
									
									break;
								}
							}
						}
					}
				}
				
			}
		}
	}
	
</script>

<script> //Polygons
	
	function getQuadraticCurvePosAtPercentage(startPt, controlPt, endPt, percentage){ //https://stackoverflow.com/a/22579440
		let T = percentage;
		
		let pos = {
			x: Math.pow(1-T,2) * startPt.x + 2 * (1-T) * T * controlPt.x + Math.pow(T,2) * endPt.x,
			y: Math.pow(1-T,2) * startPt.y + 2 * (1-T) * T * controlPt.y + Math.pow(T,2) * endPt.y
		}
		return pos;
	}
	
	function getCubicCurvePosAtPercentage(startPt, controlPt1, controlPt2, endPt, percentage){ //AI Generated from getQuadraticCurvePosAtPercentage
		let T = percentage;
		
		let pos = {
			x: Math.pow(1 - T, 3) * startPt.x + 
				3 * Math.pow(1 - T, 2) * T * controlPt1.x + 
				3 * (1 - T) * Math.pow(T, 2) * controlPt2.x + 
				Math.pow(T, 3) * endPt.x,
			
			y: Math.pow(1 - T, 3) * startPt.y + 
				3 * Math.pow(1 - T, 2) * T * controlPt1.y + 
				3 * (1 - T) * Math.pow(T, 2) * controlPt2.y + 
				Math.pow(T, 3) * endPt.y
		};
		return pos;
	}
	
	function getLinePosAtPercentage(startPt, endPt, percentage){ //AI Generated from getQuadraticCurvePosAtPercentage
		let T = percentage;
		
		let pos = {
			x: (1 - T) * startPt.x + T * endPt.x,
			y: (1 - T) * startPt.y + T * endPt.y
		};
		return pos;
	}
	
	
	function getPolygonPosAtPercentage(p, args, percentage, layer = "base"){
		let pArr = getCalculatedPolygon(p, {...args, isScaled: false});
		
		let arr = pArr[layer];
		
		let drawArr = (args.shouldCloseShape != false) ? [...arr, arr[0]] : arr;
		
		percentage = Math.max(percentage, 0);
		percentage = Math.min(percentage, 1);
		percentage *= 1 - (1 / (drawArr.length));
		
		let i = Math.floor(percentage * (drawArr.length));
		
		let currentPercentage = (percentage % (1 / (drawArr.length))) * drawArr.length;
		
		let nextArr = drawArr[i + 1] ?? {x: drawArr[i].x, y: drawArr[i].y, back: {x: drawArr[i].x, y: drawArr[i].y}};
		
		let currentPos = {
			start: drawArr[i],
			control1: drawArr[i].front,
			control2: nextArr.back,
			end: nextArr
		}
		
		let pos = {};
		
		if (drawArr[i].front != undefined){
			if (nextArr.back != undefined){
				pos = getCubicCurvePosAtPercentage(currentPos.start, currentPos.control1, currentPos.control2, currentPos.end, currentPercentage);
			} else{
				pos = getQuadraticCurvePosAtPercentage(currentPos.start, currentPos.control1, currentPos.end, currentPercentage);
			}
		} else{
			pos = getLinePosAtPercentage(currentPos.start, currentPos.end, currentPercentage);
		}
		
		return pos;
	}
	
</script>

<script> //Draw Positions Scaling
	
	function getCenteredPosition(pos){
		let arr = {...pos};
		
		arr.x -= (arr.w ?? arr.h ?? 0) / 2;
		arr.y -= (arr.h ?? arr.w ?? 0) / 2;
		
		return arr;
	}
	
	function getCanvasScaledPositions(pos, areDimentionsEqual = camera.areDimentionsEqual){
		let sizes = {x: canvas.width, y: canvas.height, w: canvas.width, h: canvas.height};
		
		if (areDimentionsEqual){
			let size = Math.min(canvas.width, canvas.height * camera.minWidthToHeightRatio);
			
			sizes = {x: size, y: size, w: size, h: size};
		}
		
		let scaledArr = {};
		
		for (let i in pos){
			scaledArr[i] = pos[i];
			
			if (sizes[i] != undefined){
				scaledArr[i] *= sizes[i];
			}
		}
		
		return scaledArr;
	}
	
	function getCanvasScaledPositionsInverted(pos, areDimentionsEqual = camera.areDimentionsEqual){
		let sizes = {x: canvas.width, y: canvas.height, w: canvas.width, h: canvas.height};
		
		if (areDimentionsEqual){
			let size = Math.min(canvas.width, canvas.height * camera.minWidthToHeightRatio);
			
			sizes = {x: size, y: size, w: size, h: size};
		}
		
		let scaledArr = {};
		
		for (let i in pos){
			scaledArr[i] = pos[i];
			
			if (sizes[i] != undefined){
				
				scaledArr[i] /= sizes[i];
			}
		}
		
		return scaledArr;
	}
	
	
	function calculatePositionWithCamera(arr){
		let pos = {x: arr.x, y: arr.y, w: arr.w, h: arr.h};
		
		refreshScrolledCamera();
		
		let scaledCamera = getCanvasScaledPositions(scrolledCamera);
		
		pos.x += scaledCamera.x;
		pos.y += scaledCamera.y;
		
		for (let i in pos){
			pos[i] *= camera.zoom.level;
		}
		
		return {x: Math.ceil(pos.x + canvas.width/2), y: Math.ceil(pos.y + canvas.height/2), w: Math.ceil(pos.w), h: Math.ceil(pos.h)};
	}
	
	function calculatePositionWithCameraInverted(arr){
		let pos = {x: arr.x - canvas.width/2, y: arr.y - canvas.height/2, w: arr.w, h: arr.h};
		
		for (let i in pos){
			pos[i] /= camera.zoom.level;
		}
		
		refreshScrolledCamera();
		
		let scaledCamera = getCanvasScaledPositions(scrolledCamera);
		
		pos.x -= scaledCamera.x;
		pos.y -= scaledCamera.y;
		
		return pos;
	}
	
	
	function getScaledPosition(pos, args = {}){
		let areDimentionsEqual = (args.isAbsolutePositioned) ? false : camera.areDimentionsEqual;
		
		let scaledPos = getCanvasScaledPositions(pos, areDimentionsEqual);
		
		if (!args.isAbsolutePositioned){
			scaledPos = calculatePositionWithCamera(scaledPos);
		}
		
		return scaledPos;
	}
	
	function getScaledPositionInverted(pos, args = {}){
		let scaledPos = pos;
		
		if (!args.isAbsolutePositioned){
			scaledPos = calculatePositionWithCameraInverted(pos);
		}
		
		let areDimentionsEqual = (args.isAbsolutePositioned) ? false : camera.areDimentionsEqual;
		
		scaledPos = getCanvasScaledPositionsInverted(scaledPos, areDimentionsEqual);
		
		return scaledPos;
	}
	
	
	
	function getCalculatedPolygon(p, args){
		let pArr = (isObject(p)) ? {...p} : {base: [...p]};
		
		for (let layer in pArr){
			let arr = pArr[layer];
			
			if ((args.radians ?? 0) % (Math.PI*2) != 0){
				let rotatedArr = [];
				
				for (let i in arr){
					let arrPos = getRotatedVertex(arr[i], args.radians, args.rotationCenter);
					
					if (arr[i].front != undefined){
						arrPos.front = getRotatedVertex(arr[i].front, args.radians, args.rotationCenter);
					}
					if (arr[i].back != undefined){
						arrPos.back = getRotatedVertex(arr[i].back, args.radians, args.rotationCenter);
					}
					
					rotatedArr.push(arrPos);
				}
				arr = rotatedArr;
			}
			
			let boxWidth = 1;
			
			if (args.boxPos != undefined){
				let currentArr = [];
				
				let ratio = args.boxRatio ?? {w: 1, h: 1};
				if (ratio.w == undefined){ ratio = {w: ratio, h: ratio}; }
				
				let boxSize = {
					w: (args.boxPos.w ?? 1) * ratio.w,
					h: (args.boxPos.h ?? 1) * ratio.h
				};
				
				boxWidth = boxSize.w;
				
				for (let i in arr){
					let arrPos = {
						x: arr[i].x * boxSize.w + args.boxPos.x,
						y: arr[i].y * boxSize.h + args.boxPos.y
					};
					
					if (arr[i].front != undefined){
						arrPos.front = {
							x: arr[i].front.x * boxSize.w + args.boxPos.x,
							y: arr[i].front.y * boxSize.h + args.boxPos.y
						};
					}
					if (arr[i].back != undefined){
						arrPos.back = {
							x: arr[i].back.x * boxSize.w + args.boxPos.x,
							y: arr[i].back.y * boxSize.h + args.boxPos.y
						};
					}
					
					currentArr.push(arrPos);
				}
				arr = currentArr;
				
			}
			if (args.isScaled != false){
				let scaledArr = [];
				
				for (let i in arr){
					let currentArr = getScaledPosition(arr[i], args);
					
					if (arr[i].front != undefined){
						currentArr.front = getScaledPosition(arr[i].front, args);
					}
					if (arr[i].back != undefined){
						currentArr.back = getScaledPosition(arr[i].back, args);
					}
					
					scaledArr.push(currentArr);
				}
				arr = scaledArr;
			}
			
			for (let i in arr){
				arr[i].boxWidth = boxWidth;
			}
			
			pArr[layer] = arr;
		}
		return pArr;
	}
	
	function getCalculatedPolygonInverted(p, args){
		let pArr = (isObject(p)) ? structuredClone(p) : {base: structuredClone(p)}; //todo: make it like in the uninverted one (without structuredClone)
		for (let layer in pArr){
			let arr = pArr[layer];
			
			if (args.isScaled != false){
				let scaledArr = [];
				
				for (let i in arr){
					let currentArr = getScaledPositionInverted(arr[i], args);
					
					if (arr[i].front != undefined){
						currentArr.front = getScaledPositionInverted(arr[i].front, args);
					}
					if (arr[i].back != undefined){
						currentArr.back = getScaledPositionInverted(arr[i].back, args);
					}
					
					scaledArr.push(currentArr);
				}
				arr = scaledArr;
			}
			
			if (args.boxPos != undefined){
				let currentArr = [];
				
				let ratio = args.boxRatio ?? {w: 1, h: 1};
				if (ratio.w == undefined){ ratio = {w: ratio, h: ratio}; }
				
				let boxSize = {
					w: (args.boxPos.w ?? 1) * ratio.w,
					h: (args.boxPos.h ?? 1) * ratio.h
				};
				
				
				for (let i in arr){
					let arrPos = {
						x: (arr[i].x - args.boxPos.x) / boxSize.w,
						y: (arr[i].y - args.boxPos.y) / boxSize.h
					};
					
					if (arr[i].front != undefined){
						arrPos.front = {
							x: (arr[i].front.x - args.boxPos.x) / boxSize.w,
							y: (arr[i].front.y - args.boxPos.y) / boxSize.h
						};
					}
					if (arr[i].back != undefined){
						arrPos.back = {
							x: (arr[i].back.x - args.boxPos.x) / boxSize.w,
							y: (arr[i].back.y - args.boxPos.y) / boxSize.h
						};
					}
					
					currentArr.push(arrPos);
				}
				arr = currentArr;
				
			}
			
			if ((args.radians ?? 0) % (Math.PI*2) != 0){
				let rotatedArr = [];
				
				for (let i in arr){
					let arrPos = getRotatedVertex(arr[i], -args.radians, args.rotationCenter);
					
					if (arr[i].front != undefined){
						arrPos.front = getRotatedVertex(arr[i].front, -args.radians, args.rotationCenter);
					}
					if (arr[i].back != undefined){
						arrPos.back = getRotatedVertex(arr[i].back, -args.radians, args.rotationCenter);
					}
					
					rotatedArr.push(arrPos);
				}
				arr = rotatedArr;
			}
			pArr[layer] = arr;
		}
		return pArr;
	}
	
</script>
<script> //Draw Color
	
	function setDrawStyleToColor(color, args = {}){
		let currentColor = colors[color] ?? color;
		
		if (isObject(currentColor)){
			let arr = currentColor;
			
			args.pos ??= {x: 0, y: 0, w: 1, h: 1};
			
			let pos = (arr.isScaled != false) ? getScaledPosition(args.pos, args) : {x: 0, y: 0, w: canvas.width, h: canvas.height};
			
			pos = {
				start: {
					x: pos.x + (pos.w ?? pos.h) * arr.pos.start.x,
					y: pos.y + (pos.h ?? pos.w) * arr.pos.start.y
				},
				end: {
					x: pos.x + (pos.w ?? pos.h) * arr.pos.end.x,
					y: pos.y + (pos.h ?? pos.w) * arr.pos.end.y
				},
			};
			
			if (args.isCentered){
				let size = {w: pos.end.x - pos.start.x, h: pos.end.y - pos.start.y};
				
				pos.start.x -= size.w/2; pos.end.x -= size.w/2;
				pos.start.y -= size.h/2; pos.end.y -= size.h/2;
			}
			
			let gradient = ctx.createLinearGradient(pos.start.x, pos.start.y, pos.end.x, pos.end.y);
			
			for (let i in arr.colorStops){
				gradient.addColorStop(arr.colorStops[i][0], arr.colorStops[i][1]);
			}
			
			currentColor = gradient;
		}
		
		ctx[(args.isFill != false) ? "fillStyle" : "strokeStyle"] = currentColor;
	}
	
</script>
<script> //Draw Shapes
	
	function drawRect(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		if (args.isFill != false){
			ctx.fillRect(pos.x, pos.y, pos.w, pos.h);
		} else{
			let polygon = [{x: pos.x, y: pos.y}, {x: pos.x + pos.w, y: pos.y}, {x: pos.x + pos.w, y: pos.y + pos.h}, {x: pos.x, y: pos.y + pos.h}];
			
			drawPolygon(polygon, {isScaled: false, isFill: false, lineWidth: args.lineWidth, minLinePixelSize: args.minLinePixelSize, isAbsolutePositioned: args.isAbsolutePositioned});
		}
	}
	
	function drawPolygonPoints(pArr, args){
		let currentArgs = {...args, lineWidth: undefined, color: undefined};
		for (let layer in pArr){
			let arr = pArr[layer];
			
			ctx.fillStyle = "#ff0000";
			ctx.strokeStyle = "#0000ff";
			ctx.lineWidth = 1;
			
			for (let i = 0; i < arr.length; i++){
				let nextPos = arr[i + 1] ?? arr[0];
				if (arr[i].front != undefined){
					ctx.strokeStyle = "#00c0ff";
					ctx.beginPath();
					ctx.moveTo(arr[i].x, arr[i].y);
					ctx.lineTo(arr[i].front.x, arr[i].front.y);
					ctx.stroke();
					
					drawRect({x: arr[i].front.x, y: arr[i].front.y, w: 10, h: 10}, {...currentArgs, isScaled: false, isCentered: true, isFill: false});
				}
				
				if (arr[i].back != undefined){
					ctx.strokeStyle = "#0000ff";
					ctx.beginPath();
					ctx.moveTo(arr[i].x, arr[i].y);
					ctx.lineTo(arr[i].back.x, arr[i].back.y);
					ctx.stroke();
				}
				
				drawRect({x: arr[i].x, y: arr[i].y, w: 7, h: 7}, {...currentArgs, isScaled: false, isCentered: true, isFill: true});
				
				if (arr[i].back != undefined){
					drawRect({x: arr[i].back.x, y: arr[i].back.y, w: 10, h: 10}, {...currentArgs, isScaled: false, isCentered: true, isFill: false});
				}
			}
		}
	}
	
	function drawPolygon(p, args = {}){
		if (args.isVisible != false){
			let pArr = getCalculatedPolygon(p, args);
			let savedPaths = {};
			
			if (isObject(args.isVisible)){
				for (let layer in pArr){
					if (args.isVisible[layer] == false){
						delete pArr[layer];
					}
				}
			}
			
			for (let layer in pArr){
				let arr = pArr[layer];
				
				if (arr.length > 0){
					let path = new Path2D();
					
					if (args.shouldCloseShape != false){
						path.moveTo(arr[arr.length-1].x, arr[arr.length-1].y);
					} else{
						path.moveTo(arr[0].x, arr[0].y);
					}
					
					let drawArr = (args.shouldCloseShape != false) ? [arr[arr.length-1], ...arr] : arr;
					for (let i = 0; i < drawArr.length - 1; i++){
						let nextArr = drawArr[i + 1];
						
						if (drawArr[i].front != undefined){
							if (nextArr.back != undefined){
								path.bezierCurveTo(drawArr[i].front.x, drawArr[i].front.y, nextArr.back.x, nextArr.back.y, nextArr.x, nextArr.y);
							} else{
								path.quadraticCurveTo(drawArr[i].front.x, drawArr[i].front.y, nextArr.x, nextArr.y);
							}
						} else{
							path.lineTo(nextArr.x, nextArr.y);
						}
						
					}
					if (args.shouldCloseShape != false){
						path.closePath();
					}
					
					let isFill = (args.isFill ?? {})[layer] ?? args.isFill ?? true;
					
					let hasFillOutline = (args.fillOutline ?? {})[layer] ?? args.fillOutline ?? false;
					
					let savedLineWidth = 1;
					
					if (isFill){
						if (args.color != undefined){
							let currentColor = (isObject(args.color)) ? (args.color[layer] ?? colors.defaultPolygonFillColor) : args.color;
							
							ctx.fillStyle = currentColor;
						}
						
						ctx.fill(path);
					}
					if (!isFill || hasFillOutline){
						if (isFill){
							let currentColor = (isObject(args.fillOutline)) ? (args.fillOutline[layer] ?? colors.defaultPolygonStrokeColor) : args.fillOutline;
							
							ctx.strokeStyle = currentColor;
						} else{
							if (args.color != undefined){
								let currentColor = (isObject(args.color)) ? (args.color[layer] ?? colors.defaultPolygonStrokeColor) : args.color;
								
								ctx.strokeStyle = currentColor;
							}
						}
						if (args.lineWidth != undefined){
							savedLineWidth = getScaledPosition({w: (args.lineWidth[layer] ?? args.lineWidth) * arr[0].boxWidth}, {isAbsolutePositioned: args.isAbsolutePositioned}).w;
							
							if (savedLineWidth < args.minLinePixelSize){
								savedLineWidth = args.minLinePixelSize;
							}
							
							ctx.lineWidth = savedLineWidth;
						}
						
						ctx.stroke(path);
					}
					
					savedPaths[layer] = {path: path, lineWidth: savedLineWidth};
				}
			}
			if (args.isEditable || args.isClickable || args.savePolygon){
				savedPolygons[args.id] = pArr;
				
				for (let i in savedPolygons[args.id]){
					for (let j in savedPolygons[args.id][i]){
						savedPolygons[args.id][i][j].args = args;
						savedPolygons[args.id][i][j].args.savedPath = savedPaths;
						
						/* todo: incorporate this way of checking if a point is in a path:
						let extraRadius = 10;
						ctx.lineWidth = savedPolygons["p3"].base[0].args.savedPath.base.lineWidth + extraRadius;
						ctx.isPointInStroke(savedPolygons["p3"].base[0].args.savedPath.base.path, 0, 0)
						*/
					}
				}
			}
			
			if (args.showPoints){
				drawLayers[1000000] ??= [];
				drawLayers[1000000].push({f: drawPolygonPoints, args: [pArr, args]});
			}
			
			if (args.showBox){
				let currentBoxPos = {x: args.boxPos.x, y: args.boxPos.y, w: args.boxPos.w ?? 1, h: args.boxPos.h ?? 1}
				
				ctx.strokeStyle = setDrawStyleToColor(args.boxColor ?? "#ff6600", {pos: currentBoxPos, isCentered: true, isFill: false});
				ctx.lineWidth = (args.boxSize ?? 1);
				
				drawRect(currentBoxPos, {...args, isScaled: true, isCentered: true, isFill: false, showBox: false, lineWidth: undefined, color: undefined});
			}
		}
	}
	
	
	function drawCircle(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let fillType = (args.isFill != false) ? "fill" : "stroke";
		
		ctx.beginPath();
		ctx.arc(pos.x + pos.w/2, pos.y + pos.w/2, Math.max(pos.w/2, 0), 0, 2 * Math.PI, false);
		ctx[fillType]();
	}
	
	function drawHollowCircle(circles, args = {}){
		let arr = structuredClone(circles);
		
		if (args.isCentered){
			let centeredArr = [];
		
			for (let i in arr){
				centeredArr.push({pos: getCenteredPosition(arr[i].pos)});
			}
			arr = centeredArr;
		}
		if (args.isScaled != false){
			let scaledArr = [];
			for (let i in arr){
				let pos = arr[i].pos;
				
				scaledArr.push({pos: getScaledPosition(pos, args)});
			}
			arr = scaledArr;
		}
		
		let fillType = (args.isFill != false) ? "fill" : "stroke";
		
		ctx.beginPath();
		for (let i in arr){
			let pos = arr[i].pos;
			
			ctx.arc(pos.x + pos.w/2, pos.y + pos.w/2, Math.max(pos.w/2, 0), 0, 2 * Math.PI, (i % 2 == 1));
		}
		ctx[fillType]();
	}
	
	
	function drawGridHex(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let polygon = [];
		
		let xValue = 0.8660254037844386; //From: Math.cos(Math.PI * 2 / 6 * i + Math.PI/2)
		
		let hexPos = [{x: 0, y: 1}, {x: -xValue, y: 0.5}, {x: -xValue, y: -0.5}, {x: 0, y: -1}, {x: xValue, y: -0.5}, {x: xValue, y: 0.5}];
		
		for (let i = 0; i < 6; i++){
			polygon.push({
				x: hexPos[i].x * pos.w/2 * 1.155 + pos.x + pos.w/2,
				y: hexPos[i].y * pos.h/2 * 1.155 + pos.y + pos.h/2
			});
		}
		
		drawPolygon(polygon, {isScaled: false, isFill: args.isFill});
	}
	
	function drawGridTri(pos, args = {}){
		let i = pos.i; let j = pos.j;
		
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let isUpwards = ((i + j) % 2 == 0);
		
		let polygon = (isUpwards) ? [{x: pos.x + pos.w/2, y: pos.y}, {x: pos.x + pos.w, y: pos.y + pos.h}, {x: pos.x, y: pos.y + pos.h}] :
									[{x: pos.x + pos.w/2, y: pos.y + pos.h}, {x: pos.x, y: pos.y}, {x: pos.x + pos.w, y: pos.y}];
		
		drawPolygon(polygon, {isScaled: false, isFill: args.isFill});
	}
	
	function drawGridIso(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let polygon = [{x: pos.x + pos.w/2, y: pos.y}, {x: pos.x + pos.w, y: pos.y + pos.h/2}, {x: pos.x + pos.w/2, y: pos.y + pos.h}, {x: pos.x, y: pos.y + pos.h/2}];
		
		drawPolygon(polygon, {isScaled: false, isFill: args.isFill});
	}
	
</script>
<script> //Draw Image
	
	function drawImage(pos, args = {}){
		let image = pos.src;
		
		if (typeof image == "string"){
			if (images[image] == undefined){
				let imageElement = document.getElementById(image);
				
				if (imageElement == undefined){
					imageElement = document.createElement("img");
					imageElement.id = image;
					imageElement.src = image;
					
					document.getElementById("imagesId").appendChild(imageElement);
					
					imageElement = document.getElementById(image);
				}
				
				images[image] = imageElement;
			}
			
			image = images[image];
		}
		
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		if (image != undefined){
			if (typeof image == "object" && image.naturalWidth != 0 && image.complete){
				ctx.drawImage(image, pos.x, pos.y, pos.w, pos.h);
			}
		}
	}
	
</script>
<script> //Draw Text	
	
	function getFontSizeFromRatio(ratio, args = {}){
		return getCanvasScaledPositions({h: ratio}).h * ((args.isAbsolutePositioned) ? 1 : (camera.zoom.level / camera.zoom.defaultTextLevel));
	}
	function getFontSizeFromRatioWithFont(ratio, font = defaultFont, args = {}){
		return getFontSizeFromRatio(ratio, args) + "px " + font;
	}
	
	function drawText(text, pos, args = {}){
		pos = {...pos};
		
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		
		if (args.textOffset != undefined){
			pos.x += args.textOffset.x ?? 0;
			pos.y += args.textOffset.y ?? 0;
		}
		
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		
		let evalText = ((text + "").includes("{{")) ? getEvaluatedText(text) : text;
		
		if (args.breakSpaces){
			evalText = evalText.replaceAll(" ", "\n");
		}
		
		let lines = (evalText + "").split("\n");
		
		
		let size;
		if (args.scaleText != false){
			if (pos.w != undefined){
				let currentSize = pos.w ?? pos.h;
				
				if (args.isAbsolutePositioned && camera.areDimentionsEqual){
					currentSize = Math.min(pos.w, pos.w * (canvas.height/canvas.width) * camera.minWidthToHeightRatio);
				}
				
				size = (currentSize * args.textSize);
			} else{
				getFontSizeFromRatio(args.textSize, args);
			}
			
			let maxLineLength = getBiggestLengthOfArray(lines);
			
			if (args.downscaleTextLength < maxLineLength && (args.downscaleTextLength != undefined)){
				size *= args.downscaleTextLength / maxLineLength;
			}
			
			ctx.font = size + "px " + (args.font ?? defaultFont);
			
			if (args.outlineSize > 0){
				let outlineSize = (pos.w != undefined && args.isScaledOutline) ? (pos.w * args.outlineSize) : getFontSizeFromRatio(args.outlineSize, args);
				
				ctx.lineWidth = outlineSize;
			}
		}
		
		let marginY = args.marginY ?? defaultValues.textMarginY;
		
		if (args.isScaled != false){
			if (size != undefined && args.isMarginYScaled != false){ //make margin bigger for bigger text sizes
				if (args.isAbsolutePositioned){
					marginY *= size * 0.015 * Math.max(1920/canvas.width, 911/canvas.height);
				} else{
					marginY *= (size / getScaledPosition({h: 1}).h) * 7;
				}
			}
			
			marginY = getScaledPosition({...pos, h: marginY}, args).h;
		}
		
		
		if (lines.length > 1 && args.shouldCenterLines != false){
			pos.y -= marginY * (lines.length - 1) / 2;
		}
		
		let spritesNum = 0;
		let currentLineWidth = ctx.lineWidth;
		for (let i = 0; i < lines.length; i++){
			let linePos = {x: pos.x, y: pos.y + marginY * i};
			
			let spriteCharacter = args.spriteCharacter ?? defaultValues.spriteCharacter;
			let spritesArr = [];
			if (lines[i].includes(spriteCharacter)){
				let currentIndex = 0;
				for (let currentCharacter of lines[i]){
					if (currentCharacter == spriteCharacter){
						spritesArr.push({index: currentIndex, spriteNum: spritesNum});
						spritesNum++;
					}
					currentIndex++;
				}
				lines[i] = lines[i].replaceAll(spriteCharacter, " ");
			}
			
			if (args.outlineSize > 0){
				ctx.lineWidth = currentLineWidth;
				ctx.strokeStyle = colors[args.outlineColor] ?? args.outlineColor;
				
				ctx.strokeText(lines[i], linePos.x, linePos.y);
			}
			
			if (args.textColor != undefined){
				ctx.fillStyle = colors[args.textColor] ?? args.textColor;
			}
			
			
			if (args.isFill != false){
				ctx.fillText(lines[i], linePos.x, linePos.y);
			} else{
				ctx.strokeText(lines[i], linePos.x, linePos.y);
			}
			
			//Draw text sprites
			if (spritesArr.length > 0){
				for (let j in spritesArr){
					let currentSpriteNum = spritesArr[j].spriteNum % (args.sprites?.length ?? 1);
					let currentSprite = args.sprites[currentSpriteNum];
					let currentPolygon = gameSprites[currentSprite] ?? currentSprite;
					
					let boxPos = getScaledPositionInverted(linePos);
					let scaledSize = getScaledPositionInverted({w: size}).w;
					
					boxPos = {x: boxPos.x + (spritesArr[j].index - (lines[i].length-1)/2) * (scaledSize * 0.5498), y: boxPos.y};
					
					boxPos.w = scaledSize * (args.spriteSize?.w ?? args.spriteSize ?? defaultValues.textSpriteSize.w);
					boxPos.h = scaledSize * (args.spriteSize?.h ?? args.spriteSize ?? defaultValues.textSpriteSize.h);
					
					drawPolygon(currentPolygon.pos.arr, {...currentPolygon, ...{boxPos: boxPos}});
				}
			}
		}
	}
	
	
	function drawTextAndBreakToFitWidth(text, pos, args = {}){
		let textArr = [];
		let width = args?.textBoxWidth ?? args?.downscaleTextLength ?? 30;
		
		let remainingText = ((text + "").includes("{{")) ? getEvaluatedText(text) : text;
		
		while (remainingText.length > width){
			remainingText = remainingText.trimStart();
			
			let lastSpaceNum = 0;
			
			for (let i = 0; i < width; i++){
				let lineWidth;
				
				if (i + 1 == width){
					lineWidth = (lastSpaceNum > 0) ? lastSpaceNum : width;
				} else{
					if (remainingText[i] == "\n"){
						lineWidth = i;
					}
					if (remainingText[i] == " "){
						lastSpaceNum = i;
					}
				}
				
				if (lineWidth != undefined){
					textArr.push(remainingText.substring(0, lineWidth));
					
					remainingText = remainingText.substring(lineWidth);
					
					break;
				}
			}
		}
		
		textArr.push(remainingText);
		
		drawText(textArr.join("\n"), pos, args);
	}
	
</script>
<script> //Rotation Draw Functions (unused for now)
	
	function rotatedDraw(functionName, argsArr, center, radians, posIndexesInArgsArr, arePosCentered = true){ //todo: remake this with args
		
		let args = structuredClone(argsArr);
		
		centerPos = getScaledPosition(center);
		
		for (let i in posIndexesInArgsArr){
			let index = posIndexesInArgsArr[i];
			
			for (let j in args[index]){
				args[index][j] *= camera.zoom.level;
			}
			
			if (arePosCentered){
				args[index].x -= args[index].w/2;
				args[index].y -= args[index].h/2;
			}
		}
		
		ctx.translate(centerPos.x, centerPos.y);
		ctx.rotate(radians);
		
		window[functionName](...args);
		
		ctx.rotate(-radians);
		ctx.translate(-centerPos.x, -centerPos.y);
	}
	
	function rotatedScaledFillRect(pos, radians, offset = {x: 0, y: 0}){ //the drawRect here hasn't been tested yet
		rotatedDraw("drawRect", [{x: offset.x, y: offset.y, w: pos.w, h: pos.h}, true], {x: pos.x, y: pos.y}, radians, [0], false);
	}
	function rotatedCenteredScaledFillRect(pos, radians, offset = {x: 0, y: 0}){
		rotatedDraw("drawRect", [{x: offset.x, y: offset.y, w: pos.w, h: pos.h}, true], {x: pos.x, y: pos.y}, radians, [0]);
	}
	
	function rotatedScaledFillText(text, pos, radians, offset = {x: 0, y: 0}){
		rotatedDraw("drawRect", [text, {x: offset.x, y: offset.y}, true], pos, radians);
	}
	
</script>
<script> //Draw Grids
	
	function refreshGridDrawValues(args = {}){
		let grid = window[args.gridName ?? "mainGrid"];
		
		if (grid != undefined){
			let values = {};
			
			let currentDataArr = grid.data.tilesData ?? window[grid.data.tilesDataName];
			
			if (currentDataArr != undefined){
				if (!isArray(currentDataArr)){
					currentDataArr = [currentDataArr];
				}
			}
			
			let symbolValues = {};
			if (currentDataArr != undefined){
				for (let currentData of currentDataArr){
					if (currentData.symbols != undefined){
						let arr = window[currentData.symbols];
						
						for (let k in arr){
							for (let m in arr[k]){
								if (arr[k][m].type != undefined && m != "data"){
									symbolValues[arr[k][m].type] = {...(arr[k].data ?? {})};
								}
							}
						}
					}
				}
			}
			
			for (let layer in grid.grid){
				values[layer] = [];
				for (let i = 0; i < grid.grid[layer].length; i++){
					values[layer][i] = [];
					for (let j = 0; j < grid.grid[layer][i].length; j++){
						let extraArgs = {layer: layer, pos: {x: j, y: i}};
						let value = getConditionalArrayValue(grid.data.gridDrawData, {layer: layer, ...args, ...grid.grid[layer][i][j], ...extraArgs});
						
						if (value != undefined){
							values[layer][i][j] = value;
						}
						
						if (currentDataArr != undefined){
							for (let currentData of currentDataArr){
								let tileName = grid.grid[layer][i][j][currentData.valueName];
								
								let tileValue = currentData.values?.[tileName];
								
								if (tileValue == undefined){
									tileValue = currentData.defaultValue ?? {};
								}
								
								if (objectLength(symbolValues) > 0){
									tileValue = symbolValues[tileName];
								}
								
								if (tileValue != undefined){
									values[layer][i][j] = {...(values[layer][i][j] ?? {}), ...tileValue};
								}
							}
						}
					}
				}
			}
			
			grid.data.gridDrawValues = values;
		}
	}
	
	
	
	function getGridTileHoverColor(data, currentHoverPos){
		let hoverColor;
		
		if (data.hover.tiles[currentHoverPos] != undefined){
			let alphaNum = data.hover.tiles[currentHoverPos] / data.hover.time;
			
			alphaNum *= data.hover.maxHoverAlphaNum ?? defaultValues.gridHoverAlphaNum;
			
			hoverColor = (data.hover.color ?? colors["defaultGridHover"]).replaceAll("{{alphaNum}}", alphaNum);
			
			if (hoverColor[0] == "#" && hoverColor.length == 7){
				hoverColor += Math.floor(Math.min(alphaNum, 1) * 255).toString(16).padStart(2, '0');
			}
		}
		return hoverColor;
	}
	
	function fillGridShape(args){
		let grid = window[args.gridName];
		let data = grid.data;
		
		ctx.lineWidth = getScaledPosition({w: (args.borderSize ?? defaultValues.gridBorderSize)}).w;
		
		let layers = (args.layers ?? args.layer) ?? Object.keys(grid.grid);
		if ( !isArray(layers) ){ layers = [layers]; }
		
		let shapeFunctions = {rect: drawRect, hex: drawGridHex, tri: drawGridTri, iso: drawGridIso};
		
		for (let layerName of layers){
			let currentGrid = grid.grid[layerName];
			
			//let pos = structuredClone(data); //todo: might be needed idk?
			let pos = {...data};
			
			let offsets = getGridOffset(grid);
			
			if (data.isCentered != false){
				pos.x -= offsets.w * data.gridSize.w / 2;
				pos.y -= offsets.h * data.gridSize.h / 2;
			}
			
			for (let i = 0; i < currentGrid.length; i++){
				for (let j = 0; j < currentGrid[i].length; j++){
					let extraArgs = (args.id != undefined) ? data.gridDrawValues[layerName][i][j][args.id] : {};
					
					if (extraArgs != undefined){
						extraArgs = {...args, ...extraArgs};
						
						
						let currentPos = {
							x: pos.x + offsets.w * j + pos.gaps.left,
							y: pos.y + offsets.h * i + pos.gaps.up,
							w: pos.w, h: pos.h, i: i, j: j
						}
						
						if (data.gridShape == "hex" || data.gridShape == "iso"){
							currentPos.x += (i % 2 == 0) * offsets.w/2;
						}
						
						setDrawStyleToColor(extraArgs.color, {...extraArgs, pos: currentPos, isFill: true});
						setDrawStyleToColor(extraArgs.borderColor, {...extraArgs, pos: currentPos, isFill: false});
						
						shapeFunctions[data.gridShape](currentPos);
						
						if (extraArgs.borderSize > 0){
							shapeFunctions[data.gridShape](currentPos, {isFill: false});
						}
						
						//Hover
						if (data.hover != undefined){
							let currentHoverPos = layerName + ";" + j + ";" + i;
							
							let hoverColor = getGridTileHoverColor(data, currentHoverPos);
							
							if (hoverColor != undefined){
								drawLayers[0] ??= [];
								drawLayers[0].push({f: shapeFunctions[data.gridShape], args: [currentPos], color: hoverColor, isFill: true});
							}
						}
					}
				}
			}
		}
	}
	
	function fillGridSprite(args){
		let grid = window[args.gridName];
		let data = grid.data;
		
		let layers = (args.layers ?? args.layer) ?? Object.keys(grid.grid);
		if ( !isArray(layers) ){ layers = [layers]; }
		
		for (let layerName of layers){
			let currentGrid = grid.grid[layerName];
			
			let pos = {...data};
			
			let offsets = getGridOffset(grid);
			
			if (data.isCentered != false){
				pos.x -= offsets.w * data.gridSize.w / 2;
				pos.y -= offsets.h * data.gridSize.h / 2;
			}
			
			for (let i = 0; i < currentGrid.length; i++){
				for (let j = 0; j < currentGrid[i].length; j++){
					let extraArgs = (args.id != undefined) ? data.gridDrawValues[layerName][i][j][args.id] : {};
					
					if (extraArgs != undefined){
						extraArgs = {...args, ...extraArgs};
						
						let currentPos = {
							x: pos.x + offsets.w * j + pos.gaps.left + pos.w/2,
							y: pos.y + offsets.h * i + pos.gaps.up + pos.h/2,
							w: pos.w, h: pos.h
						}
						
						if (data.gridShape == "hex" || data.gridShape == "iso"){
							currentPos.x += (i % 2 == 0) * offsets.w/2;
						}
						
						if (args.textOffset != undefined){
							currentPos.x += (args.textOffset.x ?? 0) * pos.w;
							currentPos.y += (args.textOffset.y ?? 0) * pos.h;
						}
						
						if (args.spriteSize != undefined){
							currentPos.w *= args.spriteSize.w ?? args.spriteSize ?? 1;
							currentPos.h *= args.spriteSize.h ?? args.spriteSize ?? 1;
						}
						
						
						if (gameSprites[extraArgs.spriteName] != undefined){
							let currentSprite = {...gameSprites[extraArgs.spriteName]};
							
							drawPolygon(currentSprite.pos.arr, {...currentSprite, boxPos: currentPos});
						}
						
						if (gameSprites[currentGrid[i][j][extraArgs.value]] != undefined){
							let currentSprite = {...gameSprites[currentGrid[i][j][extraArgs.value]]};
							
							drawPolygon(currentSprite.pos.arr, {...currentSprite, boxPos: currentPos});
						}
						
					}
				}
			}
		}
	}
	
	function fillGridText(args){
		let grid = window[args.gridName];
		let data = grid.data;
		
		let layers = (args.layers ?? args.layer) ?? Object.keys(grid.grid);
		if ( !isArray(layers) ){ layers = [layers]; }
		
		for (let layerName of layers){
			let currentGrid = grid.grid[layerName];
			
			let pos = {...data};
			
			let offsets = getGridOffset(grid);
			
			if (data.isCentered != false){
				pos.x -= offsets.w * data.gridSize.w / 2;
				pos.y -= offsets.h * data.gridSize.h / 2;
			}
			
			for (let i = 0; i < currentGrid.length; i++){
				for (let j = 0; j < currentGrid[i].length; j++){
					let extraArgs = (args.id != undefined) ? data.gridDrawValues[layerName][i][j][args.id] : {};
					
					if (extraArgs != undefined){
						extraArgs = {...args, ...extraArgs};
						
						let currentPos = {
							x: pos.x + offsets.w * j + pos.gaps.left + pos.w/2,
							y: pos.y + offsets.h * i + pos.gaps.up + pos.h/2,
							w: pos.w, h: pos.h
						}
						
						if (data.gridShape == "hex" || data.gridShape == "iso"){
							currentPos.x += (i % 2 == 0) * offsets.w/2;
						}
						
						if (args.textOffset != undefined){
							currentPos.x += (args.textOffset.x ?? 0) * pos.w;
							currentPos.y += (args.textOffset.y ?? 0) * pos.h;
						}
						
						
						let text = extraArgs.text;
						if (text != undefined){
							drawText(text, currentPos, extraArgs);
						}
						
						text = currentGrid[i][j][extraArgs.value];
						if (text != undefined){
							drawText(text, currentPos, extraArgs);
						}
						
					}
				}
			}
		}
	}
	
	function drawGrids(){
		gridHoverNextFrame();
		
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (grid.data.gameState == gameState.currentState || grid.data.gameState == undefined){
				if (grid.data.draw != undefined){
					for (let j in grid.data.draw){
						arr = grid.data.draw[j];
						
						runEvent([arr]);
					}
				}
			}
		}
	}
	
</script>
<script> //Draw Entities
	
	function drawEntities(){
		for (let entity of entities){
			
			let entityArr = [entity];
			
			if (entity.dash != undefined){
				if (entity.dash.pos != undefined){
					entityArr.unshift(entity.dash);
				}
			}
			
			let isDash = entityArr.length > 1;
			
			for (let i in entityArr){
				let entityColor = colors[entity.color] ?? entity.color;
				
				if (entity.invincibility > 0 && entity.hitColor != undefined){
					entityColor = entity.hitColor;
				}
				
				entityColor += ((isDash) ? "88" : "");
				
				ctx[(entity.isFill != false) ? "fillStyle" : "strokeStyle"] = entityColor;
				
				if (entity.lineWidth != undefined){
					ctx.lineWidth = getScaledPosition({w: entity.lineWidth}).w;
				}
				
				
				let drawArgs = {isCentered: true, ...entityArr[i]};
				
				let currentDrawLayer = [];
				
				switch (entity.pos.shape){ //todo: why is it push if there can only be 1?
					case "rect": {
						currentDrawLayer.push({f: drawRect, args: [entityArr[i].pos, drawArgs], color: entityColor});
					} break;
					case "circle": {
						currentDrawLayer.push({f: drawCircle, args: [entityArr[i].pos, drawArgs], color: entityColor});
					} break;
					case "hollowCircle": {
						currentDrawLayer.push({f: drawHollowCircle, args: [entityArr[i].hitbox, drawArgs], color: entityColor});
					} break;
					case "polygon": {
						currentDrawLayer.push({f: drawPolygon, args: [entityArr[i].pos.arr, drawArgs], color: entityColor});
					} break;
					case "image": {
						currentDrawLayer.push({f: drawImage, args: [entityArr[i].pos, drawArgs]});
					} break;
				}
				
				if (entityArr[i].drawLayer == undefined){
					for (let j in currentDrawLayer){
						currentDrawLayer[j].f(...currentDrawLayer[j].args);
					}
				} else{
					drawLayers[entityArr[i].drawLayer] ??= [];
					drawLayers[entityArr[i].drawLayer].push(...currentDrawLayer);
				}
				
				isDash = false;
			}
		}
	}
	
</script>
<script> //Draw Buttons
	
	function drawButtonTitle(){
		let buttonType = (clickedButton.i != "") ? clickedButton : closestButton;
		
		let isLocked = (buttonType.isLocked ?? false);
		let isButtonVisible = (!buttonType.isHidden && (!isLocked || !buttonType.hideLocked));
		
		if (isButtonVisible && (buttonType.distance ?? 0) == 0){
			let button = buttons[buttonType.i]?.[buttonType.j];
			
			if (button != undefined){
				let text = (isLocked) ? (button.lockedTitle ?? defaultValues.lockedButtonTitle) : (button.title);
				
				if (text != undefined){
					ctx.textAlign = (mousePosRatio.x < 0.5) ? "left" : "right";
					ctx.textBaseline = "ideographic";
					
					
					let size = (isLocked) ? (button.lockedTitleSize ?? defaultValues.lockedButtonTitleSize) : (button.titleSize ?? defaultValues.buttonTitleSize);
					ctx.font = (size*0.2325 * canvas.width) + "px " + defaultFont;
					
					let shadowColor = (isLocked) ? (button.lockedTitleShadowColor ?? "defaultButtonLockedTitleShadow") : (button.titleShadowColor ?? "defaultButtonTitleShadow");
					ctx.fillStyle = colors[shadowColor] ?? shadowColor;
					
					
					let shadowOffset = (isLocked) ? (button.lockedTitleShadowOffset ?? defaultValues.lockedButtonTitleShadowOffset) : (button.titleShadowOffset ?? defaultValues.buttonTitleShadowOffset);
					drawText(text, addObjects(mousePosRatio, shadowOffset), {isAbsolutePositioned: true});
					
					let color = (isLocked) ? (button.lockedTitleColor ?? "defaultButtonLockedTitle") : (button.titleColor ?? "defaultButtonTitle");
					setDrawStyleToColor(color, {isFill: true});
					drawText(text, mousePosRatio, {isAbsolutePositioned: true});
					
					
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
				}
			}
		}
	}
	
	
	function drawButtons(){
		let i = gameState.currentState;
		
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		
		buttonHoverNextFrame();
		
		let currentButtons = [...(buttons[i] ?? [])];
		
		if (buttons["overlay"] != undefined && currentButtons != undefined){
			currentButtons.push(...buttons["overlay"]);
		}
		
		for (let j in currentButtons){
			let button = {...currentButtons[j]};
			
			if (!button.isHidden && !(button.isLocked && button.hideLocked)){
				let pos = button.pos;
				
				let isAbsolutePositioned = (button.isAbsolutePositioned);
				
				let args = {
					isAbsolutePositioned: isAbsolutePositioned,
					downscaleTextLength: button.downscaleTextLength
				};
				
				if (button.isCentered != false){
					pos = getCenteredPosition(pos);
				}
				
				
				let currentDrawLayer = [];
				
				//hover color
				let hoverColor;
				if (hoveredButtons.arr[j] > 0 && !button.isLocked && !button.disableClick){
					let alphaNum = hoveredButtons.arr[j] / hoveredButtons.maxSeconds;
					
					alphaNum *= button.maxHoverAlphaNum ?? hoveredButtons.maxAlphaNum;
					
					hoverColor = (button.hoverColor ?? colors["defaultButtonHover"]).replaceAll("{{alphaNum}}", alphaNum);
					
					if (hoverColor[0] == "#" && hoverColor.length == 7){
						hoverColor += Math.floor(Math.min(alphaNum, 1) * 255).toString(16).padStart(2, '0');
					}
				}
				
				//button color
				let color = (button.isLocked && (!button.disableClick || button.disableClickLooksLocked)) ? (button.lockedColor ?? "defaultButtonLocked") : (button.color ?? "defaultButton");
				currentDrawLayer.push({f: setDrawStyleToColor, args: [color, {isFill: true}]});
				currentDrawLayer.push({f: drawRect, args: [pos, args]});
				
				//button border
				if (button.borderSize != undefined && button.borderSize != 0){
					currentDrawLayer.push({f: setDrawStyleToColor, args: [button.borderColor ?? "defaultButtonBorder", {isFill: false}]});
					currentDrawLayer.push({f: drawRect, args: [pos, {...args, isFill: false, lineWidth: button.borderSize, minLinePixelSize: button.minLinePixelSize}]});
				}
				
				//button text
				let text = button.text ?? "";
				
				text += (button.extraText ?? "");
				
				if (button.toggle != undefined){
					if (!button.toggle.hideText){
						let arr = (window[button.toggleArrName] ?? window);
						
						let isOn = arr[button.toggle.value];
						
						if (button.toggle.isInverse){
							isOn = !isOn;
						}
						
						text += button.toggleTexts[isOn];
					}
				}
				
				if (button.isLocked && button.lockedText != undefined){
					text = button.lockedText;
				}
				
				let textColor = (button.isLocked) ? (button.lockedTextColor ?? "defaultButtonLockedText") : (button.textColor ?? "defaultButtonText");
				let outlineColor = (button.isLocked) ? (button.lockedOutlineColor ?? "defaultButtonLockedOutline") : (button.outlineColor ?? "defaultButtonOutline");
				
				let drawFunction = (button.shouldBreakText) ? drawTextAndBreakToFitWidth : drawText;
				
				if (text != undefined){
					let textArgs = {
						...button,
						...args,
						textColor: textColor,
						outlineColor: outlineColor,
						textSize: (button.textSize ?? defaultValues.buttonTextSize),
						outlineSize: (button.outlineSize ?? defaultValues.buttonOutlineSize),
						marginY: (button.marginY ?? defaultValues.buttonTextMarginY)
					}
					
					currentDrawLayer.push({f: drawFunction, args: [text, button.pos, textArgs]});
					
					if (button.textHoverOverlay && hoverColor != undefined){
						currentDrawLayer.push({f: drawFunction, args: [text, button.pos, {...textArgs, outlineColor: hoverColor, textColor: hoverColor}]});
					}
				}
				
				//button subtext
				if (button.subtext != undefined){
					button.subtextPos ??= defaultValues.buttonSubtextPos;
					
					let subtextPos = {
						x: button.pos.x + (button.subtextPos.x ?? defaultValues.buttonSubtextPos.x) * button.pos.w,
						y: button.pos.y + (button.subtextPos.y ?? defaultValues.buttonSubtextPos.y) * button.pos.h,
						w: button.pos.w,
						h: button.pos.h
					}
					
					
					let textSize = (button.subtextSize ?? defaultValues.buttonSubtextSize);
					let outlineSize = (button.subtextOutlineSize ?? button.outlineSize) ?? defaultValues.buttonSubtextOutlineSize;
					
					let subtextArgs = {...args};
					if (button.downscaleSubtextLength != undefined){
						subtextArgs.downscaleTextLength = button.downscaleSubtextLength;
					}
					
					currentDrawLayer.push({f: drawFunction, args: [button.subtext, subtextPos, {...subtextArgs, textSize: textSize, outlineSize: outlineSize, outlineColor: outlineColor, textColor: textColor}]});
					
					if (button.textHoverOverlay && hoverColor != undefined){
						currentDrawLayer.push({f: drawFunction, args: [button.subtext, subtextPos, {...subtextArgs, textSize: textSize, outlineSize: outlineSize, outlineColor: hoverColor, textColor: hoverColor}]});
					}
				}
				
				//button color hover
				if (hoverColor != undefined){
					currentDrawLayer.push({f: setDrawStyleToColor, args: [colors[hoverColor] ?? hoverColor, {isFill: true}]});
					currentDrawLayer.push({f: drawRect, args: [pos, args]});
				}
				
				//Draw Layers
				if (button.drawLayer == undefined){
					for (let j in currentDrawLayer){
						currentDrawLayer[j].f(...currentDrawLayer[j].args);
					}
				} else{
					drawLayers[button.drawLayer] ??= [];
					drawLayers[button.drawLayer].push(...currentDrawLayer);
				}
			}
		}
		
		drawButtonTitle();
	}
	
</script>
<script> //Draw Scrollbars
	
	function scrollHoverNextFrame(){
		if (hoveredScrollbars.gameState != gameState.currentState){
			hoveredScrollbars.gameState = gameState.currentState;
			hoveredScrollbars.arr = {};
		}
		
		let pos = getScrollbarsPos();
		
		let hoveredXY = "";
		
		for (let xy of xyArr){
			if (pos[xy] != undefined){
				if (isScrollbarPosTouchingMouse(pos, xy)){
					if (!(hoveredScrollbars.arr[xy] > hoveredScrollbars.maxSeconds)){
						if (hoveredScrollbars.arr[xy] == undefined){
							hoveredScrollbars.arr[xy] = 0;
						}
						
						hoveredScrollbars.arr[xy] += 1/fps;
						
						hoveredScrollbars.arr[xy] = Math.min(hoveredScrollbars.maxSeconds, hoveredScrollbars.arr[xy]);
						
						hoveredXY = xy;
					}
				}
			}
		}
		
		for (let i in hoveredScrollbars.arr){
			if (hoveredScrollbars.arr[i] > 0 && i != hoveredXY){
				hoveredScrollbars.arr[i] -= 1/fps;
				
				hoveredScrollbars.arr[i] = Math.max(0, hoveredScrollbars.arr[i]);
			}
		}
		
		if (clickedScrollbar.xy != undefined){
			hoveredScrollbars.arr[clickedScrollbar.xy] = hoveredScrollbars.maxSeconds * hoveredScrollbars.clickMultiplier;
		}
	}
	
	
	function getScrollbarsPosDrawSize(pos, xy){
		let currentPos = {...pos[xy]};
		
		let minSize = (scrollbarsMinSize[xy] ?? {})[xyToWH[xy]];
		
		if (minSize != undefined){
			let currentWH = currentPos[xyToWH[xy]];
			
			if (currentWH < minSize){
				let middlePos = currentPos[xy] + currentWH/2;
				
				currentPos[xyToWH[xy]] = minSize;
				currentPos[xy] = middlePos - minSize/2;
			}
		}
		return currentPos;
	}
	
	function drawScrollbars(){
		let pos = getScrollbarsPos();
		
		scrollHoverNextFrame();
		
		let scrollbarDrawOrder = ["w","x","h","y"];
		
		for (let i of scrollbarDrawOrder){
			if (pos[i] != undefined){
				let currentPos = getScrollbarsPosDrawSize(pos, i);
				
				ctx.fillStyle = colors[((i == "x" || i == "y") ? "scrollbar" : "scrollbarBackground")];
				
				drawRect(currentPos, {isAbsolutePositioned: true});
				
				if (hoveredScrollbars.arr[i] > 0){
					let alphaNum = hoveredScrollbars.arr[i] / hoveredScrollbars.maxSeconds;
					
					alphaNum *= hoveredScrollbars.maxAlphaNum;
					
					ctx.fillStyle = colors["scrollbarHover"].replaceAll("{{alphaNum}}", alphaNum);
					
					drawRect(currentPos, {isAbsolutePositioned: true});
				}
			}
		}
	}
	
</script>
<script> //Draw Layers
	
	function drawDrawLayers(){
		let drawLayerIndices = Object.keys(drawLayers).sort((a, b) => a - b);
		
		for (let index = 0; index < drawLayerIndices.length; index++){
			
			let i = drawLayerIndices[index];
			
			for (let j = 0; j < drawLayers[i].length; j++){
				let arr = drawLayers[i][j];
				
				if (arr.color != undefined){
					ctx[(arr.isFill != false) ? "fillStyle" : "strokeStyle"] = arr.color;
				}
				
				if (arr.f != undefined){
					if (typeof(arr.f) == "function"){
						arr.f(...arr.args);
					} else{
						window[arr.f](...arr.args);
					}
				}
				
				if (arr.event != undefined){
					runEvent(arr.event);
				}
			}
			
			drawLayerIndices = Object.keys(drawLayers).sort((a, b) => a - b);
		}
		drawLayers = [];
	}
	
</script>

<script> //Draw Call
	
	function drawCall(alwaysDraw){
		if (!cancelNextDrawFrame || alwaysDraw){
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			setDrawStyleToColor(colors.backgroundColor, {isAbsolutePositioned: true});
			
			savedPolygons = {};
			
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			
			
			runEvent(drawOrder);
			
			
			drawDrawLayers();
			
			
			if (isNotesClickable){
				ctx.fillStyle = notesColors[currentNotesColorNum];
				
				let pos = {w: canvas.width * 0.00125, h: canvas.height * 0.0025};
				
				ctx.fillRect(0, 0, canvas.width, pos.h);
				ctx.fillRect(0, canvas.height - pos.h, canvas.width, pos.h);
				ctx.fillRect(0, 0, pos.w, canvas.height);
				ctx.fillRect(canvas.width - pos.w, 0, pos.w, canvas.height);
				
				if (isNotesTextHidden){
					ctx.textAlign = "left";
					ctx.font = "16px " + defaultFont;
					ctx.fillStyle = colors.debugText;
					
					ctx.fillText("*Notes Mode* [Press Tilde to Turn Off]", 10, 20);
				}
			}
		}
		
		cancelNextDrawFrame = false;
	}
	
	function draw(){
		requestAnimationFrame(drawCall);
	}
	
</script>

<script> //Events
	
	function flattenNestedEvents(){
		let eventNames = Object.keys(events);
		let nestedEventNames = {};
		
		for (let i = 0; i < eventNames.length; i++){
			let name = eventNames[i];
			
			if (isObject(events[name]) && events[name].f == undefined && events[name].event == undefined){
				
				for (let j in events[name]){
					if (events[j] == undefined){
						events[j] = structuredClone(events[name][j]);
						
						eventNames.push(j);
						nestedEventNames[name] = true;
					}
				}
			}
		}
		
		for (let i in nestedEventNames){
			delete events[i];
		}
	}
	
	
	function isEvent(name){
		let isTrue = false;
		
		let currentName = name;
		
		if (isObject(name)){
			if (name.f != undefined){
				currentName = name.f;
			}
			if (name.event != undefined){
				currentName = name.event;
			}
		}
		
		if (typeof window[currentName] == "function"){
			isTrue = true;
		}
		if (events[currentName] != undefined){
			isTrue = true;
		}
		
		return isTrue;
	}
	
	function runEvent(eventData, args = {}){
		let eventsArr = eventData;
		
		if (events[eventData] != undefined){
			eventsArr = events[eventData];
		}
		if (eventsArr.f != undefined || eventsArr.event != undefined){
			eventsArr = [eventsArr];
		}
		
		eventsArr = structuredClone(Object.values(eventsArr));
		
		let mostRecentReturn;
		
		for (let i = 0; i < eventsArr.length; i++){
			let name = structuredClone(eventsArr[i]);
			
			
			let currentArr = {args: args};
			if (isObject(name)){ //if value is object (ex: {f: "resetButtons", args: {state: "game"}})
				let arr = structuredClone(name);
				
				arr.args = combineValues(arr.extraArgs ?? {}, arr.args ?? args);
				
				currentArr = arr;
			} else{
				if (window[name] != undefined){ //if value is a function's name
					if (window[name].args != undefined){
						let arr = window[name];
						
						arr.args = combineValues(arr.extraArgs ?? {}, arr.args ?? args);
						
						currentArr = arr;
					} else{
						currentArr = {args: args, f: name};
					}
				}
				if (events[name] != undefined){ //if value is an event's name
					if (events[name].args != undefined){
						let arr = events[name];
						
						arr.args = combineValues(arr.extraArgs ?? {}, arr.args ?? args);
						
						currentArr = arr;
					} else{
						currentArr = {args: args, event: name};
					}
				}
			}
			
			
			if (currentArr.f != undefined){
					if (currentArr.args != undefined){
						currentArr.args = getArrayWithReplacedValues(currentArr.args, currentArr.args);
					}
					name = getArrayWithReplacedValues(name, combineValues(args, currentArr.args));
				let currentReturn = window[currentArr.f](currentArr.args);
				
				mostRecentReturn = currentReturn ?? mostRecentReturn;
			} else if (currentArr.event != undefined){
					if (currentArr.args != undefined){
						currentArr.args = getArrayWithReplacedValues(currentArr.args, currentArr.args);
					}
					name = getArrayWithReplacedValues(name, combineValues(args, currentArr.args));
				let currentReturn = runEvent(currentArr.event, currentArr.args);
				
				mostRecentReturn = currentReturn ?? mostRecentReturn;
			} else{
				let evalArr = [name];
				if (typeof name != "string"){
					evalArr = name;
				}
				
				for (let j in evalArr){
					mostRecentReturn = getEvaluatedText(evalArr[j], false, false, currentArr.args);
				}
			}
			
			if (name?.amount > 1){
				for (let j = 1; j < name.amount; j++){
					eventsArr[i].amount = 1;
					
					insertIntoArray(eventsArr, structuredClone(eventsArr[i]), Number(i) + 1);
				}
			}
		}
		
		return mostRecentReturn;
	}
	
	
	function runEventWithDelay(args){
		args = structuredClone(args);
		
		let amount = args.amount ?? 1;
		
		if (args.startWithoutDelay){
			runEvent(args.event);
			
			amount--;
		}
		
		for (let i = 0; i < amount; i++){
			delayedEvents.push({
				time: (i + 1) * fps * args.delay + t,
				event: args.event
			});
		}
	}
	
</script>

<script> //Next Frame
	
	let lastFrameTime = getCurrentTime();
	let currentFrameTime = getCurrentTime();
	let wasPreviousCatchUpFrame = false;
	
	function nextFrame(){
		t++;
		
		gamepads = navigator.getGamepads();
		
		scrolledCamera.hasCalculated = false;
		
		if (mouseMoveEvent != undefined){
			onMouseMove(mouseMoveEvent);
		}
		
		refreshButtonPressStates();
		
		for (let i = 0; i < delayedEvents.length; i++){
			if (t >= delayedEvents[i].time){
				runEvent(delayedEvents[i].event);
				
				delayedEvents.splice(i, 1);
				i--;
			}
		}
		
		runEvent("onNextFrame");
		
		if (mouseLockFrames <= 1){
			mouseLockFrames++;
		}
		
		
		currentFrameTime = getCurrentTime();
		
		
		let nextFrameDelay = 1000/fps;
		
		if (!wasPreviousCatchUpFrame){
			nextFrameDelay = (1000/fps * 2) - (currentFrameTime - lastFrameTime);
			
			nextFrameDelay = Math.min(nextFrameDelay, 1);
			
			wasPreviousCatchUpFrame = true;
		} else{
			wasPreviousCatchUpFrame = false;
		}
		
		lastFrameTime = getCurrentTime();
		
		
		setTimeout(nextFrame, nextFrameDelay);
	}
	
</script>
<script> //Initiate Game
	
	function changeValuesByGameData(){
		let arr = gameData[currentGame.currentState];
		
		for (let valueName in arr.overriddenVariables){
			if (window[valueName] != undefined){
				window[valueName] = structuredClone(arr.overriddenVariables[valueName]);
			}
		}
		
		for (let valueName in arr.createdVariables){
			window[valueName] = structuredClone(arr.createdVariables[valueName]);
		}
		
		for (let valueName in arr.modifiedVariables){
			if (window[valueName] != undefined){
				if (isArrayOrObject(arr.modifiedVariables[valueName])){
					window[valueName] = calculateObjectsByOperator(arr.modifiedVariables[valueName], window[valueName]);
				} else{
					window[valueName] = structuredClone(arr.modifiedVariables[valueName]);
				}
			}
		}
		
		flattenNestedEvents();
	}
	
	function isVariableNew(i){
		let isNew = false;
		
		if (!defaultVariables[i] && i != "defaultVariables"){
			if (window[i] != undefined && window[i] != null){
				if (typeof(window[i]) != "function" && !(window[i] instanceof HTMLCanvasElement) && !(window[i] instanceof CanvasRenderingContext2D)){
					if (i != "originalVariableValues" && i != "gameSaves" && i != "currentGame" && i != "gameData"){
						isNew = true;
					}
				}
			}
		}
		return isNew;
	}
	
	function initiateGame(){
		if (!hasInitiated){
			let currentURL = new URLSearchParams(location.search);
			if (gameData[currentURL.get('game')]){
				currentGame.currentState = currentURL.get('game');
			}
			
			for (let i in window){
				if (isVariableNew(i)){
					originalVariableValues[i] = structuredClone(window[i]);
				}
			}
		} else{
			for (let i in window){
				if (isVariableNew(i)){
					if (originalVariableValues[i] == undefined){
						delete window[i];
					} else{
						window[i] = structuredClone(originalVariableValues[i]);
					}
				}
			}
		}
		
		if (gameData[currentGame.currentState] != undefined){
			changeValuesByGameData();
		}
		
		document.getElementById("titleId").innerHTML = "Sover the " + currentGame.currentState;
		
		if (events.onload != undefined){
			runEvent(events.onload);
		}
		
		if (!hasInitiated){
			nextFrame();
		}
		
		hasInitiated = true;
	}
	
	function loadGame(args){
		let previousGameName = currentGame.currentState;
		
		if (gameData[args.gameName] != undefined){
			if ((args.gameName == "Game Selection") ? (confirm("Are you sure you'd like to quit " + previousGameName + "?\n\nYour progress won't be saved (except for high scores).")) : true){
				currentGame.currentState = args.gameName;
				
				initiateGame();
				
				if (args.gameName == "Game Selection"){
					gameState.currentState = "newGames";
					
					selectedGame = previousGameName;
					
					runEvent("gameSelect");
				}
			}
		}
	}
	
</script>

<script> //Notes Canvas
	
	var notesCanvas = document.getElementById("notesCanvasId");
	var notesCtx = notesCanvas.getContext("2d");
	notesCanvas.oncontextmenu = function(){return false;}
	notesCanvas.height = window.innerHeight;
	notesCanvas.width = window.innerWidth;
	
	let isNotesClickable = false;
	let isNotesTextHidden = false;
	
	let notesColors = [colors.enby[3], ...colors.trans.slice(0, 3), ...colors.pan, ...colors.enby];
	let currentNotesColorNum = 0;
	
	function clickNotesCanvas(pos){
		if (currentNotesColorNum >= notesColors.length){
			currentNotesColorNum = 0;
		}
		
		notesCtx.fillStyle = notesColors[currentNotesColorNum];
		
		if (isMouseDown){
			switch (mouseButton){
				case 1:
					notesCtx.fillRect(pos.x, pos.y, 3, 3);
				break;
				case 2:
					notesCanvas.width |= 0;
				break;
			}
		}
	}
	
</script>

<script> //Mouse Wheel (Zoom and Scroll)
	
	function isMovingCamera(){
		return (isMouseDown && mouseButton != 1 && mouseLockFrames > 1 && !isNotesClickable);
	}
	
	function cameraMouseDown(){
		if (camera.state.canMove && camera.state.shouldLockMouse){
			if(notesCanvas.requestPointerLock){
				notesCanvas.requestPointerLock();
			}else {
				notesCanvas.mozRequestPointerLock();
			}
			
			mouseLockFrames = 0;
		}
	}
	
	function cameraMouseUp(){
		if (camera.state.canMove && camera.state.shouldLockMouse){
			if(document.exitPointerLock){
				document.exitPointerLock();
			} else{
				document.mozExitPointerLock();
			}
		}
	}
	
	function cameraMouseMove(event){
		if (camera.state.canMove){
			if (isMovingCamera()){
				let speed = {
					x: event.movementX / canvas.width,
					y: event.movementY / canvas.height
				}
				
				speed.x *= (camera.zoom.min / camera.zoom.level) * camera.zoom.speed;
				speed.y *= (camera.zoom.min / camera.zoom.level) * camera.zoom.speed;
				
				camera.x -= speed.x * camera.speed;
				camera.y -= speed.y * camera.speed;
			}
		}
	}
	
	
	function zoomWheel(event){
		if (camera.state.canZoom){
			let zoom = camera.zoom;
			
			if (zoom.scrollSpeed <= 0 && zoom.scrollbarSpeed > 0){
				let pos = getScrollbarsPos();
				
				for (let xy of xyArr){
					if (pos[xy] != undefined){
						let isShiftDown = (inputs["ShiftLeft"] || inputs["ShiftRight"]);
						
						let shouldScroll = (xy == "x") ? isShiftDown : !isShiftDown;
						
						if (shouldScroll){
							let wh = xyToWH[xy];
							
							pos[xy][xy] += event.deltaY * zoom.scrollbarSpeed * pos[xy][wh];
							
							if (scrolledCameras[gameState.currentState] == undefined){
								scrolledCameras[gameState.currentState] = structuredClone(camera);
							}
							
							scrolledCameras[gameState.currentState][xy] = getCameraPosFromScrollbarPos(pos)[xy];
							
							refreshScrolledCamera(true);
						}
					}
				}
			} else{
				if (event.deltaY >= 0){
					zoom.level *= zoom.scrollSpeed;
				} else{
					zoom.level /= zoom.scrollSpeed;
				}
				
				zoom.level = getNumInRange(zoom.level, zoom.min, zoom.max);
			}
			
			drawCall(true);
		}
	}
	
</script>

<script> //Listeners
	
	//Window Resize
	
	function onResize(args = {}){
		canvas.height = window.innerHeight;
		canvas.width = window.innerWidth;
		
		notesCanvas.height = window.innerHeight;
		notesCanvas.width = window.innerWidth;
		
		let resetKeys = ["ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight"];
		
		for (let i in resetKeys){
			inputs[resetKeys[i]] = false;
		}
		
		if (args.shouldDraw != false){
			drawCall(true);
		}
	}
	
	window.addEventListener("resize", onResize);
	
	//Window Focus
	
	function onFocus(){
		drawCall(true);
	}
	
	window.addEventListener("focus", onFocus);
	
	
	//Inputs
	
	let inputs = []; //ex: inputs.KeyW
	
	function setKeyDown(e){
		e = e || window.event;
		inputs[e.code] = true;
		
		if (e.code == "Backquote"){
			isNotesClickable = !isNotesClickable;
		}
		if (e.code.includes("Digit")){
			currentNotesColorNum = e.code[5];
		}
		
		if (scrolledCameras[gameState.currentState] != undefined){
			if (e.code == "ArrowUp"){ scrolledCameras[gameState.currentState].y += scrollbarStep.y; }
			if (e.code == "ArrowDown"){ scrolledCameras[gameState.currentState].y -= scrollbarStep.y; }
			if (e.code == "ArrowLeft"){ scrolledCameras[gameState.currentState].x += scrollbarStep.x; }
			if (e.code == "ArrowRight"){ scrolledCameras[gameState.currentState].x -= scrollbarStep.x; }
		}
	}
	
	function setKeyUp(e){
		e = e || window.event;
		inputs[e.code] = false;
	}
	
	document.onkeydown = setKeyDown;
	document.onkeyup = setKeyUp;
	
	
	//Mouse
	
	function onMouseDown(event){
		setMousePos(notesCanvas, event);
		
		isMouseDown = true;
		mouseButton = event.buttons;
		
		if (isNotesClickable){
			clickNotesCanvas(mousePos);
		} else{
			if (mouseButton != 1){
				cameraMouseDown();
			}
			
			if ((shouldEditPolygons || shouldClickPolygons) && mouseButton == 1){
				savedPolygonsClick();
			}
			
			if (clickedPolygonVertex.i == -1){
				let scrollbarsPos = getScrollbarsPos();
				let isScrollbarBoxClicked = false;
				
				if (scrollbarsPos.w != undefined){
					isScrollbarBoxClicked = isVertexInRect(mousePosRatio, scrollbarsPos.w) || isScrollbarBoxClicked;
				}
				if (scrollbarsPos.h != undefined){
					isScrollbarBoxClicked = isVertexInRect(mousePosRatio, scrollbarsPos.h) || isScrollbarBoxClicked;
				}
				
				if (mouseButton == 1){
					scrollbarsClick(true);
					
					if (!isScrollbarBoxClicked){
						buttonsClick(true);
					}
					
					if (isScrollbarBoxClicked || clickedButton.i != ""){
						clickedPolygons = [];
					}
				} else{
					clickedScrollbar = {xy: "", clickedPos: {x: 0, y: 0}};
					clickedButton = {i: "", j: 0};
					
					buttonsClick(false, true);
				}
				
				if (!isScrollbarBoxClicked && clickedButton.i == "" && !closestButton.isHover){
					gridClick({isDown: true, mouseButton: mouseButton});
					
					if (clickedGridTile.gridName == ""){
						wasEmptyMouseDown = true;
					}
				}
			}
		}
	}
	
	function onMouseUp(event){
		setMousePos(notesCanvas, event);
		
		isMouseDown = false;
		wasEmptyMouseDown = false;
		
		if (isNotesClickable){
			
		} else{
			let wasButtonHover = closestButton.isHover
			
			scrollbarsClick(false);
			buttonsClick(false);
			
			if (!closestButton.isHover && !wasButtonHover){
				gridClick({isDown: false, isUp: true, mouseButton: mouseButton});
			}
			
			if (clickedPolygons.length > 0){
				savedPolygonsClick(false);
			}
		}
		
		clickedScrollbar = {xy: "", clickedPos: {x: 0, y: 0}};
		clickedButton = {i: "", j: 0};
		clickedPolygonVertex = {i: -1, layer: "", j: -1, type: ""};
		
		cameraMouseUp();
	}
	
	function onMouseMove(event){
		setMousePos(notesCanvas, event);
		
		let directions = getVertexToVertexDirection(mousePos, lastMousePos);
		let distance = getVertexDistance(mousePos, lastMousePos);
		let scaledDistance = getVertexDistance(scaledMousePos, lastScaledMousePos);
		
		if (isMovingCamera()){
			cameraMouseMove(event);
		} else{
			if (clickedPolygonVertex.i == -1){
				let incrementAmount = (isNotesClickable) ? 1 : distance*0.1;
				
				for (let i = 0; i < distance; i += incrementAmount){
					let currentPos = {
						x: mousePos.x + i * directions.x,
						y: mousePos.y + i * directions.y
					};
					let scaledCurrentPos = {
						x: scaledMousePos.x + (i/distance * scaledDistance) * directions.x,
						y: scaledMousePos.y + (i/distance * scaledDistance) * directions.y
					};
					
					if (isNotesClickable){
						clickNotesCanvas(currentPos);
					} else{
						//mouse move outside of notes
						scrollbarsClick(false, true);
						
						if (clickedScrollbar.xy == ""){
							buttonsClick(false, true);
							
							if (!closestButton.isHover){
								gridClick({isDown: false, mouseButton: mouseButton, currentMousePos: scaledCurrentPos});
							}
						}
					}
				}
			} else{
				if (!disablePolygonEditMovement){
					savedPolygonsMove();
				}
			}
		}
		
		mouseMoveEvent = undefined;
	}
	function onMouseMoveCall(event){
		mouseMoveEvent = event;
	}
	
	function setMousePos(c, event){
		let rect = c.getBoundingClientRect();
		
		lastMousePos = mousePos;
		lastMousePosRatio = mousePosRatio;
		lastScaledMousePos = scaledMousePos;
		
		mousePos = {
			x: event.clientX - rect.left,
			y: event.clientY - rect.top
		};
		
		mousePosRatio = {x: mousePos.x / c.width, y: mousePos.y / c.height};
		
		scaledMousePos = getScaledPositionInverted(mousePos);
	}
	
	notesCanvas.addEventListener("mousedown", onMouseDown);
	notesCanvas.addEventListener("mouseup", onMouseUp);
	notesCanvas.addEventListener('mousemove',onMouseMoveCall);
	notesCanvas.addEventListener('wheel', zoomWheel, {passive: true});
	
</script>

<script> //LocalStorage Save
	
	var savedData = localStorage.getItem("soverthe.saves");
	
	function refreshSaves(){
		try {
			savedData = JSON.parse(savedData);
		} catch (e){
			savedData = {};
		}
		
		if (!isObject(savedData)){
			savedData = {};
		}
		
		for (let i in gameSaves){
			if (savedData[i] != undefined){
				gameSaves[i].score = savedData[i];
			} else{
				savedData[i] = gameSaves[i].score;
			}
		}
		
		localStorage.setItem('soverthe.saves', JSON.stringify(savedData));
	}
	refreshSaves();
	
	function saveCurrentGameScore(score, type){
		gameSaves[currentGame.currentState] ??= {};
		
		let arr = gameSaves[currentGame.currentState];
		
		if (type != undefined){
			arr.score[type] ??= score;
			
			if (arr.score[type] == null || arr.trophies == undefined){
				arr.score[type] = score;
			} else{
				if (arr.trophies.mode == "less"){
					arr.score[type] = Math.min(score, arr.score[type]);
				} else{
					arr.score[type] = Math.max(score, arr.score[type]);
				}
			}
		} else{
			if (arr.score == null || arr.trophies == undefined){
				arr.score = score;
			} else{
				if (arr.trophies.mode == "less"){
					arr.score = Math.min(score, arr.score);
				} else{
					arr.score = Math.max(score, arr.score);
				}
			}
		}
		
		gameSaves[currentGame.currentState] = arr;
		
		refreshSaves();
	}
	
</script>
<script> //Browser Check
	
	function refreshBrowserName(){ //https://stackoverflow.com/a/13348618
		let winNav = window.navigator;
		let vendorName = winNav.vendor;

		let isChromium = window.chrome;
		let isOpera = typeof window.opr !== "undefined";
		let isFirefox = winNav.userAgent.indexOf("Firefox") > -1;
		let isIEedge = winNav.userAgent.indexOf("Edg") > -1;
		let isIOSChrome = winNav.userAgent.match("CriOS");
		let isGoogleChrome = isChromium !== null
			&& typeof isChromium !== "undefined"
			&& vendorName === "Google Inc."
			&& isOpera === false
			&& isIEedge === false
			&& (typeof winNav.userAgentData === "undefined" || winNav.userAgentData.brands.some(x => x.brand === "Google Chrome"));
		
		browserName = "Other";
		
		if (isChromium){ browserName = "Other Chromium"; }
		if (isOpera){ browserName = "Opera"; }
		if (isFirefox){ browserName = "Firefox"; }
		if (isIEedge){ browserName = "Edge"; }
		if (isIOSChrome){ browserName = "CriOS"; }
		if (isGoogleChrome){ browserName = "Chrome"; }
	}
	
</script>
<script> //Close Confirmation
	
	if (shouldConfirmBeforeClosing){
		window.onbeforeunload = function(e) {
			return "";
		};
	}
	
</script>

<script> //Calls
	refreshBrowserName();
	
	onResize({shouldDraw: false});
	
	initiateGame();
</script>
</body>
</html>