<!DOCTYPE html>
<html lang="en-US">
<head>
<title id="titleId">Sover the Page</title>
<meta charset="UTF-8">
<style>
	
	html, body { height: 100%; margin: 0; }
	body {
		overflow: hidden;
		background-color: #444444;
	}
	
	canvas {
		position: absolute;
		top: 0;
		left: 0;
	}
	
</style>
</head>
<body>
	<div style="position: relative;">
		<canvas id="canvasId"></canvas>
		<canvas id="notesCanvasId"></canvas>
	</div>
	<section id="imagesId" hidden></section>
<script> //Variables
	
	//if you're using notepad++, press Alt+3 to collapse all of the scripts
	
	//Canvas
	var canvas = document.getElementById("canvasId");
	var ctx = canvas.getContext("2d");
	canvas.oncontextmenu = function(){return false;}
	canvas.height = window.innerHeight; //969
	canvas.width = window.innerWidth; //1920
	
	var browserName = "Other";
	
	//Default Variables
	var hasInitiated = false;
	
	var defaultVariables = {};
	
	for (let i in window){
		if (window[i] != undefined && window[i] != null){
			defaultVariables[i] = true;
		}
	}
	
	
	//FPS
	var fps = 60;
	
	
	//Directions
	var xyArr = ["x", "y"];
	var whArr = ["w", "h"];
	var xywhArr = ["x", "y", "w", "h"];
	var xyToWH = {x: "w", y: "h"};
	var whToXY = {w: "x", h: "y"};
	var xywhInverse = {x: "y", y: "x", w: "h", h: "w"};
	
	var directions = [{x: 0, y: -1}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}];
	var directionsInverse = [{x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0}];
	var directionNumsInverse = [2,3,0,1];
	
	
	//Keyboard / Gamepad
	var keyboardAxes = {
		x: {negative: ["KeyA","ArrowLeft"], positive: ["KeyD","ArrowRight"]},
		y: {negative: ["KeyW","ArrowUp"], positive: ["KeyS","ArrowDown"]}
	};
	
	var gamepadDpadAxes = {
		x: {negative: [14], positive: [15]},
		y: {negative: [12], positive: [13]}
	}
	
	var gamepads = navigator.getGamepads();
	var gamepadAxisRange = {min: 0.05, max: 0.75};
	
	
	var inputButtons = {
		//keyboard [], gamepads [[],[],[],[]], timer, maxTimer, disableHold, onclick, condition (ex: "fps > 30")
		
		//run: {keyboard: ["ShiftLeft"], gamepads: [[2],[2],[2],[2]], timer: 0, maxTimer: 0, onclick: {f: "onRun"}},
		//rotateRight: {keyboard: ["KeyX"], gamepads: [[1],[1],[1],[1]], timer: 0, maxTimer: 12, onclick: {f: "onRotateRight"}}
		
		/*ex: keyboardRotateRight: {keyboard: ["KeyY"], gamepads: [[0],[0],[0],[0]], timer: 0, maxTimer: 12, disableHold: true, onclick: {f: "onRotateRight"},
		condition: "rules[keyboardMovement] == true"*/
	}
	inputButtonStates = {};
	
	//Mouse
	var mousePos = {x: 0, y: 0};
	var mousePosRatio = {x: 0, y: 0};
	var scaledMousePos = {x: 0, y: 0};
	
	var lastMousePos = {x: 0, y: 0};
	var lastMousePosRatio = {x: 0, y: 0};
	var lastScaledMousePos = {x: 0, y: 0};
	
	var isMouseDown = false;
	var mouseButton = -1;
	
	//Camera
	var camera = {x: 0, y: 0, speed: 16, zoom: {level: 1, min: 0.02, max: 2, speed: 1, scrollSpeed: 0.9, scrollbarSpeed: 0.0005, defaultTextLevel: 0.2},
				  areDimentionsEqual: true, minWidthToHeightRatio: 2, state: {canMove: false, canZoom: false, shouldLockMouse: false}};
	
	var mouseLockFrames = 0;
	
	//Images
	var images = {};
	
	//Entities
	var entities = [
		//pos {x, y, w, h, shape}, boxPos, boxRatio, radians, rotationCenter,
		//color, isFill, (showPoints, showBox),
		//isPlayer, isStoppedByWalls, speed, runMultiplier, disabledMovementAxis {x, y},
		//dash {maxDistance, minDistance, charge, maxCharge}, health invincibility, maxInvincibility, movement,
		//attacks, onlyShootIfFoundTarget, shouldEval = true
	];
	
	var attacks = {
		//bullets, time, repeatAmount, center, shouldEval = true
	};
	
	var bullets = {
		//hitbox {radius (should be w), isHitboxHole, action {type, target, speed}}, damage, color, time, maxTime, canHitPlayers, canHitNotPlayers, shouldEval = true
	};
	
	
	//Buttons
	var gameState = {currentState: "menu", states: ["menu", "game"]};
	
	var buttons = {
		//pos {x, y, w, h}, text, textSize, downscaleTextLength, textOffset {x, y}, shouldCenterLines, downscaleSubtextLength,
		//color, textColor, outlineColor, lockedTitleColor, hoverColor, maxHoverAlphaNum,
		//subtext, subtextSize, subtextPos {x, y}, marginY, outlineSize, onclick {f, args}, isAbsolutePositioned
		//lockedText, lockedTitle, lockedTitleSize, lockedTitleShadowColor, lockedTitleShadowOffset
		
		//ex: {menu: [{pos: {x: 0.5, y: 0.5, w: 0.2, h: 0.1}, text: "Text", textSize: 0.2, onclick: {f: "funcName", args: 12}}]};
	};
	
	
	//var hoveredButtons = {gameState: "", arr: [], maxSeconds: 0.25, maxAlphaNum: 0.3, clickMultiplier: 1.75, releaseMultiplier: 2};
	var hoveredButtons = {gameState: "", arr: [], maxSeconds: 0.25, maxAlphaNum: 0.3, clickMultiplier: 1.25, releaseMultiplier: 2};
	
	var clickedButton = {i: "", j: 0};
	
	var closestButton = {i: "", j: 0, distance: -1};
	
	var valueReplacedButtons = {};
	var previousButtonsText = "";
	
	//Scrollbars
	var scrollbarsArr = {}; //ex: {menu: {x: {start: -4, end: 4}, y: {start: -2, end: 4}}};
	
	var scrollbarsSize = {w: 0.012, h: 0.02};
	var scrollbarsMinSize = {x: {w: 0.01}, y: {h: 0.02}};
	var scrollbarMargin = {x: 0.0025, y: 0.004};
	var scrollbarStep = {x: 0.025, y: 0.025};
	
	var hoveredScrollbars = {gameState: "", arr: {}, maxSeconds: 0.25, maxAlphaNum: 0.5, clickMultiplier: 1.75, releaseMultiplier: 2};
	
	var clickedScrollbar = {xy: "", clickedPos: {x: 0, y: 0}};
	
	var scrolledCamera = structuredClone(camera);
	var scrolledCameras = {};
	
	
	//Grid
	var gridNames = [];
	
	var clickedGridTile = {gridName: "", layer: "", pos: {x: -1, y: -1}, isDown: false, mouseButton: -1, lastOnDownPos: {x: -1, y: -1}};
	
	
	//Polygons Editing
	var shouldEditPolygons = false;
	var shouldClickPolygons = false;
	
	var isCurveSymmetryDefault = true;
	
	var savedPolygons = {};
	var clickedPolygonVertex = {i: -1, layer: "", j: -1, type: ""};
	var clickedPolygons = [];
	
	//Fonts
	var defaultFont = "Consolas";
	
	const cursefont = new FontFace('Cursefont', 'url(Cursefont.ttf)');
	
	cursefont.load().then((font) => {
		document.fonts.add(font);
		
		defaultFont = "Cursefont";
		originalVariableValues["defaultFont"] = "Cursefont";
	});
	
	
	//Events
	var events = {
		//onload: [{f: "generateButtons", args: {arrName: "buttonNumbers", pos: {x: -0.2, y: 0.2, w: 0.05, h: 0.03, margin: {w: 0.01, h: 0.01}}, grid: {w: 8}}}],
	};
	
	var delayedEvents = [];
	
	
	//Colors
	var colors = {
		white: "#ffffff",
		black: "#000000",
		
		backgroundColor: "#646464",
		
		ace: ["#000000", "#a3a3a3", "#ffffff", "#880088"],
		pan: ["#ff218c", "#ffd800", "#21b1ff"],
		aro: ["#3da542", "#a7d379", "#ffffff", "#a9a9a9", "#000000"],
		aroace: ["#e28c00", "#eccd00", "#ffffff", "#62aedc", "#203856"],
		bi: ["#d60270", "#9b4f96", "#0038a8"],
		enby: ["#fff433", "#ffffff", "#9b59d0", "#2d2d2d"],
		trans: ["#5bcefa", "#f5a9b8", "#ffffff", "#f5a9b8", "#5bcefa"],
		poly: ["#f61cb9", "#07d569", "#1c92f6"],
		agender: ["#000000", "#b9b9b9", "#ffffff", "#b8f483", "#ffffff", "#b9b9b9", "#000000"],
		demiboy: ["#7f7f7f", "#c4c4c4", "#9ad9eb", "#ffffff", "#9ad9eb", "#c4c4c4", "#7f7f7f"],
		demigirl: ["#7f7f7f", "#c4c4c4", "#ffaec9", "#ffffff", "#ffaec9", "#c4c4c4", "#7f7f7f"],
		genderfluid: ["#ff75a2", "#f5f5f5", "#be18d6", "#2c2c2c", "#333ebd"],
		genderqueer: ["#b57edc", "#ffffff", "#4a8123"],
		lesbian: ["#d52d00","#ef7627","#ff9a56","#ffffff","#d162a4","#b55690","#a30262"],
		lesbianFiveStripes: ["#d52d00","#ff9a56","#ffffff","#d362a4","#a30262"],
		mlm: ["#078d70","#26ceaa","#98e8c1","#ffffff","#7bade2","#5049cc","#3d1a78"],
		mlmFiveStripes: ["#078d70","#98e8c1","#ffffff","#7bade2","#3d1a78"],
		pride: ["#e50000", "#ff8b00", "#ffee00", "#028121", "#004cff", "#770088"],
		
		defaultButton: "#ffffff",
		defaultButtonText: "#222222",
		defaultButtonOutline: "#000000",
		defaultButtonHover: "hsla(0, 100%, 100%, {{alphaNum}})",
		defaultGridHover: "hsla(0, 100%, 100%, {{alphaNum}})",
		
		defaultButtonLocked: "#777777",
		defaultButtonLockedText: "#222222",
		defaultButtonLockedOutline: "#000000",
		
		defaultButtonLockedTitle: "#ffffff",
		defaultButtonLockedTitleShadow: "#000000",
		
		defaultButtonBorder: "#000000",
		
		defaultPolygonFillColor: "#000000",
		defaultPolygonStrokeColor: "#000000",
		
		scrollbar: "#ffffffaa",
		scrollbarBackground: "#ffffff33",
		scrollbarHover: "hsla(0, 100%, 100%, {{alphaNum}})",
		
		
		debugText: "#000000"
	}
	
	//Default Values
	var defaultValues = {
		textMarginY: 0.115,
		
		buttonTextSize: 0.1,
		buttonTextMarginY: 0.115,
		buttonOutlineSize: 0.00015,
		buttonSubtextOutlineSize: 0.0001,
		buttonSubtextSize: 0.05,
		buttonSubtextPos: {x: 0.4, y: 0.3},
		
		lockedButtonTitle: "",//"[Locked]",
		lockedButtonTitleSize: 0.0125,
		lockedButtonTitleShadowOffset: {x: 0.00125, y: 0.00125},
		
		gridBorderSize: 0.002,
		gridHoverAlphaNum: 0.3,
		
		channelIconPiece: ""
	}
	
	//Draw Order & Layers
	var drawOrder = ["drawGrids", "drawEntities", "drawButtons", "drawScrollbars"];
	var drawLayers = [];
	
	//
	var cancelNextDrawFrame = false;
	
	//Eval (technically not eval but it works like it)
	var shouldEvalText = true;
	
	//(this gets saved in initiateGame())
	var originalVariableValues = {};
	
	
</script>
<script src="CountriesData.js"></script>
<script> //Game Data Extras
	
	var gamePresets = {
		lockedCamera: {state: {canMove: false, canZoom: false, shouldLockMouse: false}},
		freeCamera: {state: {canMove: true, canZoom: true, shouldLockMouse: true}},
		zoomCamera: {state: {canMove: false, canZoom: true, shouldLockMouse: false}},
		
		textButton: {disableClick: true, color: "#00000000"},
		
		//channelIconPieceBackgroundText: {f: "addButtonToCurrentGameState", args: {pos: {x: 0, y: 0.03, w: 1, h: 1}, text: defaultValues.channelIconPiece,
		//								 textSize: 0.9, disableClick: true, outlineSize: 0.00075, textColor: "#616161", outlineColor: "#00000000", color: "#00000000"}},
		
		
		channelIconPieceBottomRight: {pos: {x: 1 - 0.075 + 0.01, y: 1 - 0.15 + 0.02, w: 0.075, h: 0.1525}, isAbsolutePositioned: true, text: defaultValues.channelIconPiece,
									  textSize: 1.79, outlineSize: 0.00075, textColor: colors.ace[1], outlineColor: "#00000000", color: "#32323200", textOffset: {y: 0.0095},
									  onclick: [{f: "loadGame", args: {gameName: "Game Selection"}}]},
		
		quitButton: {pos: {x: 0.9645, y: 0.0365, w: 0.04, h: 0.03}, isAbsolutePositioned: true,
					 text: "Quit", textSize: 0.3, color: "#ffffffAA", onclick: [{f: "loadGame", args: {gameName: "Game Selection"}}]},
	};
	
	//you can use the spread syntax, ex: {areDimentionsEqual: false, ...gamePresets["lockedCamera"]}
	
</script>

<script> //Game Data
	
	var currentGame = {currentState: "Game Selection", states: []};
	var selectedGame = "";
	
	var gameSaves = { //(the trophies are currently unused)
		"Not-So-Quick Save": {score: null, text: "Clicks", trophies: {gold: 36, silver: 143, bronze: 250, mode: "less"}},
		"Shape-Shifting Minesweeper": {score: {Tiny: null, Medium: null, Huge: null}, text: "Explosions", trophies: {gold: 0, silver: 2, bronze: 5, mode: "less"}, sizes: ["Tiny", "Medium", "Huge", "Massive"]},
		"Countries Quiz": {score: null, text: "First Tries", trophies: {gold: 198, silver: 100, bronze: 20, mode: "more"}},
		"''Fascinating'' ''Possibilities''": {score: null, text: "Clicks", trophies: {gold: null, silver: null, bronze: null, mode: "less"}},
	};
	
	var currentVideos = [];
	
	currentGame.states = Object.keys(gameSaves);
	
	var shouldConfirmBeforeClosing = true; //todo: make this true for the release
	
	var gameData = {
		"Not-So-Quick Save": {
			overriddenVariables: {
				events: {
					onload: [
						{f: "resetButtons", args: {state: "all"}},
						{f: "addButtonsFromButtonsArray", args: {arrName: "menuButtons"}},
						"addOverlayTexts"
					],
					
					addOverlayTexts: [
						{f: "addButtonToOverlay", args: {...gamePresets.channelIconPieceBottomRight, textColor: "#ffffffd4"}},
						{f: "addButtonToOverlay", args: {pos: {x: -0.8, y: 0.4, w: 0.075, h: 0.15},
						text: "Power outage in:\n{{maxButtonClicks - buttonClicks}} clicks",
						textSize: 0.325, disableClick: true, outlineSize: 0.00075, textColor: "powerOutageText", outlineColor: "#00000000", color: "#00000000"}},
					],
					
					refreshCharts: [
						"<<changeButtonArgsById('engineChart', {text: 'Engine Circle Slice [' + charts.engine + '%]'});>>",
						"<<changeButtonArgsById('gameplayChart', {text: 'Gameplay Circle Slice [' + charts.gameplay + '%]'});>>",
						"<<changeButtonArgsById('levelChart', {text: 'Level Design Circle Slice [' + charts.level + '%]'});>>",
						"<<changeButtonArgsById('worldChart', {text: 'World Design Circle Slice [' + charts.world + '%]'});>>",
						"<<changeButtonArgsById('graphicChart', {text: 'Graphic Circle Slice [' + charts.graphic + '%]'});>>",
						
						"<<changeButtonArgsById('tieChart', {isHidden: (charts.gameplay != charts.level || charts.level != 15)});>>",
					],
					
					powerOutageCheck: [
						"<<if (buttonClicks >= maxButtonClicks){ gameState.currentState = 'Fail'; }>>"
					],
					
					resetVariables: [
						`<<{
							buttonToggles = {vSync: false, highNoShadows: false, buttonDNA: false, creditsOptions: false, extras3: false, wonTicTacToe: false, tookCredit: false,
							catalan: true, phonetic: false, potatoRhyme: true, wonChess: false, isLeftControlLeft: true, isRightControlRight: true,
							fishEvolve: false, fishness: false, simplifiedBooks: false, unlockLock: false, buttonAnimation: false, inferentialStats: false};
							
							achievements = {local: "4", global: "9,870,237,264"};
							charts = {engine: 20, gameplay: 20, level: 20, world: 20, graphic: 20};
							sampledPeople = "100";
							inputtedCode = "";
							desertCode = 0;
							
							gender = "Uncustomized Gender";
							pluralGender = "Uncustomized Gendered People";
							
							runEvent("onload");
						}>>`,
					],
					
					onNextFrame: ["powerOutageCheck", "draw"],
				}
			},
			createdVariables: {
				buttonClicks: 0,
				maxButtonClicks: 250,
				
				buttonToggles: {vSync: false, highNoShadows: false, buttonDNA: false, creditsOptions: false, extras3: false, wonTicTacToe: false, tookCredit: false,
				catalan: true, phonetic: false, potatoRhyme: true, wonChess: false, isLeftControlLeft: true, isRightControlRight: true,
				fishEvolve: false, fishness: false, simplifiedBooks: false, unlockLock: false, buttonAnimation: false, inferentialStats: false},
				
				achievements: {local: "4", global: "9,870,237,264"},
				charts: {engine: 20, gameplay: 20, level: 20, world: 20, graphic: 20},
				sampledPeople: "100",
				inputtedCode: "",
				desertCode: 0,
				
				gender: "Uncustomized Gender",
				pluralGender: "Uncustomized Gendered People",
				
				menuButtons: {
					buttons: [
						{value: "Options", buttons: [
							{value: "Graphical Options", buttons: [
								{value: "Vertical Sync", toggle: {value: "vSync"}},
								{value: "Horizontal Sync", toggle: {value: "vSync", isInverse: true}},
								{value: "High-Quality No Shadows", toggle: {value: "highNoShadows"}},
								{value: "Chartical Options", buttons: [
									{value: "Engine Circle Slice [20%]", id: "engineChart", onclick: [
										"<<charts.engine += 10;>>", "<<charts.gameplay -= 5;>>", "<<charts.world -= 5;>>", "refreshCharts"
									]},
									{value: "Gameplay Circle Slice [20%]", id: "gameplayChart", onclick: [
										"<<charts.gameplay += 10;>>", "<<charts.level -= 5;>>", "<<charts.world -= 5;>>", "refreshCharts"
									]},
									{value: "Story/Quest Circle Slice [100%]", isLocked: true},
									{value: "Dialogues Circle Slice [1000%]", isLocked: true},
									{value: "Level Design Circle Slice [20%]", id: "levelChart", onclick: [
										"<<charts.level += 10;>>", "<<charts.engine -= 5;>>", "<<charts.graphic -= 5;>>", "refreshCharts"
									]},
									{value: "AI Circle Slice [?%]", buttons: [
										{label: "Come back once AI takes over the world and adds extra content to this game", text: "Back", isBack: true}
									]},
									{value: "World Design Circle Slice [20%]", id: "worldChart", onclick: [
										"<<charts.world += 10;>>", "<<charts.gameplay -= 5;>>", "<<charts.graphic -= 5;>>", "refreshCharts"
									]},
									{value: "Graphic Circle Slice [20%]", id: "graphicChart", onclick: [
										"<<charts.graphic += 10;>>", "<<charts.engine -= 5;>>", "<<charts.level -= 5;>>", "refreshCharts"
									]},
									{value: "Sound Circle Slice [0%]", isLocked: true},
									{value: "Back", isBack: true},
									{value: "TIE RESOLVER", id: "tieChart", isHidden: true, onclick: [
										"<<charts.gameplay -= 5;>>",
										"<<charts.level += 5;>>",
										"refreshCharts"
									]}
								]}
							]},
							{value: "Reassign Controls", buttons: [
								{text: "Left Control Input: ", toggle: {value: "isLeftControlLeft"}, toggleTexts: {true: "Left Control", false: "Right Control"}},
								{text: "Right Control Input: ", toggle: {value: "isRightControlRight"}, toggleTexts: {true: "Right Control", false: "Left Control"}},
							]},
							{value: "Latency Calibration", buttons: [
								{value: "Click", label: "Click this button exactly when you click this button to calibrate", id: "calibration",
								onclick: "<<changeButtonArgsById('calibrationLabel', {text: 'Latency: 0 kilohertz^-1'});>>"},
							]},
							{value: "Sound Latency Calibration", buttons: [
								{value: "Change Sound Speed", label: "Speed of Sound: 343 m/s", id: "speed", buttons: [
									{label: "Please change your air temperature to change the speed of sound", value: "Back", isBack: true},
								]},
								{value: "Complain about the chosen units", id: "speed",
								onclick: "<<changeButtonArgsById('speedLabel', {text: 'Speed of Sound: 343 (c / 299792458 hertz) hertz'});>>"},
							]},
							{value: "Language Options", buttons: [
								{value: "Catalan Different From Spanish", toggle: {value: "catalan"}},
								{value: "Potato Rhymes With Entire", toggle: {value: "potatoRhyme"}},
								{value: "Simplified Books", toggle: {value: "simplifiedBooks"}},
								{value: "Phonetic English Pronunciation", toggle: {value: "phonetic"}},
								{value: "Rogue Owl On The Loose: On"},
							]},
							{value: "Misc Options", buttons: [
								{text: "Unlock Credits Options", value: "creditsOptionsToggle", id: "creditsToggleId", toggle: {value: "creditsOptions"}, onclick: "<<changeButtonArgsById('creditsOptions', {isLocked: !buttonToggles.creditsOptions});>>"},
							]},
						]},
						{value: "Gameplay Options", buttons: [
							{value: "Is Game Playable: Yes", isLocked: true},
							{value: "Very nice button pressing animation", toggle: {value: "buttonAnimation"}, isLocked: true},
							{value: "No Button DNA", toggle: {value: "buttonDNA", isInverse: true}, isLocked: true},
							{value: "Don't Try Evolving", buttons: [
								{label: "You managed to not try to evolve", text: "Woah", isBack: true},
							]},
							{value: "Unlock Locked House of Unlocked House and Lock House of Locked House", toggle: {value: "unlockLock"}},
						]},
						{value: "Lifework Options", buttons: [
							{value: "Is Life Playable: NO", isLocked: true},
							{value: "Very BAD button pressing animation", toggle: {value: "buttonAnimation", isInverse: true}, isLocked: true},
							{value: "Button DNA", toggle: {value: "buttonDNA"}},
							{value: "Try Evolving", buttons: [
								{label: "Cannot evolve without Button DNA", text: "Succeed At Evolving", id: "evolveId", buttons: [
									{text: "Fishness: ", toggle: {value: "fishness"}, toggleTexts: {true: "Fully Fish", false: "None"}},
								]},
							], onclick: [
								`<<
									if (buttonToggles.buttonDNA){
										if (buttonToggles.fishEvolve){
											changeButtonArgsById('evolveId', {isLocked: false});
											changeButtonArgsById('evolveIdLabel', {text: 'You can evolve into a Fish!'});
										} else{
											changeButtonArgsById('evolveId', {isLocked: true});
											changeButtonArgsById('evolveIdLabel', {text: 'You have no idea what to evolve into'});
										}
									} else{
										changeButtonArgsById('evolveId', {isLocked: true});
										changeButtonArgsById('evolveIdLabel', {text: 'Cannot evolve without Button DNA'});
									}
								>>`
							]},
							{value: "Lock House of Unlocked House and Unlock Locked House of Locked House", toggle: {value: "unlockLock", isInverse: true}},
						]},
						{value: "Achievements", buttons: [
							{value: "Your Achieved ments: ", extraText: "{{achievements.local}}", isLabel: true},
							{value: "Globally Achieved ments: ", extraText: "{{achievements.global}}", isLabel: true},
							{value: "Erase All Achievements (personal computer)", onclick: ["<<achievements.local = '0';>>", "<<achievements.global = achievements.global.slice(0, -1) + '0';>>"]},
							{value: "Erase All Achievements (everyone's computers)", onclick: ["<<achievements.global = '0';>>","<<achievements.local = '0';>>"]}
						]},
						{value: "Statistics", buttons: [
							{value: "Inferential Statistics", buttons: [
								{value: "Example I", buttons: [
									{label: "I sampled 100 people and they were all humans, therefore:", value: "Everything in the Universe is human", id: "sampledPeople", buttons: [
										{label: "Correct, you have now mastered Inferential Statistics Statistical Inference", value: "Yes I know", isFullyBack: true, onclick: "<<buttonToggles.inferentialStats = true;>>"}
									]},
									{value: "Everyone's lying", buttons: [
										{value: "You're so right bestie", isFullyBack: true}
									]},
									{value: "Sample size is too small", onclick: [
										"<<sampledPeople += '0';>>",
										"<<changeButtonArgsById('sampledPeopleLabel', {text: 'I sampled '+sampledPeople+' people and they were all humans, therefore:'});>>",
									]},
								]},
								{value: "Example II", buttons: [
									{label: "Example I was perfect, how dare you ask for another one", value: "It was cherry-picked", buttons: [
										{label: ":O", value: "I see through your lies", buttons: [
											{label: "You're right, I apologize to the harm I caused for the Statistic Wizard(s)", value: "Awesome", isFullyBack: true}
										]},
										{value: "(Stop bullying the poor game)", isFullyBack: true}
									]},
									{value: "I deeply appreciate Example I", buttons: [
										{label: "I sampled 1 person and they liked Example I, therefore:", value: "Everything in the Universe is Example I", buttons: [
											{label: "Yess, you're really good at Inferentials now", value: "Thank you kindly", isFullyBack: true, onclick: "<<buttonToggles.inferentialStats = true;>>"}
										]},
										{value: "That 1 person was awesome", buttons: [
											{label: "Love the confidence, it reflects positively on the entire human population", value: "50%^0", isFullyBack: true}
										]},
									]},
								]},
							]},
							{value: "Descriptive Statistics", buttons: [
								{label: "Our scientist quit due to lack of funding, none of we remaining idiots know about descriptive statistics", text: "Bummer", isBack: true}
							]},
						]},
						{value: "Leaderboards", buttons: [
							{text: "Best Country (By GDP): Country 2", isLabel: true},
							{text: "Best Country (By Education Index): Country 2", isLabel: true},
							{text: "Best Country (By Life Expectancy): Country 2", isLabel: true},
							{text: "Best Country (By Glucose Production): Country 2", isLabel: true},
							{text: "Best Country (By Glucose Exports): Country 2", isLabel: true},
							{text: "Best Country (By Glucose Expenditures): Country 2", isLabel: true},
							{text: "Best Country (By Good Country Index): Country 2", isLabel: true},
							{text: "Best Country (By Not Country 1 Country Index): Country 2", isLabel: true, id: "country1Leaderboards1"},
							{text: "Best Country (By Duo-Books Published): Country 2", isLabel: true},
							{text: "Best Country (By Annual Cannabis Use): Country 2", isLabel: true},
							{text: "Best Country (By Refined Good Country Index Exports): Country 2", isLabel: true},
							{text: "Best Country (By Forest Area): Country 1", isLabel: true, id: "country1Leaderboards2"},
						]},
						{value: "How To Play", buttons: [
							{value: "Button-Clicking Basics 101", buttons: [
								{label: "You can click on a button to click on it. Try it out!", value: "Click me!", buttons: [
									{label: "You can also click the Back button to go back one or more menus towards the main pause main menu", value: "Back", isBack: true}
								]},
								{value: "Donut click me", buttons: [
									{label: "That was a regular click and not a donut click", value: "Potato potato", isBack: true}
								]},
							]},
							{value: "Clicking-Button Advanced 201", buttons: [
								{label: "What would you like to learn about?", value: "Battles of Chess", buttons: [
									{label: "There's no chess in this game", value: "Could you add chess?", buttons: [
										{label: "Yeah sure, visit the Extras", value: "Thanks",
										onclick: "<<changeButtonArgsById('chess', {isLocked: false});>>", isFullyBack: true},
									]}
								]},
								{value: "Shields", buttons: [
									{label: "A shield adds an extra double-time hit to a Skeleton.", value: "shieldsTutorial", text: "Tell me more", buttons: [
										{label: "Yellow Skeletons run away after the first hit, so make sure to finish them off!", text: "Tell me more", buttons: [
											{label: "Black Skeletons take 2 hits before running away.", text: "Tell me more", buttons: [
												{label: "Blademasters are especially tricky. Listen for the SHING sound, then press the corresponding key on the next beat.", text: "Tell me more", buttons: [
													{label: "That's it for this tutorial. Now get out there and crush some monsters!", text: "Thank you Bard", isFullyBack: true}
												]}
											]}
										]}
									]}
								]},
								{value: "How to save", buttons: [
									{label: "Oh, well...", value: "H o w  t o  s a v e", buttons: [
										{label: "I-", value: "H O W  T O  S A V E", buttons: [
											{label: "I DON'T KNOW OKAY????", value: "oh", buttons: [
												{label: "I would suggest asking a wizard, but they might not even exist", value: "Where would they be if they exist?", buttons: [
													{label: "I would say \"Earth\"", value: "Thank you for saying that", isFullyBack: true},
												]},
												{value: "Alright", isFullyBack: true},
											]},
										]},
									]},
								]},
							]},
							{value: "How To Follow Instructions", buttons: [
								{value: "How To Follow Instructions Page 2", label: "Please refer to How To Follow Instructions Page 2", buttons: [
									{value: "How To Follow Instructions Page 1", label: "Please refer to How To Follow Instructions Page 1", onclickGameState: "How To Follow Instructions", savePreviousState: false},
								]},
							]},
							{value: "What To Play", buttons: [
								{label: "Not-So-Quick Save", text: "Now that's a game!", isBack: true},
							]},
						]},
						{value: "Extras", buttons: [
							{value: "Tic Tac Toe", buttons: [
								{label: "Where are you putting your symbol?", text: "Center", buttons: [
									{label: "I put mine to the side. Where are you symboling?", text: "Opposite Side", buttons: [
										{label: "This is going to be a draw", text: "Draw", isFullyBack: true}
									]},
									{text: "Side Side", buttons: [
										{label: "I block your attempt. Where symbol?", text: "Corner Next To Your Symbol", buttons: [
											{label: "This is going to be a draw", text: "Draw", isFullyBack: true}
										]},
										{text: "Corner Next To My Symbol", buttons: [
											{label: "I can't stop your attempt at winning", text: "Win", isFullyBack: true, toggle: {value: "wonTicTacToe", shouldTurnOff: false, hideText: true}}
										]},
										{text: "Side", buttons: [
											{label: "I put mine at the corner with my other symbols and will win", text: "Resign", isFullyBack: true}
										]},
									]},
									{text: "Corner Next To Yours", buttons: [
										{label: "I block your attempt. Where symbol?", text: "Corner Next To Your Symbol", buttons: [
											{label: "This is going to be a draw", text: "Draw", isFullyBack: true}
										]},
										{text: "Corner Next To Nothing", buttons: [
											{label: "I can't stop your attempt at winning", text: "Win", isFullyBack: true, toggle: {value: "wonTicTacToe", shouldTurnOff: false, hideText: true}}
										]},
										{text: "Side Next To My Symbols", buttons: [
											{label: "I can't stop your attempt at winning", text: "Win", isFullyBack: true, toggle: {value: "wonTicTacToe", shouldTurnOff: false, hideText: true}}
										]},
										{text: "Side Not Next To My Corner Symbol", buttons: [
											{label: "This is going to be a draw", text: "Draw", isFullyBack: true}
										]},
									]},
									{text: "Corner Not Next To Yours", buttons: [
										{label: "I block your attempt. Where symbol?", text: "I'll also block your attempt", buttons: [
											{label: "I can't stop your attempt at winning", text: "Win", isFullyBack: true, toggle: {value: "wonTicTacToe", shouldTurnOff: false, hideText: true}}
										]},
										{text: "I won't block your attempt >:(", buttons: [
											{label: "I win", text: "Resign Post-Game", isFullyBack: true}
										]},
									]},
								]},
								{text: "Side", buttons: [
									{label: "I put mine in the center", text: "Resign", isFullyBack: true}
								]},
								{text: "Corner", buttons: [
									{label: "I put mine in the center", text: "Resign", isFullyBack: true}
								]},
							]},
							{value: "Back", isBack: true},
							{value: "Chess (new)", id: "chess", isLocked: true, hideLocked: true, buttons: [
								{label: "How would you like to play?", text: "Poorly", buttons: [
									{label: "I win", text: "Darn", isFullyBack: true}
								]},
								{text: "As best as I can", buttons: [
									{label: "I'm a computer therefore I win", text: "Shucks", isFullyBack: true}
								]},
								{text: "I wanna cheat", buttons: [
									{label: "It's a draw", text: "WHAT", buttons: [
										{label: "Google \"en passant\"", text: "No >:(", buttons: [
											{label: "Okay I did cheat a little on moves 1-8848.5", text: "Typical", isFullyBack: true},
											{text: "Topical", isFullyBack: true},
											{text: "Tropical", isFullyBack: true},
											{text: "Trophical", isFullyBack: true},
											{text: "Can I win then?", buttons: [
												{label: "Yeah sure", text: "Wicked", isFullyBack: true, toggle: {value: "wonChess", shouldTurnOff: false, hideText: true}}
											]},
										]},
										{text: "Can you Google it for me?", onclick: "<<window.open('https://www.google.com/search?q=en+passant')>>"}
									]},
								]},
								{text: "Back", buttons: [
									{label: "Wow okay, I make chess specifically for you and you just leave?", text: "Yiss", isFullyBack: true}
								]},
							]},
						]},
						{value: "Earth Back Extras", text: "Extras II", buttons: [
							{value: "Earth", buttons: [
								{text: "Continent 1", buttons: [
									{text: "Country 1", id: "country1", buttons: [
										{text: "Province 1", buttons: [
											{text: "City 1", buttons: [
												{text: "House 1", buttons: [
													{text: "Computer", buttons: [
														{text: "Folder 1", buttons: [
															{label: "You wish you could unlearn what you saw here", text: "[Unlearn]", buttons: [
																{label: "You have unlearned what you saw here", text: "What was it?", buttons: [
																	{label: "See? It worked", text: "Back", isBack: true},
																]},
															]},
														]},
														{text: "Folder 2", buttons: [
															{text: "Super Secret Password.txt", buttons: [
																{label: "\"First number divisible by 191 and 617 without remainders\"", text: "Secret About The Super Secret Password.innerTXT", buttons: [
																	{text: "(they're primes)", isLocked: true, lockedTitle: "They're really primes."},
																]},
															]},
														]},
													]},
												]},
												{text: "House 2", buttons: [
													{label: "House 2 wishes to be in Country 2 but can't", text: "Why not?", buttons: [
														{label: "Because it's in Country Want, not Country Wish", text: "That's not what it's called", buttons: [
															{label: "Yes it is, check again.", text: "Back", isBack: true},
														], onclick: [
															"<<changeButtonArgsById('country1', {text: 'Country Want'})>>",
															"<<changeButtonArgsById('country1Leaderboards1', {text: 'Best Country (By Not Country Want Country Index): Country 2'})>>",
															"<<changeButtonArgsById('country1Leaderboards2', {text: 'Best Country (By Forest Area): Country Want'})>>",
														]},
													]},
												]},
											]},
											{text: "City 2", buttons: [
												{text: "Shady Hut", buttons: [
													{text: "[Look at Wizard]", buttons: [
														{label: "You see Wizard.", text: "Back", isBack: true}
													]},
													{text: "[Talk to Wizard]", buttons: [
														{text: "[Ask about Shady Hut]", buttons: [
															{label: "\"It is a temporary residence for the big one.\"", text: "Oh okay, I fully understand", isBack: true},
														]},
														{text: "[Ask about Wizardself]", buttons: [
															{label: "\"I am the Curse Wizard, the only wizard for now.\"", text: "For now?", buttons: [
																{label: "\"We are trying our best.\"", text: "Back", isBack: true},
															]},
															{text: "Can I learn more about you?", buttons: [
																{label: "\"I am quite busy now, but I have answered a lot of questions in Cursetris if you are interested.\"",
																text: "[Open Cursetris Right Now]", onclick: "<<window.open('https://soverthe.github.io/Cursetris.html')>>"},
															]},
														]},
														{text: "[Ask about weird menus]", buttons: [
															{label: "\"It might be a commentary on bad menus, or just a contribution perhaps.\"", text: "Um-hum", isBack: true},
														]},
														{text: "[Ask \"How to save\"]", buttons: [
															{label: "\"I was hoping you weren't interested about that.\"", text: "It's why I'm here", buttons: [
																{label: "\"Alright. First of all, Extras IV is the key, but it in itself needs keys.\"", text: "What kind of keys?", buttons: [
																	{label: "\"It accepts multiple passwords that can unlock different things.\"", text: "What are the passwords?", buttons: [
																		{label: "\"That's where the problem begins, I only know the most basic one.\"", text: "And what is it?", buttons: [
																			{label: "\"It's the one that lets you enter Country 2.\"", text: "Okay but what's the code?", buttons: [
																				{label: "\"The number '2'. It stands for 'Country 2'.\"", text: "...That's indeed very basic", buttons: [
																					{label: "\"But make no mistake, Country 2 is the most complex place in town... I mean Earth.\"", text: "What's in it?", buttons: [
																						{label: "\"People there value security to the highest degree, they'll ask a lot from you.\"", text: "Like what?", buttons: [
																							{label: "\"They'll only let you use certain things if they know you can be trusted with them.\"", text: "How can they know that?", buttons: [
																								{label: "\"They might be spying on you at all times and keeping notes about what you do.\"", text: "Thanks for the heads-up", buttons: [
																									{label: "\"No problem, sorry about your upcoming Back presses.\"", text: "Back", isBack: true},
																								]},
																							]},
																						]},
																					]},
																				]},
																			]},
																		]},
																	]},
																]},
															]},
														]},
														{text: "[Let them ask you stuff]", buttons: [
															{label: "What would you like to be asked?", text: "\"Who is your favorite Wizard?\"", onclick: "<<prompt('\"Who is your favorite Wizard?\"')>>", buttons: [
																{label: "\"Classic.\"", text: "Back", isBack: true},
															]},
															{text: "\"What do you think of these menus?\"", onclick: "<<prompt('\"What do you think of these menus?\"')>>", buttons: [
																{label: "\"Understandable.\"", text: "Back", isBack: true},
															]},
															{text: "\"Could you win a fight against a half-sized version of yourself?\"", onclick: "<<prompt('\"Could you win a fight against a half-sized version of yourself?\"')>>", buttons: [
																{label: "\"I thought so.\"", text: "Back", isBack: true},
															]},
															{text: "\"What is your favorite number color?\"", onclick: "<<prompt('\"What is your favorite number color?\"')>>", buttons: [
																{label: "\"I hope that wasn't a lie.\"", text: "Back", isBack: true},
															]},
															{text: "\"Do you like the music?\"", onclick: "<<prompt('\"Do you like the music?\"')>>", buttons: [
																{label: "\"Exactly.\"", text: "Back", isBack: true},
															]},
														]},
													]},
													{text: "[Perception the Wizard]", buttons: [
														{label: "With a high enough roll you would see Wizard, but you rolled too low sadly.", text: "Back", isBack: true}
													]},
													{text: "[Arcana check the Wizard]", buttons: [
														{label: "Arcana Level: Magical", text: "Back", isBack: true}
													]},
												]},
												{text: "Back House", buttons: [
													{label: "(One of these is lying)", text: "Back", isBack: true},
													{text: "Back", isBack: true},
													{text: "Back", isBack: true},
													{text: "Back", isBack: true},
													{text: "Back", isBack: true},
													{text: "Back", buttons: [
														{text: "Shady Hut", buttons: [
															{label: "THIS ISN'T THE SHADY HUT AT ALL, IT'S:", text: "Back House?", buttons: [
																{label: "sí", text: "Awesome", isBack: true},
																{text: "Back", buttons: [
																	{label: "One must not just simply Back House.", text: "Back House Complicatedly", buttons: [
																		{label: "...Oh no.", text: "What's up?", buttons: [
																			{label: "It seems like we stumbled onto a pass-away enigma in Back House. Care to solve it?", text: "Bring it on", buttons: [
																				{label: "I found a bunch of voice recordings, here they are:", text: "Act I: The Nobody", buttons: [
																					{text: "01-BA-0", buttons: [
																						{text: "[@] This is an audio with no people in it just like all the others.", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "[@] As you most definitely know, no one lives in Back House.", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "[@] Fun.", isLabel: true},
																						{text: "", isLabel: true},
																					]},
																					{text: "02-BA-0", buttons: [
																						{text: "[1003] It feels like there are a lot of people in this house.", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "[8213269530] Yeah, I think that there are as well.", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "[@] This is definitely a lie. Very very very very muy muchos interesting................", isLabel: true},
																						{text: "", isLabel: true},
																					]},
																				]},
																				{text: "Act II: Surely No One", buttons: [
																					{text: "03-BA-0", buttons: [
																						{text: "[@] Welcome to the surely no one of Act II!", isLabel: true},
																						{text: "", isLabel: true},
																					]},
																					{text: "04-BA-0", buttons: [
																						{text: "[@] What does BA mean anyways?", isLabel: true},
																						{text: "", isLabel: true},
																					]},
																				]},
																				{text: "Act III: Maybe Someone?", buttons: [
																					{text: "06-BA-0", buttons: [
																						{text: "[@] OKAY! I'm gonna just quickly delete 05-BA-0, that was CRAZY!", isLabel: true},
																						{text: "", isLabel: true},
																					]},
																				]},
																				{text: "Act IV: The Reckoning", buttons: [
																					{label: "There's no reckoning.", text: "Aw.", isBack: true},
																				]},
																			]},
																			{text: "I want to go back", buttons: [
																				{label: "Oh, it's too hard to get back from here? Would you like me to help?", text: "Yes", buttons: [
																					{label: "Click the first button to speed up the inevitable", text: "Click this.", onclick: "<<buttonClicks = 999998 + maxButtonClicks;>>"}
																				]},
																				{text: "No", isBack: true},
																			]},
																		]},
																	]},
																]},
															]},
														]},
														{text: "Back House", buttons: [
															{label: "(You were already in the Back House, check the Shady Hut)", text: "Back", isBack: true},
														]},
													]},
												]},
											]},
										]},
										{text: "Province 2", buttons: [
											{text: "Field 1", buttons: [
												{text: "Tree 1", buttons: [
													{label: "There's a note saying: \"This field (forest) is the pride of the country.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 2", buttons: [
													{label: "There's a note saying: \"Why do we call it a field? You tell me!\"", text: "Back", isBack: true},
												]},
												{text: "Tree 3", buttons: [
													{label: "There's a note saying: \"We are glad to be on the leaderboards, even if only once.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 4", buttons: [
													{label: "There's a note saying: \"At least we're not those security-obsessed freaks...\"", text: "Back", isBack: true},
												]},
												{text: "Tree 5", buttons: [
													{label: "There's a note saying: \"I apologize for my previous note.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 6", buttons: [
													{label: "There's a note saying: \"The people of Country 2 are okay.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 7", buttons: [
													{label: "There's a note saying: \"We do have 12 trees though.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 8", buttons: [
													{label: "There's a note saying: \"Each one one more than the last.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 9", buttons: [
													{label: "There's a note saying: \"...Life is simple here.\"", text: "Back", isBack: true},
												]},
												{text: "Tree 10", buttons: [
													{label: "There's a note saying: \"You just count the trees...\"", text: "Back", isBack: true},
												]},
												{text: "Tree 11", buttons: [
													{label: "There's a note saying: \"Then you become one, I think?\"", text: "Back", isBack: true},
												]},
												{text: "Tree 12", buttons: [
													{label: "There's a note saying: \"I don't fully get this evolution thing.\"", text: "Back", isBack: true},
												]},
											]},
											{text: "Field 2", buttons: [
												{text: "Strange Portal", buttons: [
													{text: "Earth 2", buttons: [
														{text: "Continent -1", buttons: [
															{text: "Country Infinity", buttons: [
																{text: "Province Antivince", buttons: [
																	{text: "Field City 0", buttons: [
																		{text: "Strange Note", buttons: [
																			{text: "Strange Text", buttons: [
																				{label: "You read: \"DO NOT ENTER 46656 AS THE PASSWORD\"", text: "Back", isBack: true},
																			]},
																		]},
																	]},
																]},
															]},
														]},
													]},
												]},
											]},
										]},
									]},
									{text: "Country 2", buttons: [
										{label: "You cannot enter Country 2", text: "Try to enter Country 2", isLocked: true, id: "country2", lockedTitle: "You cannot enter Country 2", buttons: [
											{text: "Commercial District", buttons: [
												{text: "Mall of Everything", buttons: [
													{text: "Library", id: "library", isLocked: true, lockedTitle: "These books are waaay too complicated for you", buttons: [
														{label: "Librarian: \"Welcome to the only library in the Observable Universe! Feel free to read either books.\"", text: "Read Book 1", buttons: [
															{text: "(This book used to be super complicated but has since been simplified)", isLabel: true},
															{text: "", isLabel: true},
															{text: "Bad things = bad", isLabel: true},
															{text: "Good things = debatable", isLabel: true},
															{text: "Batting an eye = batable", isLabel: true},
															{text: "Equals = =", isLabel: true},
															{text: "", isLabel: true},
															{text: "[Return the book]", isBack: true},
														]},
														{text: "Read Book 2", buttons: [
															{text: "Why is there no Book 3?", isLabel: true},
															{text: "", isLabel: true},
															{text: "Why is there no Country 3?", isLabel: true},
															{text: "", isLabel: true},
															{text: "Why is there no Extras 3? Oh wait...", isLabel: true},
															{text: "", isLabel: true},
															{text: "Nevermind that last one, there is an Extras 3,", isLabel: true},
															{text: "it's called Extras III.", isLabel: true},
															{text: "", isLabel: true},
															{text: "[Return the book]", isBack: true},
														]},
													], onclick: ["<<changeButtonArgsById('observableUniverse3', {isLocked: false});>>"]},
													{text: "Sub-Mall of Something?", buttons: [
														{label: "ya shant c dis", id: "somethingMall", text: "Back", isBack: true},
													], onclick: ["<<changeButtonArgsById('somethingMallLabel', {text: 'Here\\'s a free number just for you: ' + getReversedString((Math.random() + '').substring(2))});>>"]},
													{text: "Everything Else", buttons: [
														{text: "Everything (A-B)", buttons: [
															{text: "Apple", buttons: [
																{label: "good pineapple-like food", text: "Back", isBack: true},
															]},
															{text: "Bean", buttons: [
																{label: "the more the merrier foodier", text: "Back", isBack: true},
															]},
															{text: "Bird", buttons: [
																{label: "like a pigeon or worse", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (C-D)", buttons: [
															{text: "Cat", buttons: [
																{label: "curious being with curiosity", text: "Back", isBack: true},
															]},
															{text: "Curiosity", buttons: [
																{label: "cat concept with catosity", text: "Back", isBack: true},
															]},
															{text: "Duck", buttons: [
																{label: "the motion ducks can do while lowering themselves", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (E-F)", buttons: [
															{text: "Everything Else", buttons: [
																{label: "Everything (A-Z)", text: "Back", isBack: true},
															]},
															{text: "Extras", buttons: [
																{label: "a tetralogy without a fifth part", text: "Back", isBack: true},
															]},
															{text: "Frick", buttons: [
																{label: "the protagonist of Undertale", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (G-H)", buttons: [
															{text: "Go To", buttons: [
																{label: "the act of asking someone to go to", text: "Back", isBack: true},
															]},
															{text: "Hell And", buttons: [
																{label: "an alternate name for the Netherlands", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (I-K)", buttons: [
															{text: "J", buttons: [
																{label: "jhe jetter j js jice", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (L-M)", buttons: [
															{text: "Library", buttons: [
																{label: "wait this shouldn't be here?", text: "Back", isBack: true},
															]},
															{text: "Mashing Wachine", buttons: [
																{label: "good for demoving cirt from rlothes", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (N-O)", buttons: [
															{text: "NO", buttons: [
																{label: "x", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (P-R)", buttons: [
															{text: "Pineapple", buttons: [
																{label: "pinnacle apple-like food", text: "Back", isBack: true},
															]},
															{text: "Q", buttons: [
																{label: "pronounced \"queueu\"", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (S-T)", buttons: [
															{text: "Sub-", buttons: [
																{label: "a subfix", text: "Back", isBack: true},
															]},
															{text: "Tetralogy", buttons: [
																{label: "a four-part trilogy without a fifth part", text: "Back", isBack: true},
															]},
															{text: "Trilogy", buttons: [
																{label: "a three-part duology without a fourth part", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (U-V)", buttons: [
															{text: "UniVerse", buttons: [
																{label: "might contain multiple observable parts?", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (W-X)", buttons: [
															{text: "Wise", buttons: [
																{label: "pronounced \"wise\"", text: "Back", isBack: true},
															]},
															{text: "Xebra", buttons: [
																{label: "a stripped being spelled correctly", text: "Back", isBack: true},
															]},
														]},
														{text: "Everything (Y-Z)", buttons: [
															{text: "YZ", buttons: [
																{label: "pronounced \"wise\"", text: "Back", isBack: true},
															]},
														]},
													]},
												]},
												{text: "Mall of Nothing", buttons: [
													{text: "Back", isBack: true},
												]},
											]},
											{text: "Social Status District", buttons: [
												{text: "House of Games", buttons: [
													{text: "Sub-House of Tic Tac Toe Legends", id: "subTicTacToeHouse", isLocked: true, lockedTitle: "You haven't won a game of Tic Tac Toe yet bucko buddy", buttons: [
														{label: "You see a skeleton sitting in a chair. There's nothing more here.", text: "Go up to the skeleton", id: "skel1", buttons: [
															{label: "It's a skeleton alright. Must've been here for a really long time.", text: "Touch the skeleton", id: "skel2", buttons: [
																{label: "The skeleton slowly looks at you and says: \"Did... you... win...\"", text: "I won the Tic Tac Toe", id: "skel3", buttons: [
																	{label: "Tears start to fall out of their eye sockets, then they stand up and leave.", id: "skel4", text: "...", buttons: [
																		{label: "You notice a note on the chair where the skeleton used to be.", text: "Read the note", buttons: [
																			{label: "The note says: \"Thank you for freeing me, I can make more games now. - a Wizard\"", text: "Back", isBack: true},
																		]},
																	], onclick: ["<<changeButtonArgsById('skel4Label', {text: 'One of the best chairs you have seen so far.'});>>"]},
																], onclick: [
																	"<<changeButtonArgsById('skel1Label', {text: 'You see a chair. There\\'s nothing more here.'});>>",
																	"<<changeButtonArgsById('skel1', {text: 'Go up to the chair'});>>",
																	"<<changeButtonArgsById('skel2Label', {text: 'Tis a chair alright.'});>>",
																	"<<changeButtonArgsById('skel2', {text: 'Stare at the chair'});>>",
																	"<<changeButtonArgsById('skel3Label', {text: 'It is a nice chair.'});>>",
																	"<<changeButtonArgsById('skel3', {text: 'Stare more at the chair'});>>",
																	"<<changeButtonArgsById('skelNo1', {text: 'Go away from the chair'});>>",
																	"<<changeButtonArgsById('skelNo2', {text: 'Do NOT stare at the chair'});>>",
																]},
															]},
															{text: "Do NOT touch the skeleton", id: "skelNo2", isBack: true},
														]},
														{text: "Go away from the skeleton", id: "skelNo1", isBack: true},
													]},
													{text: "Sub-House of Chess Cheaters", id: "subChessHouse", isLocked: true, lockedTitle: "You haven't won a cheated game of Chess yet bucko buddy", buttons: [
														{label: "Your account has violated the Lichess Terms of Service.", text: "Aw, not again!", isBack: true},
													], onclick: ["<<changeButtonArgsById('subChessHouse', {text: 'Sub-House of Banned Lichess Accounts'});>>"]},
												]},
												{text: "House of No Games", buttons: [
													{text: "Inferential Sub-House of Statistical Inference", id: "subStatsHouse", isLocked: true, lockedTitle: "You haven't completed the Inferential Statistics course in Statistics", buttons: [
														{text: "Talk to the ex-statistician", buttons: [
															{label: "Exastician: \"I can't believe how low science funding is! I couldn't even finish writing the tutorial.\"", text: "I loved your tutorial!", buttons: [
																{label: "Exastician: \"Oh thanks! I did pretty much all of it, surveying all those people was quite the challenge.\"", text: "What do you do now?", buttons: [
																	{label: "Exastician: \"Haven't had time to think about that yet, but I hope to find another job soon.\"", text: "I wish you the best", buttons: [
																		{label: "Exastician: \"Thanks, at this point I'd work in a dungeon if it had enough probability attached to it.\"", text: "Back", isBack: true},
																	]},
																]},
															]},
															{text: "Could you help me save the game?", buttons: [
																{label: "Exastician: \"Oh that's a tricky one! Don't think it would happen by sheer luck.\"", text: "What are the odds?", buttons: [
																	{label: "Exastician: \"Well at first it's like 1 in 8, but you wouldn't know that it's correct.\"", text: "And then?", buttons: [
																		{label: "Exastician: \"Then it's 1 in 7, assuming you know what you're doing.\"", text: "And then then?", buttons: [
																			{label: "Exastician: \"Overall it's 8! which is 40320. But thankfully it's less than that.\"", text: "How is it less?", buttons: [
																				{label: "Exastician: \"Well you don't have to rely on luck! There are plenty of clues around here.\"", text: "Could you tell me a clue?", buttons: [
																					{label: "Exastician: \"Let's just say that the Credits are usually at the end of games.\"", id: "exasticianCredits", text: "Thanks!", isBack: true},
																				]},
																			]},
																		]},
																	]},
																]},
																{text: "Don't tell me the odds", isBack: true},
															]},
														]},
													]},
													{text: "Sub-House of Math(s) Geniuses", id: "subMathsHouse", isLocked: true, lockedTitle: "You haven't input the math(s) code math(s)ly enough", buttons: [
														{text: "Math(s) Genius 1", buttons: [
															{label: "\"I'm just here to make sure we keep up with the glucose quota.\"", text: "Back", isBack: true},
														]},
														{text: "Math(s) Genius 1+1", buttons: [
															{label: "\"I'm here to click things in alphabetical order based on their last words.\"", text: "How is that math(s)?", buttons: [
																{label: "\"Letters are just fancy numbers.\"", text: "Agree to disagree to agree to disagree", isBack: true},
															]},
														]},
														{text: "Math(s) Genius Cubic Root of 3 Cubed", buttons: [
															{label: "\"AAAAAAAAAAAAAAAAAAAAAAAAAA\"", text: "Hi", buttons: [
																{label: "\"I HAVE SOLVED THE SOLUTION\"", text: "Yeah?", id: "maths3", buttons: [
																	{label: "\"I KNOW HOW TO SAVE THE GAME\"", text: "...Wait, really?", buttons: [
																		{label: "\"YES! YOU JUST GO TO THE DESERT AND...\"", text: "And what?", buttons: [
																			{label: "\"...I CAN'T READ MY HANDWRITING\"", text: "Welp.", isBack: true},
																		]},
																	]},
																]},
																{text: "Aren't solutions already solved?", buttons: [
																	{label: "\"THAT'S NOT WHAT I SAID\"", text: "Sorry I just can't read", isBack: true},
																], onclick: ["<<changeButtonArgsById('maths3Label', {text: 'I HAVE SOLVED THE RIDDLEUTION'});>>"]},
															]},
															{text: "Are you okay?", buttons: [
																{label: "\"Yes I'm swell actually.\"", text: "Oh okay", isBack: true},
															]},
															{text: "Bye", isBack: true},
														]},
													]},
												]},
											]},
											{text: "Transcended Neighborhood", id: "transHood", buttons: [
												{text: "House of Unlocked House", id: "unlockedHouse", isLocked: true, lockedTitle: "Unlocked House is Locked", buttons: [
													{label: "Unlocked House - Warning! Keep it locked! Bad puns ahead!", text: "Basic Puns", buttons: [
														{text: "Paying for a ride is pretty taxi", isLabel: true},
														{text: "I feel like I'm just one person but Spanish people call me tu", isLabel: true},
														{text: "Why do people get buried 6 feet deep? I can't fathom", isLabel: true},
														{text: "I want to sit in a green bodysuit to have greener postures", isLabel: true},
														{text: "I'm the master of disguise, you couldn't find anyone better than me", isLabel: true},
														{text: "I'm losing your mind", isLabel: true},
														{text: "Friend-shaped people have buddy parts", isLabel: true},
													]},
													{text: "Definitely Correct Sayings:", buttons: [
														{text: "Breathing is harder said than done", isLabel: true},
														{text: "You couldn't hurt a fly if it hit you", isLabel: true},
														{text: "Setting up for a recipe of disaster failure", isLabel: true},
														{text: "The brain and the mind are connected", isLabel: true},
														{text: "The journey is the journey", isLabel: true},
														{text: "My lungs are very close to my heart", isLabel: true},
													]},
													{text: "Feels Good to Say(ings):", buttons: [
														{text: "Anime's main enemy is an anemone", isLabel: true},
														{text: "Or ingenious orange genus", isLabel: true},
														{text: "It's a basis to basis casis", isLabel: true},
														{text: "It's a bast from the plast", isLabel: true},
														{text: "The rig was gamed from the start", isLabel: true},
														{text: "Retreat is just rit reet", isLabel: true},
														{text: "I presenta this pasta", isLabel: true},
														{text: "We and me both", isLabel: true},
													]},
													{text: "Special Underworld Puns:", buttons: [
														{text: "Hell you can eat buffet", isLabel: true},
														{text: "Pokdémon", isLabel: true},
														{text: "It's Earth on Hell", isLabel: true},
														{text: "Demon-stration", isLabel: true},
														{text: "I'm very up to Earth", isLabel: true},
														{text: "If you stay in hell for long enough, you'll get demon-itized", buttons: [
															{text: "(I independently came up with this joke and then saw it in the game Purrgatory but I swear I didn't steal it)", isLabel: true},
														]},
														{text: "Reward", buttons: [
															{text: "Thank you for sitting through my puns,", isLabel: true},
															{text: "I'll let you know a hint as a reward.", isLabel: true},
															{text: "", isLabel: true},
															{text: "To save the game, you must go to Continent 2", isLabel: true},
															{text: "then go in the order of 58207x891", isLabel: true},
															{text: "and then you can find the end!", isLabel: true},
															{text: "", isLabel: true},
															{text: "PS: I wrote most of these jokes in 2022,", isLabel: true},
															{text: "if you'd like to complain, go back in time.", isLabel: true},
														]},
													]},
												]},
												{text: "House of Locked House", id: "lockedHouse", isLocked: true, lockedTitle: "Locked House is Locked", buttons: [
													{text: "The Huge Locked In-House Door", buttons: [
														{text: "Open The Huge Locked In-House Door", id: "lockedDoor", isLocked: true, buttons: [
															{text: "Very Open Computer", buttons: [
																{text: "Finished Unpublished Game", buttons: [
																	{text: "Publish Button", buttons: [
																		{text: "Game review", isLabel: true},
																		{text: "The first reviews of our newly released game came in!", isLabel: true},
																		{text: "OK", buttons: [
																			{text: "1 - Really bad. ...Galaxy Works", isLabel: true},
																			{text: "10 - Everyone loves it! ...Clueful Gamer", isLabel: true},
																			{text: "4 - Must have! ...Life Villain", isLabel: true},
																			{text: "11 - UFO/RPG is a terrible combination. ...No Games", isLabel: true},
																			{text: "Close", buttons: [
																				{text: "Industry News", isLabel: true},
																				{text: "We just got word that Alien Skyrim has racked up over 0M in sales!", isLabel: true},
																			]},
																		]},
																	]},
																]},
															]},
														]},
														{text: "Door Keeper", buttons: [
															{label: "Door Keeper: \"Lemme guess, you're wondering about this huge locked door...\"", text: "Yes of course", buttons: [
																{label: "Door Keeper: \"There is a way to unlock this huge locked door actually.\"", text: "What?! No...", buttons: [
																	{label: "Door Keeper: \"Yes no! There's a way.\"", text: "Howww", buttons: [
																		{label: "Door Keeper: \"Some say it has to do with the Chartical Options.\"", text: "What about it?", buttons: [
																			{label: "Door Keeper: \"The changeable charts should go up by 10 or something?\"", text: "...What?", buttons: [
																				{label: "Door Keeper: \"Like from top to bottom it should be: 0 10 20 30 40.\"", text: "That's so obscure.", buttons: [
																					{label: "Door Keeper: \Don't shoot the door keeper!\"", text: "Back", isBack: true},
																				]},
																			]},
																		]},
																	]},
																]},
															]},
															{text: "I wonder about something else", buttons: [
																{label: "Door Keeper: \"Oh really? What are you wondering about?\"", text: "This beautiful door keeper <3", buttons: [
																	{label: "(where this went is up to your imagination)", text: "Back", isBack: true},
																]},
																{text: "This huge locked door", buttons: [
																	{label: "Door Keeper: \"I was just about to guess that!\"", text: "Back", isBack: true},
																]},
															]},
														]},
													], onclick: ["<<changeButtonArgsById('lockedDoor', {isLocked: !(charts.engine == 0 && charts.gameplay == 10 && charts.level == 20 && charts.world == 30 && charts.graphic == 40)});>>"]},
												]},
												{text: "House of Uncustomized Gendered People", id: "genderHouse", isLocked: true, lockedTitle: "Everyone else has customized their genders in the Customize menu", buttons: [
													{label: "This house is full of people!", text: "Person 1", buttons: [
														{label: "\"Hi! Welcome to pluralGender's House! You must be gender, right?\"", id: "genderPerson1", text: "How did you know?", buttons: [
															{label: "\"I used my genderdar and the fact that you're in here\"", id: "genderPerson1b", text: "Back", isBack: true},
														]},
														{text: "You know it!", buttons: [
															{label: "\"Awesome, me too! You're welcome here at any time!\"", text: "Back", isBack: true},
														]},
													]},
													{text: "Person 2", buttons: [
														{label: "\"You know what rhymes with gender?\"", id: "genderPerson2", text: "What?", buttons: [
															{label: "\"I was hoping you'd have some ideas, I'm pretty bad at rhymes sadly.\"", text: "Aw that's okay", buttons: [
																{label: "\"I did come up with a straight joke though, would you like to hear it?\"", text: "Sure, go ahead", buttons: [
																	{text: "\"I'm planning to collect some expensive old horror games and wear them on my head.\"", isLabel: true},
																	{text: "\"I was thinking of calling it the Hat Terror ROM Antique\"", isLabel: true},
																]},
															]},
														]},
													]},
													{text: "Nosrep 3", buttons: [
														{label: "\"ebiv redneg ym s'taht ,sdrawkcab sgniht gnitirw ekil I ,olleH\"", id: "genderPerson3", text: "Awesome", buttons: [
															{label: "\"):\"", text: "Is that a :) or :(?", buttons: [
																{label: "\"): yppah s'tI\"", text: "Oh okay :)", isBack: true},
															]},
														]},
														{text: "Emosewa", buttons: [
															{label: "\"lla uoy evah ot ykcul leef I tub ,semitemos rednik saw dlrow eht hsiw I\"", text: "Me too darling", isBack: true},
														]},
													]},
													{text: "Everyone else", buttons: [
														{label: "Everyone's dancing to some music that you happen to like as well", text: "Join the dance", buttons: [
															{label: "You had an amazing time!", text: ":D", isBack: true},
														]},
														{text: "Social anxiety", isBack: true},
													]},
												], onclick: [
													"<<changeButtonArgsById('genderPerson1Label', {text: '\\\"Hi! Welcome to '+pluralGender+'\\'s House! You must be '+gender.toLowerCase()+', right?\\\"'})>>",
													"<<changeButtonArgsById('genderPerson1bLabel', {text: '\\\"I used my '+gender.replaceAll(' ','').toLowerCase()+'dar and the fact that you\\'re in here\\\"'})>>",
													"<<changeButtonArgsById('genderPerson2Label', {text: '\\\"You know what rhymes with '+gender.toLowerCase()+'?\\\"'})>>",
													"<<changeButtonArgsById('genderPerson3Label', {text: '\\\"ebiv '+gender.toLowerCase().split('').reverse().join('')+' ym s\\'taht ,sdrawkcab sgniht gnitirw ekil I ,olleH\\\"'})>>",
												]},
												{text: "House of Fishness", id: "fishHouse", isLocked: true, lockedTitle: "You're way too not fish for House of Fishness", buttons: [
													{text: "Fish Scientist", buttons: [
														{label: "Scientish: \"You are exactly what I'm looking for!\"", text: "I am?", buttons: [
															{label: "Scientish: \"Yes, you must have recently evolved, right? How did you do it?\"", text: "I typed a heart", buttons: [
																{label: "Scientish: \"Ah, the old 52 trick! I see.\"", text: "Then I clicked Fishness", buttons: [
																	{label: "Scientish: \"Yes, of course. And how was your glucose production?\"", text: "Glucose?", buttons: [
																		{label: "Scientish: \"You know, the thing you make with Thylakoids and all.\"", text: "Ah, right.", isBack: true},
																	]},
																	{text: "I went for a plant build", buttons: [
																		{label: "Scientish: \"Ah of course, photosynthesis! If it ain't broke don't fix it.\"", text: "It's such a broken strategy", buttons: [
																			{label: "Scientish: \"It really is, indeed. Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																		{text: "It was difficult though!", buttons: [
																			{label: "Scientish: \"Oh how so? Is there not enough sunlight down there?\"", text: "It's very dark", buttons: [
																				{label: "Scientish: \"Oh I see. Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																			]},
																			{text: "I was fighting for my life!", buttons: [
																				{label: "Scientish: \"Oh wow, I didn't expect that. Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																			]},
																		]},
																	]},
																	{text: "Went all out on Chemosynthesizing Proteins", buttons: [
																		{label: "Scientish: \"Oh really? You found enough Hydrogen Sulfide for that?\"", text: "Yes, I even used Chemoplasts", buttons: [
																			{label: "Scientish: \"That's most interesting! Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																		{text: "Yes, but barely", buttons: [
																			{label: "Scientish: \"I see, I see. Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																	]},
																	{text: "I just manually ate the glucose", buttons: [
																		{label: "Scientish: \"Oh wow! I didn't know there was that much glucose in the oceans.\"", text: "There's a lot", buttons: [
																			{label: "Scientish: \"That's very convenient! Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																		{text: "I ate my fallen siblings", buttons: [
																			{label: "Scientish: \"Oh jeez, nature is brutal. But thanks for your input though, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																	]},
																	{text: "Rusticyanin babyyy", buttons: [
																		{label: "Scientish: \"Oh, so there's a lot of iron down there? Did you also use Ferroplasts?\"", text: "Of course I did", buttons: [
																			{label: "Scientish: \"Very interesting! Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																		{text: "That would've been too much", buttons: [
																			{label: "Scientish: \"Yes, of course. Thank you so much for your input, now this lab can Thrive!\"", text: "No problem!", isBack: true},
																		]},
																	]},
																	{text: "I don't know", isBack: true},
																]},
																{text: "Wait no", isBack: true},
															]},
															{text: "I forgot", isBack: true},
														]},
														{text: "You got the wrong fish", isBack: true},
													]},
													{text: "I fish out", isBack: true},
												]},
											]},
										], onclick: [
											"<<changeButtonArgsById('library', {isLocked: !buttonToggles.simplifiedBooks});>>",
											"<<changeButtonArgsById('subStatsHouse', {isLocked: !buttonToggles.inferentialStats});>>",
											"<<changeButtonArgsById('subTicTacToeHouse', {isLocked: !buttonToggles.wonTicTacToe});>>",
											"<<changeButtonArgsById('subChessHouse', {isLocked: !buttonToggles.wonChess});>>",
											"<<changeButtonArgsById('unlockedHouse', {isLocked: !buttonToggles.unlockLock});>>",
											"<<changeButtonArgsById('lockedHouse', {isLocked: buttonToggles.unlockLock});>>",
											"<<changeButtonArgsById('genderHouse', {isLocked: pluralGender == 'Uncustomized Gendered People'});>>",
											"<<changeButtonArgsById('fishHouse', {isLocked: !buttonToggles.fishness});>>",
										]},
									]},
								]},
								{text: "Continent 2", buttons: [
									{text: "Desert", buttons: [
										{text: "Cool Dunes", buttons: [
											{label: "Click on a part to get the Part Description (really good)", id: "coolPart", text: "Our Glorious Sand", onclick: [
												"<<changeButtonArgsById('coolPartLabel', {text: 'The gloriousest sand in the more stars than sand on Earth. Some rate it 100/{{desertCode > 1 ? desertCode : 1}}'})>>",
												"<<desertCode = (desertCode == 4 || desertCode == 5) ? 5 : 0;>>"
											]},
											{text: "Our Great Cacti", onclick: [
												"<<changeButtonArgsById('coolPartLabel', {text: 'The greatest cactus (plural) in the Desert (singular). Some rate it 100/{{desertCode > 1 ? desertCode : 1}}'})>>",
												"<<desertCode = 1;>>"
											]},
											{text: "Our Noble Wind", onclick: [
												"<<changeButtonArgsById('coolPartLabel', {text: 'The noblest yes blessed windinwinds of dwwds. Some rate it 100/{{desertCode > 1 ? desertCode : 1}}'})>>",
												"<<desertCode = (desertCode == 7 || desertCode == 8) ? 8 : 0;>>",
												"<<if (desertCode == 8){ changeButtonArgsById('extras3', {isLocked: false}); }>>"
											]},
											{text: "Our Heroic Serpent", onclick: [
												"<<changeButtonArgsById('coolPartLabel', {text: 'The heroicest serpent in the landent. Some rate it 100/{{desertCode > 1 ? desertCode : 1}}'})>>",
												"<<desertCode = (desertCode == 5 || desertCode == 6) ? 6 : 0;>>"
											]},
										]},
										{text: "Lame Dunes", buttons: [
											{label: "Click on a part to get the Part Description (really bad)", id: "lamePart", text: "Their Wicked Gravel", onclick: [
												"<<changeButtonArgsById('lamePartLabel', {text: 'The wickedest graver evel. Some rate it {{desertCode > 1 ? desertCode : 1}}/100'})>>",
												"<<desertCode = (desertCode == 1 || desertCode == 2) ? 2 : 0;>>"
											]},
											{text: "Their Primitive Prick", onclick: [
												"<<changeButtonArgsById('lamePartLabel', {text: 'The primitivest prickest everest. Some rate it {{desertCode > 1 ? desertCode : 1}}/100'})>>",
												"<<desertCode = (desertCode == 3 || desertCode == 4) ? 4 : 0;>>"
											]},
											{text: "Their Backward Gust", onclick: [
												"<<changeButtonArgsById('lamePartLabel', {text: 'The backwardest gust with tsugsid. Some rate it {{desertCode > 1 ? desertCode : 1}}/100'})>>",
												"<<desertCode = (desertCode == 2 || desertCode == 3) ? 3 : 0;>>"
											]},
											{text: "Their Brutish Snake", onclick: [
												"<<changeButtonArgsById('lamePartLabel', {text: 'The brutishest snake of fake Earth. Some rate it {{desertCode > 1 ? desertCode : 1}}/100'})>>",
												"<<desertCode = (desertCode == 6 || desertCode == 7) ? 7 : 0;>>"
											]},
										]},
									]},
									{text: "Lake", buttons: [
										{text: "Lava Lake", buttons: [
											{text: "Lava Fish 1", buttons: [
												{label: "I'm so glad you're here instead of in \"Lava 2+2 2\"", text: "You know me!", buttons: [
													{label: "Although they say that the number you see there is important.", text: "How so?", buttons: [
														{label: "It's like a code or something?", text: "Back", isBack: true},
													]},
												]},
											]},
											{text: "Lava 2+2 2", buttons: [
												{text: "52", buttons: [
													{text: "52 is a heart in case you don't see it", buttons: [
														{text: "Now you're in a lava fish's heart", buttons: [
															{text: "You're filled with 26 times 2 energy", isBack: true},
														]},
													]},
												]},
											]},
										]},
										{text: "Water Lake", isLocked: true, lockedTitle: "The Adventures of FF Island hasn't been beaten yet canonically"},
									]},
								]},
							]},
							{value: "Earth Back", text: "Back", buttons: [
								{value: "Solar System", onclickGameState: "Earth Back Extras"},
								{value: "Earth Back 1", text: "Back", buttons: [
									{value: "Galaxy", onclickGameState: "Earth Back"},
									{value: "Earth Back 2", text: "Back", buttons: [
										{value: "Local Group of Galaxies", onclickGameState: "Earth Back 1"},
										{value: "Earth Back 3", text: "Back", buttons: [
											{value: "Local Supercluster", onclickGameState: "Earth Back 2"},
											{value: "Earth Back 4", text: "Back", buttons: [
												{value: "Observable Universe", onclickGameState: "Earth Back 3"},
												{value: "Earth Back 5", text: "Back", buttons: [
													{value: "Universe", onclickGameState: "Earth Back 4"},
													{value: "I don't want to zoom further", onclickGameState: "menu"},
												]},
												{value: "Observable Universe 3", id: "observableUniverse3", isLocked: true, hideLocked: true, buttons: [
													{text: "Local Supercluster 3", buttons: [
														{text: "Local Group of Galaxies 3", buttons: [
															{text: "Galaxy 3", buttons: [
																{text: "Solar System 3", buttons: [
																	{text: "Earth 3", buttons: [
																		{text: "Continent 3", buttons: [
																			{text: "Country 3", buttons: [
																				{text: "(secret other library)", buttons: [
																					{text: "Read Book 3", buttons: [
																						{text: "Extras III Recipe:", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "Step I:", isLabel: true},
																						{text: "Click the parts of the ---rt in -------tical order.", isLabel: true},
																						{text: "(last words: CAgrguprSASEsnWI)", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "Step II:", isLabel: true},
																						{text: "Check the Credits.", id: "book3credits", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "Step III:", isLabel: true},
																						{text: "", isLabel: true},
																						{text: "[Return the book]", isBack: true},
																					]},
																				]},
																			]},
																		]},
																	]},
																]},
															]},
														]},
													]},
												]},
											]},
										]},
									]},
								]},
							]},
						]},
						{value: "Extras IV", onclick: ["<<inputtedCode = '';>>"], buttons: [
							{value: "0", label: "Code: {{inputtedCode}}", onclick: ["<<inputtedCode += '0';>>"]}, {value: "1", onclick: ["<<inputtedCode += '1';>>"]},
							{value: "2", onclick: ["<<inputtedCode += '2';>>"]}, {value: "3", onclick: ["<<inputtedCode += '3';>>"]},
							{value: "4", onclick: ["<<inputtedCode += '4';>>"]}, {value: "5", onclick: ["<<inputtedCode += '5';>>"]},
							{value: "6", onclick: ["<<inputtedCode += '6';>>"]}, {value: "7", onclick: ["<<inputtedCode += '7';>>"]},
							{value: "8", onclick: ["<<inputtedCode += '8';>>"]}, {value: "9", onclick: ["<<inputtedCode += '9';>>"]},
							{value: "Confirm", onclick: [
								"<<changeButtonArgsById('extras4ConfirmLabel', {text: 'Wrong code :c'});>>",
								"<<changeButtonArgsById('extras4Confirm', {text: 'Aw.'});>>",
								`<<
									if (inputtedCode == '2'){
										changeButtonArgsById('country2', {text: 'Enter Country 2', isLocked: false});
										changeButtonArgsById('country2Label', {text: 'You can now enter Country 2'});
										changeButtonArgsById('extras4ConfirmLabel', {text: 'Access granted for Country 2!'});
										changeButtonArgsById('extras4Confirm', {text: 'Aw, nice!'});
									}
								>>`,
								`<<
									if (inputtedCode == '52'){
										buttonToggles.fishEvolve = true;
										changeButtonArgsById('extras4ConfirmLabel', {text: 'You can now evolve into Fish!'});
										changeButtonArgsById('extras4Confirm', {text: 'Aw, fish! (positive)'});
									}
								>>`,
								`<<
									if (inputtedCode == '117847'){
										changeButtonArgsById('subMathsHouse', {isLocked: false});
										changeButtonArgsById('extras4ConfirmLabel', {text: 'You can now enter that one math(s) house in Country 2!'});
										changeButtonArgsById('extras4Confirm', {text: 'Aw, mathematical! (youth speak of 3025)'});
									}
								>>`,
								`<<
									if (inputtedCode == '46656'){
										changeButtonArgsById('extras4ConfirmLabel', {text: "NOTHING HAPPENS (cuz im evil) hahaha /evil. Also there's no Extras I"});
										changeButtonArgsById('extras4Confirm', {text: 'Aw?'});
									}
								>>`,
								`<<
									if (inputtedCode == '51862437'){
										changeButtonArgsById('extras4ConfirmLabel', {text: "Wrong code, or at least the wrong place for the code, also it's 5186 2437"});
										changeButtonArgsById('extras4Confirm', {text: 'I am so confused'});
									}
								>>`,
								"<<inputtedCode = '';>>",
							], buttons: [
								{label: "You shouldn't see this text.", text: "Got it.", id: "extras4Confirm", isBack: true},
							]},
						]},
						{value: "Customize", buttons: [
							{value: "Extras V", buttons: [
								{label: "There's no Extras V", value: "Thanks", isBack: true}
							]},
							{value: "Gender Customization", buttons: [
								{label: "Which option is the closest to your gender identity?", value: "Feminine", onclick: ["<<gender = 'Feminine';>>"]},
								{value: "Masculine", onclick: ["<<gender = 'Masculine';>>"]},
								{value: "Non-Binary", onclick: ["<<gender = 'Non-Binary';>>"]},
								{value: "Androgynous", onclick: ["<<gender = 'Androgynous';>>"]},
								{value: "Genderfluid", onclick: ["<<gender = 'Genderfluid';>>"]},
								{value: "Bigender", onclick: ["<<gender = 'Bigender';>>"]},
								{value: "Agender", onclick: ["<<gender = 'Agender';>>"]},
								{value: "Demigirl", onclick: ["<<gender = 'Demigirl';>>"]},
								{value: "Demiboy", onclick: ["<<gender = 'Demiboy';>>"]},
								{value: "Xenogender", onclick: ["<<gender = 'Xenogender';>>"]},
								{value: "[Custom]", onclick: ["<<gender = prompt('Please input your gender:');>>"]},
								{value: "Gender Customization Confirm", text: "--> CONFIRM <--",
								onclick: [
									"<<changeButtonArgsById('PluralOption1', {text: gender + ' People', onclick: ['<<pluralGender = \"' + gender + ' People\";>>']})>>",
									"<<changeButtonArgsById('PluralOption2', {text: gender + 's', onclick: ['<<pluralGender = \"' + gender + 's\";>>']})>>",
									"<<changeButtonArgsById('PluralOption3', {text: gender + 'ies', onclick: ['<<pluralGender = \"' + gender + 'ies\";>>']})>>",
									"<<changeButtonArgsById('PluralOption4', {text: gender + 'ers', onclick: ['<<pluralGender = \"' + gender + 'ers\";>>']})>>",
									"<<changeButtonArgsById('PluralOption5', {text: gender + 'ed People', onclick: ['<<pluralGender = \"' + gender + 'ed People\";>>']})>>",
									"<<changeButtonArgsById('PluralOption6', {text: gender + 'ing People', onclick: ['<<pluralGender = \"' + gender + 'ing People\";>>']})>>",
								], buttons: [
									{label: "What's the plural version?", value: "PluralOption1", id: "PluralOption1"},
									{value: "PluralOption2", id: "PluralOption2"},
									{value: "PluralOption3", id: "PluralOption3"},
									{value: "PluralOption4", id: "PluralOption4"},
									{value: "PluralOption5", id: "PluralOption5"},
									{value: "PluralOption6", id: "PluralOption6"},
									{value: "[Custom]", onclick: ["<<pluralGender = prompt('Please input the plural version of your gender:');>>"]},
									{value: "Gender Customization Plural Confirm", text: "--> CONFIRM <--", onclick: [
										"<<changeButtonArgsById('GenderDoneLabel', {text: 'Gender: ' + gender + ', Plural: ' + pluralGender + ', for more info visit Country 2'})>>",
									], buttons: [
										{label: "Gender: Plural: , for more info visit Country 2", value: "Alright!", id: "GenderDone", isFullyBack: true, onclick: [
										"<<changeButtonArgsById('genderHouse', {text: 'House of ' + pluralGender})>>"]},
									]}
								]},
							]},
							{value: "Mod Options", buttons: [
								{label: "The modding community is currently asleep", value: "Back", isBack: true},
							]},
						]},
						{value: "Credits", id: "creditsId", buttons: [
							{label: "Every button was made by Sover the Button Maker", value: "Take credit for it yourself", id: "credits", onclick: ["<<changeButtonArgsById('creditsLabel', {text: 'You made this'});>>", "<<buttonToggles.tookCredit = true;>>"]},
							{value: "Special Thanks", buttons: [
								{label: "", value: "Back", outlineSize: 0, isBack: true},
							]},
							{value: "Back", isBack: true},
							{value: "Credits Options", id: "creditsOptions", isLocked: true, hideLocked: true, buttons: [
								{label: "Would you like Credits to be backwards?", text: "Yes", onclick: [
									"<<changeButtonArgsById('creditsId', {text: 'stiderC'})>>",
									"<<changeButtonArgsById('book3credits', {text: 'Check the stiderC.'})>>",
									"<<changeButtonArgsById('creditsToggleId', {text: 'Unlock stiderC Options'})>>",
									"<<changeButtonArgsById('exasticianCreditsLabel', {text: 'Exastician: \"Let\\'s just say that the stiderC are usually at the end of games.\"'})>>",
								], buttons: [
									{label: "Done. What was the point of this again?", text: "I dunno", isFullyBack: true},
								]},
								{text: "Leave it the way it is", isBack: true},
							]},
							{value: "nothing1", isHidden: true},
							{value: "nothing2", isHidden: true},
							{value: "Extras III", id: "extras3", isLocked: true, hideLocked: true, buttons: [
								{value: "Send Feedback", buttons: [
									{label: "To" + "do: Add Send Feedback Field", value: "Complain about the lack of send feedback field", buttons: [
										{label: "Thank you for your feedback!", value: "Back", isBack: true},
									]},
								]},
								{value: "Quick Save", buttons: [
									{text: "You win!", isLabel: true},
									{text: "You managed to save the game!", isLabel: true},
									{text: "Now you don't have to worry about the whole power thing!", isLabel: true},
									{text: "Awesome!", isLabel: true},
									{text: "", isLabel: true},
									{text: "", isLabel: true},
									{text: "Though it seems like you've forgotten about the whole game by now", isLabel: true},
									{text: "and you can only remember all the buttons from the Pause Menu...", isLabel: true},
									{text: "", isLabel: true},
									{text: "It's probably better this way anyways...", isLabel: true},
									{text: "", isLabel: true},
									{text: "Extras VI", buttons: [
										{text: "Some of the games referenced:", isLabel: true},
										{text: "", isLabel: true},
										{text: "Inspiration for Extras II:", isLabel: true},
										{text: "Nested (by Orteil)", isLabel: true},
										{text: "", isLabel: true},
										{text: "Back House Voice Recordings:", isLabel: true},
										{text: "Type Help (by William Rous)", isLabel: true},
										{text: "", isLabel: true},
										{text: "Chartical Options Slices:", isLabel: true},
										{text: "Game Dev Tycoon (by Greenheart Games)", isLabel: true},
										{text: "", isLabel: true},
										{text: "A LOT of the Menu Buttons:", isLabel: true},
										{text: "Crypt of the Necrodancer (by Brace Yourself Games)", isLabel: true},
										{text: "Extras VII", buttons: [
											{text: "Thank you so much for playing!", isLabel: true},
											{text: "", isLabel: true},
											{text: "Click the " + defaultValues.channelIconPiece + " button to exit the game.", isLabel: true},
										]}
									]},
								], onclick: ["<<saveCurrentGameScore(buttonClicks + 1)>>", "<<buttonClicks = -Infinity;>>"]},
							]},
						]},
						{value: "Legal Notice", buttons: [
							{label: "To" + "do: Add Legal Notice", value: "Complain about the lack of legal notice", buttons: [
								{label: "To" + "do: Add Lack of Legal Notice Complaint Field", value: "Complain about the abundance of lack of legal notice complaint field", buttons: [
									{label: "To" + "do: Add More Complaint Buttons", value: "Back", isFullyBack: true},
								]},
							]},
						]},
						
						{value: "Start", isLocked: true, isHidden: true, buttons: [
							{text: "", isLabel: true, isFullyBack: true},
							{text: "Oh no!", isLabel: true, isFullyBack: true},
							{text: "You got really far in this game,", isLabel: true, isFullyBack: true},
							{text: "but you haven't saved in a long time!", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "Quick, press the Pause Menu button and save your progress", isLabel: true, isFullyBack: true},
							{text: "before your upcoming power outage!", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "(it might take a few tries)", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "Pause Menu", onclick: ["<<buttonClicks = 0;>>", "resetVariables"], isFullyBack: true},
						]},
						{value: "Fail", isLocked: true, isHidden: true, buttons: [
							{text: "", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "Noooooo!!!!", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "Yer power went out before you could save the game :c", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "Would you like to try again?", isLabel: true, isFullyBack: true},
							{text: "", isLabel: true, isFullyBack: true},
							{text: "[Roll back time]", onclick: ["<<buttonClicks = 0;>>", "resetVariables"], isFullyBack: true},
						]},
					],
					buttonArgs: {
						pos: {x: 0, y: -0.425, w: 0.5, h: 0.06, margin: {h: 0.07}},
						onclick: "<<buttonClicks++;>>", downscaleTextLength: 17, textHoverOverlay: true,
						toggleArrName: "buttonToggles", toggleTexts: {true: ": On", false: ": Off"},
						textSize: 0.1, outlineSize: 0.00015, lockedTitleSize: 0.00575
					},
					labelArgs: {
						color: "#00000000", disableClick: true, downscaleTextLength: 50
					},
					args: {
						initialState: "menu",
						backButton: {value: "Back", onclickGameState: "Back", excludedStates: ["menu", "Tic Tac Toe", "Earth Back", "Chess (new)", "Gender Customization", "Quick Save"]}
					}
				},
			},
			modifiedVariables: {
				camera: {zoom: {level: 0.5}, areDimentionsEqual: true, ...gamePresets["lockedCamera"]},
				
				colors: {
					powerOutageText: "#ffffff",
					backgroundColor: {
						pos: {start: {x: 0, y: 0}, end: {x: 1, y: 1}},
						colorStops: [['0', '#3070c8'], ['0.85', '#d2548a']]
					},
					defaultButtonLocked: "#48484866",
				},
				
				gameState: {currentState: "Start", states: ["menu"]},
			},
			data: {
				description: "Navigate your way through extremely complicated menus to save the game!\nOne of my most fun games for people who like some silly jokes :>",
				releaseDate: "Early 2025",
				tags: ["puzzle", "silly jokes", "button game"],
				/*videos: [
					{name: "Showcase/Walkthrough Video"},
					{name: '\\"How It Was Made\\" Video'},
				]*/
			},
		},
		"Countries Quiz": {
			overriddenVariables: {
				drawOrder: ["drawEntities", "drawGrids", "drawButtons", "drawScrollbars"],
				
				events: {
					onload: ["generateGrids", "saveCountryColors", "generateMenuButtons"],
					onNextFrame: ["countryClick", "draw"],
					
					saveCountryColors: [
						"<<for (let i in earthEntity.color){ savedCountryColors[i] = earthEntity.color[i]; }>>"
					],
					refreshActiveCountries: [
						"<<activeCountries = [...activeCountriesArr[getIndexOfInventoryValue({arrName: 'activeCountriesArr', value: currentChallenge})].countries];>>"
					],
					resetCountryColors: [
						"<<for (let i in savedCountryColors){ getEntityById(i).color = savedCountryColors[i]; }>>"
					],
					removeCountryColors: [
						"<<for (let i in savedCountryColors){ getEntityById(i).color = colors.genderfluid[3]; }>>"
					],
					resetCountryColorsForActiveCountries: [
						"removeCountryColors",
						"<<for (let i of activeCountries){ getEntityById(i).color = savedCountryColors[i]; }>>",
						"<<score = {correct: 0, wrong: 0, firstTry: 0};>>"
					],
					
					setStartingCountry: [
						"<<currentCountry = getRandomElementOfArray(activeCountries);>>",
						"<<wrongCountry = '';>>"
					],
					
					resetCameraPosition: [
						"<<continentNum = getIndexOfInventoryValue({arrName: 'continentTeleports', value: currentChallenge});>>",
						"<<camera = {...camera, ...((continentTeleports[continentNum] ?? {}).pos ?? extraTeleports[currentChallenge] ?? extraTeleports['Every Country'])};>>",
						"<<camera.zoom.level = ((continentTeleports[continentNum] ?? {}).pos ?? extraTeleports[currentChallenge] ?? extraTeleports['Every Country']).zoomLevel;>>",
					],
					
					refreshChallenge: ["refreshActiveCountries", "resetCameraPosition", "resetCountryButtons", "resetCountryColorsForActiveCountries", "setStartingCountry"],
					
					
					quitToMenu: [
						"<<gameState.currentState = 'menu';>>",
						"refreshActiveCountries",
						"resetCountryColorsForActiveCountries",
						"<<camera.x = 0;>>",
						"<<camera.y = 0;>>",
						"<<camera.zoom.level = 0.5;>>",
					],
					
					
					resetCountryButtons: [
						`<<buttons.game = [
							{pos: {x: 0.15, y: 0.85, w: 0.15, h: 0.15}, text: "Back", textSize: 0.3, color: "#ffffff44", id: "backButton", isHidden: true, isAbsolutePositioned: true, onclick: "backTeleportClick"},
						]>>`,
						`<<for (let i of activeCountries){
							if (earthCountriesCenter[i] != undefined){
								buttons.game.push({pos: {x: earthCountriesCenter[i].x, y: earthCountriesCenter[i].y, w: 0.005, h: 0.005}, id: i,
								text: "", textSize: 0.3, color: "#00000000", hoverColor: "#ffffff00",
								borderSize: 0.0005, borderColor: savedCountryColors[i],
								onclick: ['<<clickedPolygons[0] = {i: "' + i + '", layer: "0", isDown: false};>>', 'countryClick']});
							}
						}>>`,
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0.21, y: 0.1, w: 0.35, h: 0.075}, isAbsolutePositioned: true,
							text: "{{'Click: ' + ((currentCountry != undefined) ? ((currentChallenge != 'Every Country (facts only)') ? currentCountry : 'Check Fact ->') : 'Done! :>')}}", downscaleTextLength: 30, id: "currentCountry",
							textSize: 0.2/3.5, outlineSize: 0.0025, disableClick: true,
							textColor: colors.white, outlineColor: colors.black, color: "#00000028"
						}},
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0.21, y: 0.175, w: 0.35, h: 0.075}, isAbsolutePositioned: true,
							text: "{{(currentChallenge == 'Tutorial') ? '' : (getNumWithTruncatedDecimals(score.correct / Math.max(score.correct + score.wrong, 1) * 100, 2) + '% (correct: ' + score.correct + ', wrong: ' + score.wrong + ')')}}",
							textSize: 0.175/3.5, outlineSize: 0.0025, disableClick: true,
							textColor: colors.white, outlineColor: colors.black, color: "#00000000"
						}},
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0.21, y: 0.25, w: 0.35, h: 0.075}, isAbsolutePositioned: true,
							text: "{{(wrongCountry != '') ? ('(Clicked: ' + wrongCountry + ')') : ((currentChallenge == 'Tutorial') ? '(wrong guesses appear here and its name above will be colored like the country)' : '')}}",
							textSize: 0.175/3.5, outlineSize: 0.0025, disableClick: true, downscaleTextLength: 42,
							textColor: colors.white, outlineColor: colors.black, color: "#00000000"
						}},
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0.7, y: 0.1, w: 0.6, h: 0.033}, isAbsolutePositioned: true,
							text: "{{(challengeNotes[currentChallenge] ?? {})[(((challengeNotes[currentChallenge] ?? {}).All != undefined) ? 'All' : currentCountry)] ?? earthCountriesNotes[currentCountry] ?? ''}}", downscaleTextLength: 113,
							textSize: 0.0155, outlineSize: 0.00155, disableClick: true,
							textColor: colors.white, outlineColor: colors.black, color: "#00000028"
						}},
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0, y: 0.325, w: 0.2, h: 0.06}, isAbsolutePositioned: false,
							text: "{{(currentChallenge == 'Tutorial') ? 'You can click these to zoom into a continent:' : ''}}",
							textSize: 0.1, outlineSize: 0, disableClick: true, textColor: colors.white, color: "#00000000"
						}},
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0.9645, y: 0.0365, w: 0.04, h: 0.03}, isAbsolutePositioned: true,
							text: "Quit", textSize: 0.3, color: "#ffffffAA", onclick: "quitToMenu"
						}},
						"<<if (camera.zoom.level == 0.5){ runEvent('generateTeleportButtons'); }>>",
					],
					
					
					generateTeleportButtons: [{
						f: "generateButtons", args: {arrName: "continentTeleports", gameState: "game",
						button: {text: "{{value}}", textSize: 0.15, downscaleTextLength: 11,
						subtextPos: {x: 0.325}, textColor: "#000000", outlineColor: "#000000", id: "teleportButton",
						onclick: {event: "teleportClick", args: "{arrName: 'continentTeleports', value: '{{value}}', buttonValue: '{{value}}', index: {{index}}, buttonIndex: {{index}}}"}},
						pos: {x: 0.5, y: 0.4, w: 0.2, h: 0.06, margin: {w: 0.05, h: 0.01}}, grid: {w: 10}, isCentered: true}
					}],
					
					generateMenuButtons: [{
						f: "generateButtons", args: {arrName: "activeCountriesArr", gameState: "menu",
						button: {text: "{{value}}", textColor: "#FFFFFF", color: "#000000AA", borderColor: "menuBorder", borderSize: 0.002, textSize: 0.15, downscaleTextLength: 11,
						onclick: [
							{f: "runEval", extraArgs: {text: "currentChallenge = '{{value}}'"}},
							"refreshActiveCountries",
							"resetCountryColorsForActiveCountries",
						]},
						pos: {x: 0, y: -0.325, w: 0.3, h: 0.1, margin: {w: 0.05, h: 0.01}}, grid: {w: 4}, isCentered: true}
					}],
					
					
					countryClick: [
						`<<
						if ((clickedPolygons[0]??{}).isDown == false){
							let name = clickedPolygons[0].i;
							
							if (activeCountries.includes(name)){
								if (name == currentCountry){
									score.correct++;
									
									if (wrongCountry == ""){
										score.firstTry++;
									}
									
									getEntityById(name).color = colors.genderfluid[3];
									removeValueFromArray({arrName: "activeCountries", value: name});
									
									removeButtonsById(name);
									
									currentCountry = getRandomElementOfArray(activeCountries);
									wrongCountry = "";
									
									changeButtonArgsById("currentCountry", {outlineColor: colors.black, textColor: colors.white});
									
									if (currentCountry == undefined){
										saveCurrentGameScore(score.firstTry);
										
										gameState.currentState = "postGame";
									}
								} else{
									score.wrong++;
									wrongCountry = name;
									
									changeButtonArgsById("currentCountry", {outlineColor: savedCountryColors[currentCountry], textColor: colors.black});
								}
								
								clickedPolygons = [];
							}
						}
						>>`
					],
					
					teleportClick: [
						"<<cancelNextDrawFrame = true;>>",
						"<<camera.x = continentTeleports[args.buttonIndex].pos.x;>>",
						"<<camera.y = continentTeleports[args.buttonIndex].pos.y;>>",
						"<<camera.zoom.level = continentTeleports[args.buttonIndex].pos.zoomLevel;>>",
						"<<changeButtonArgsById('backButton', {isHidden: false})>>",
						"<<changeButtonArgsById('teleportButton', {isHidden: true})>>",
					],
					backTeleportClick: [
						"<<cancelNextDrawFrame = true;>>",
						"<<camera.x = 0;>>",
						"<<camera.y = 0;>>",
						"<<camera.zoom.level = 0.5;>>",
						"<<changeButtonArgsById('backButton', {isHidden: true})>>",
						"<<changeButtonArgsById('teleportButton', {isHidden: false})>>",
					],
					
				},
				
				shouldClickPolygons: true,
				
				buttons: {
					game: [],
					menu: [
						{pos: {x: 0, y: 0.39, w: 0.25, h: 0.085}, text: "Start", textSize: 0.225, color: "#FFFFFFF0", borderColor: "#000000", borderSize: 0.0025, onclick: [
							{f: "runEval", extraArgs: {text: "gameState.currentState = 'game'"}},
							"refreshChallenge"
						]},
						{pos: {x: 0.9645, y: 0.0365, w: 0.04, h: 0.03}, isAbsolutePositioned: true,
							text: "Quit", textSize: 0.3, color: "#ffffffAA", onclick: [{f: "loadGame", args: {gameName: "Game Selection"}}]
						},
					],
					postGame: [
						{pos: {x: 0.5, y: 0.77, w: 0.125, h: 0.075}, text: "Retry", textSize: 0.225, color: "#FFFFFFF0", isAbsolutePositioned: true,
						borderColor: "#000000", borderSize: 0.0025, onclick: [
							"quitToMenu",
							{f: "runEval", extraArgs: {text: "gameState.currentState = 'game'"}},
							"refreshChallenge"
						]},
						{pos: {x: 0.5, y: 0.89, w: 0.125, h: 0.075}, text: "Menu", textSize: 0.225, color: "#FFFFFFF0", isAbsolutePositioned: true,
						borderColor: "#000000", borderSize: 0.0025, onclick: "quitToMenu"},
						
						{pos: {x: 0.5, y: 0.5, w: 0.5, h: 0.3}, isAbsolutePositioned: true,
							text: "{{(currentChallenge == 'Tutorial') ? postTutorialText : 'Done! :>\\n\\nScore:\\n' + (getNumWithTruncatedDecimals(score.correct / Math.max(score.correct + score.wrong, 1) * 100, 2) + '% (correct: ' + score.correct + ', wrong: ' + score.wrong + ')') + '\\n(correct on first try: ' + score.firstTry + ')\\n'}}",
							textSize: 0.175/3.5, outlineSize: 0.0025, downscaleTextLength: 35, disableClick: true,
							textColor: colors.white, outlineColor: colors.black, color: "#00000000"
						},
						
						{pos: {x: 0.5, y: 0.985, w: 0.1, h: 0.1}, text: "thank you", textSize: 0.03, isAbsolutePositioned: true,
						textColor: "#222222", outlineSize: 0, ...gamePresets.textButton},
					]
				},
				entities: [
					...earthEntities,
				]
			},
			createdVariables: {
				savedCountryColors: {},
				
				continentNum: -1,
				currentChallenge: "Every Country",
				activeCountries: [],
				
				disabledCountries: {},
				currentCountry: "",
				wrongCountry: "",
				
				score: {correct: 0, wrong: 0, firstTry: 0},
				
				postTutorialText: "Done! :>\nYou might not get some countries on your first try,\n free to try again until you get all of them!\nYou can also go back to the menu.",
				
				activeCountriesArr: [
					{value: "Tutorial", countries: ["United States", "China", "Brazil", "Russia", "Nigeria", "India", "Australia"]},
					{value: "G20 Countries", countries: ["Argentina", "Australia", "Brazil", "Canada", "China", "France", "Germany", "India", "Indonesia", "Italy", "Japan", "Mexico", "Russia", "Saudi Arabia", "South Africa", "South Korea", "Turkey", "United Kingdom", "United States"]},
					{value: "30 Biggest Countries by Population", countries: earthCountriesOrderOfPopulation.slice(0,30)},
					{value: "10 Biggest European Countries", countries: ["Russia", "Ukraine", "France", "Spain", "Sweden", "Germany", "Finland", "Norway", "Poland", "Italy"]},
					{value: "Balkan Countries", countries: ["Slovenia", "Croatia", "Bosnia and Herzegovina", "Montenegro", "Albania", "Greece", "Serbia", "Kosovo", "North Macedonia", "Romania", "Bulgaria", "Turkey", "Moldova"]},
					{value: "Europe", countries: earthContinents["Europe"]},
					{value: "The Caribbean", countries: ["Cuba", "Jamaica", "Haiti", "Dominican Republic", "The Bahamas", "Dominica", "Trinidad and Tobago", "Saint Lucia", "Saint Vincent and the Grenadines", "Grenada", "Barbados", "Antigua and Barbuda", "Saint Kitts and Nevis"]},
					{value: "North America", countries: earthContinents["North America"]},
					{value: "Spanish-Speaking Countries", countries: ["Mexico", "Guatemala", "United States", "Honduras", "El Salvador", "Nicaragua", "Costa Rica", "Panama", "Cuba", "Dominican Republic", "Colombia", "Ecuador", "Peru", "Chile", "Argentina", "Bolivia", "Paraguay", "Uruguay", "Venezuela", "Spain", "Equatorial Guinea"]},
					{value: "South America", countries: [...earthContinents["South America"], "France"]},
					{value: "Asia", countries: earthContinents["Asia"]},
					{value: "Northern Africa", countries: ["Western Sahara", "Mauritania", "Libya", "Tunisia", "Morocco", "Egypt", "Algeria"]},
					{value: "Southern Africa", countries: ["Malawi", "Eswatini", "Lesotho", "South Africa", "Zambia", "Zimbabwe", "Namibia", "Mozambique", "Botswana", "Angola"]},
					{value: "Eastern Africa", countries: ["Comoros", "Mauritius", "Seychelles", "Rwanda", "Uganda", "Kenya", "South Sudan", "Sudan", "Ethiopia", "Eritrea", "Somalia", "Tanzania", "Djibouti", "Madagascar"]},
					{value: "Western Africa", countries: ["Benin", "Burkina Faso", "Côte d'Ivoire", "Guinea-Bissau", "Guinea", "Sierra Leone", "Liberia", "Ghana", "Togo", "Cape Verde", "Nigeria", "Niger", "Mali", "The Gambia", "Senegal"]},
					{value: "Central Africa", countries: ["São Tomé and Príncipe", "Burundi", "Cameroon", "Gabon", "Republic of the Congo", "Central African Republic", "Equatorial Guinea", "Democratic Republic of Congo", "Chad"]},
					{value: "Africa", countries: earthContinents["Africa"]},
					{value: "Commonwealth States", countries: ["United Kingdom", "South Africa", "New Zealand", "Canada", "Australia", "Pakistan", "India", "Sri Lanka", "Ghana", "Malaysia", "Nigeria", "Cyprus", "Sierra Leone", "Tanzania", "Jamaica", "Trinidad and Tobago", "Uganda", "Kenya", "Malawi", "Malta", "Zambia", "The Gambia", "Singapore", "Guyana", "Botswana", "Lesotho", "Barbados", "Mauritius", "Eswatini", "Nauru", "Tonga", "Samoa", "Fiji", "Bangladesh", "The Bahamas", "Grenada", "Papua New Guinea", "Seychelles", "Solomon Islands", "Tuvalu", "Dominica", "Saint Lucia", "Kiribati", "Saint Vincent and the Grenadines", "Vanuatu", "Belize", "Antigua and Barbuda", "Maldives", "Saint Kitts and Nevis", "Brunei", "Namibia", "Cameroon", "Mozambique", "Rwanda", "Togo", "Gabon"]},
					{value: "100 Biggest Countries by Population", countries: earthCountriesOrderOfPopulation.slice(0,100)},
					{value: "Oceania", countries: earthContinents["Oceania"]},
					{value: "Small Countries", countries: earthSmallCountries},
					{value: "100 Smallest Countries by Population", countries: earthCountriesOrderOfPopulation.slice(97,198)},
					{value: "Every Country", countries: [...earthContinents["North America"], ...earthContinents["South America"], ...earthContinents.Europe, ...earthContinents.Africa, ...earthContinents.Asia, ...earthContinents.Oceania]},
					{value: "Every Country (facts only)", countries: [...earthContinents["North America"], ...earthContinents["South America"], ...earthContinents.Europe, ...earthContinents.Africa, ...earthContinents.Asia, ...earthContinents.Oceania]},
				],
				
				continentTeleports: [
					{value: "North America", pos: {x: 0.5043411854926669, y: 0.1658733401713646, zoomLevel: 1.5537469619750979}},
					{value: "South America", pos: {x: 0.39072288450270853, y: -0.15723033386014287, zoomLevel: 1.1337469619750975}},
					{value: "Europe", pos: {x: 0.001378732421038559, y: 0.28797583909289637, zoomLevel: 2.073746961975098}},
					{value: "Africa", pos: {x: -0.03609923088237635, y: -0.01600783135961315, zoomLevel: 1.0737469619750972}},
					{value: "Asia", pos: {x: -0.4713185414856007, y: 0.1391087398199801, zoomLevel: 1.0737469619750972}},
					{value: "Oceania", pos: {x: -0.7710573132698738, y: -0.12417127345614659, zoomLevel: 1.1337469619750973}},
				],
				extraTeleports: {
					"Every Country": {x: 0, y: 0, zoomLevel: 0.5},
					"10 Biggest European Countries": {x: 0.001378732421038559, y: 0.28797583909289637, zoomLevel: 2.073746961975098},
					"Balkan Countries": {x: -0.07252729297197495, y: 0.24166325696500232, zoomLevel: 4.319999999999997},
					"The Caribbean": {x: 0.4834926976374426, y: 0.09993207351613666, zoomLevel: 2.853746961975099},
					"Spanish-Speaking Countries": {x: 0.2600639809850334, y: -0.038727078727078694, zoomLevel: 0.7600000000000002},
					"Northern Africa": {x: 0.02373270873177125, y: 0.14828693979868568, zoomLevel: 2.173746961975098},
					"Southern Africa": {x: -0.0766916558383424, y: -0.13706543268957383, zoomLevel: 1.973746961975098},
					"Eastern Africa": {x: -0.16845188018642146, y: -0.0351615249057599, zoomLevel: 1.5137469619750976},
					"Western Africa": {x: 0.07379206091525109, y: 0.07879342370745435, zoomLevel: 2.013746961975098},
					"Central Africa": {x: -0.04607281908450597, y: 0.012903887756674491, zoomLevel: 1.973746961975098},
				},
				
				challengeNotes: {
					"Spanish-Speaking Countries": {
						"United States": "Counts as Spanish-speaking due to Puerto Rico.",
						"Spain": "The only Spanish-speaking country in Europe. :)",
					},
					"South America": {
						"France": "French Guiana is a region of France located in South America."
					},
					"Tutorial": {
						"All": "(here you can usually read a fact about countries that might help you remember them better)"
					},
				},
			},
			modifiedVariables: {
				camera: {zoom: {level: 0.5, min: 0.02, max: 100}, areDimentionsEqual: true, minWidthToHeightRatio: 2, ...gamePresets["lockedCamera"]},
				
				gameState: {currentState: "menu", states: ["menu", "game", "postGame"]},
				
				colors: {
					backgroundColor: "#808080",
					menuBorder: {
						pos: {start: {x: 0, y: -0.35}, end: {x: 0, y: 0.25}},
						colorStops: [["0", colors.trans[0]], ["0.25", colors.trans[1]], ["0.5", colors.trans[2]], ["0.75", colors.trans[3]], ["1", colors.trans[4]]]
					},
				}
			},
			data: {
				description: "Learn the countries of the world and a fun fact about each of them!",
				releaseDate: "Early 2025",
				tags: ["geography", "countries", "fun facts"],
				/*videos: [
					{name: "Showcase/Walkthrough Video"},
					{name: '\\"How It Was Made\\" Video'},
				]*/
			},
		},
		"Shape-Shifting Minesweeper": {
			overriddenVariables: {
				events: {
					onload: [],
					onNextFrame: [
						"<<if (checkIfWon){ runEvent('winCheck'); checkIfWon = false;}>>",
						"refreshScrollbars",
						"draw"
					],
					
					refreshScrollbars: [{f: "setScrollbarsToGrids", args: {state: "game", margin: {left: 0.5, right: 0.5, up: 0.5, down: 0.05}}}],
					
					generateNumbers: [
						{f: "incrementGridValuesFromNeighborValues", extraArgs: {gridName: "mainGrid", value: "num", neighborValue: {name: "isBomb", value: true}, layer: "base", shouldReplace: true}}
					],
					
					squareGrid: ["<<mainGrid.data.gridShape = 'rect';>>", "generateNumbers"],
					hexagonGrid: ["<<mainGrid.data.gridShape = 'hex';>>", "generateNumbers"],
					triangleGrid: ["<<mainGrid.data.gridShape = 'tri';>>", "generateNumbers"],
					
					winCheck: [
						"<<uncoveredNum = 0;>>",
						"<<overallBombNum = 0;>>",
						"<<uncoveredBombNum = 0;>>",
						`<<
						for (let i in mainGrid.grid.base){
							for (let j in mainGrid.grid.base[i]){
								if (mainGrid.grid.base[i][j].isBomb){
									overallBombNum++;
								}
								if (mainGrid.grid.base[i][j].isRevealed){
									if (mainGrid.grid.base[i][j].isBomb){
										uncoveredBombNum++;
									} else{
										uncoveredNum++;
									}
								}
							}
						}
						let didWin = (((mainGrid.data.gridSize.w * mainGrid.data.gridSize.h) == (uncoveredNum + overallBombNum)) && bombNum == 0);
						
						if (didWin){
							gameState.currentState = "win";
							
							saveCurrentGameScore(uncoveredBombNum, selectedGridSize);
						}
						>>`
					],
				},
				gridNames: ["mainGrid"],
				buttons: {
					game: [
						{pos: {x: 0.1, y: 0.1, w: 0.1, h: 0.1}, text: "💣: {{bombNum}}", textSize: 0.2, isAbsolutePositioned: true,
						textColor: "#ffffff", outlineSize: 0.0022, ...gamePresets.textButton},
						
						{pos: {x: 0.3, y: 0.1, w: 0.1, h: 0.1}, text: "Square", textSize: 0.2, isAbsolutePositioned: true, onclick: {event: "squareGrid"}},
						{pos: {x: 0.5, y: 0.1, w: 0.1, h: 0.1}, text: "Hexagon", textSize: 0.2, isAbsolutePositioned: true, onclick: {event: "hexagonGrid"}},
						{pos: {x: 0.7, y: 0.1, w: 0.1, h: 0.1}, text: "Triangle", textSize: 0.2, isAbsolutePositioned: true, onclick: {event: "triangleGrid"}},
						
						{pos: {x: 0.95, y: 0.05, w: 0.05, h: 0.05}, text: "Quit", textSize: 0.2, isAbsolutePositioned: true, onclick: "<<(confirm('Are you sure? Your progress will be lost.') ? gameState.currentState = 'menu' : '')>>"},
					],
					menu: [
						{pos: {x: 0.5, y: 0.2, w: 0.4, h: 0.2}, text: "Size Selection", textSize: 0.2, isAbsolutePositioned: true,
						textColor: "#ffffff", outlineSize: 0.005, ...gamePresets.textButton},
						
						{pos: {x: 0.2, y: 0.5, w: 0.2, h: 0.2}, text: "Tiny", textSize: 0.1, isAbsolutePositioned: true, onclick: ["<<mainGrid.data.gridSize = gridSizes.tiny;>>", "<<selectedGridSize = 'Tiny'>>", "generateGrids", "<<gameState.currentState = 'game'>>"]},
						{pos: {x: 0.5, y: 0.5, w: 0.2, h: 0.2}, text: "Medium", textSize: 0.2, isAbsolutePositioned: true, onclick: ["<<mainGrid.data.gridSize = gridSizes.medium;>>", "<<selectedGridSize = 'Medium'>>", "generateGrids", "<<gameState.currentState = 'game'>>"]},
						{pos: {x: 0.8, y: 0.5, w: 0.2, h: 0.2}, text: "Huge", textSize: 0.4, isAbsolutePositioned: true, onclick: ["<<mainGrid.data.gridSize = gridSizes.huge;>>", "<<selectedGridSize = 'Huge'>>", "generateGrids", "<<gameState.currentState = 'game'>>"]},
						
						{pos: {x: 0.5, y: 0.8, w: 0.05, h: 0.05}, text: "MASSIVE", textSize: 3, outlineSize: 0, isAbsolutePositioned: true, textColor: colors.backgroundColor, color: "#ffffff00", textHoverOverlay: true, onclick: ["<<mainGrid.data.gridSize = gridSizes.massive;>>", "<<selectedGridSize = 'Massive'>>", "generateGrids", "<<gameState.currentState = 'game'>>"]},
						
						{pos: {x: 0.95, y: 0.05, w: 0.05, h: 0.05}, text: "Quit", textSize: 0.2, isAbsolutePositioned: true, onclick: [{f: "loadGame", args: {gameName: "Game Selection"}}]},
					],
					win: [
						{pos: {x: 0.5, y: 0.5, w: 0.2, h: 0.2}, text: "You Win!\n\nSize: {{selectedGridSize}}\nExplosions: {{uncoveredBombNum}}", textSize: 0.2, isAbsolutePositioned: true,
						textColor: "#ffffff", outlineSize: 0.005, ...gamePresets.textButton},
						
						{pos: {x: 0.5, y: 0.95, w: 0.1, h: 0.1}, text: "thank you for your contribution", textSize: 0.035, isAbsolutePositioned: true,
						textColor: "#ffffff", outlineSize: 0, ...gamePresets.textButton},
						
						{pos: {x: 0.9, y: 0.1, w: 0.1, h: 0.1}, text: "Menu", textSize: 0.2, isAbsolutePositioned: true, onclick: "<<gameState.currentState = 'menu'>>"},
					],
				},
			},
			createdVariables: {
				bombNum: 0,
				bombRatio: 0.366,
				
				uncoveredNum: 0,
				overallBombNum: 0,
				uncoveredBombNum: 0,
				
				checkIfWon: false,
				
				gridSizes: {tiny: {w: 7, h: 5}, medium: {w: 17, h: 11}, huge: {w: 27, h: 17}, massive: {w: 50, h: 32}},
				selectedGridSize: "Tiny",
				
				mainGrid: {
					grid: {},
					entities: [],
					data: {
						x: 0, y: 0, w: 0.2, h: 0.2, gaps: {left: 0, right: 0, up: 0, down: 0}, isCentered: true,
						gridShape: "rect",
						gridSize: {w: 17, h: 11}, layers: ["base"], gameState: "game",
						isFastClick: false,
						
						onload: [
							{f: "setValuesOnGridRandomly", args: {value: {name: "isBomb", value: true}, exclusionPos: [{w: 3, h: 3, isMiddle: true}], amountRatio: "<<bombRatio>>"}},
							{f: "setValuesOnGridPositions", args: {value: {isRevealed: true}, pos: [{w: 3, h: 3, isMiddle: true}], shouldReplace: true}},
							{f: "setVariableToValue", args: {varName: "bombNum", value: {f: "countValuesInGrid", args: {value: {name: "isBomb", value: true}, gridName: "mainGrid"}}}},
							{event: "generateNumbers"},
						],
						
						draw: [
							{f: "fillGridShape", args: {id: "drawTile", color: "#444444", borderColor: "#000000", borderSize: 0.003}},
							{f: "fillGridText", args: {id: "drawLogo", text: defaultValues.channelIconPiece, textSize: 0.45, outlineSize: 0.0005, outlineColor: "#212121"}},
							{f: "fillGridText", args: {id: "drawNumbers", textColor: "#FFFFFF", textSize: 0.4, outlineSize: 0.0025, outlineColor: "#000000", downscaleTextLength: 2}},
						],
						
						gridDrawData: [
							{
								value: {name: "isRevealed", value: true},
								isTrue: [
									{drawTile: {color: "#cecece"}},
									{
										value: {name: "isBomb", value: true},
										isTrue: {drawNumbers: {text: "💣"}, drawTile: {color: "bombColor"}},
										isFalse: {drawNumbers: {value: "num"}}
									}
								],
								isFalse: [
									{drawTile: {color: "#2e2e2e"}},
									{
										value: {name: "isFlagged", value: true},
										isTrue: {drawNumbers: {text: (Math.random() < 0.5 ? "⚑" : "⚐")}},
										isFalse: {value: "<<(args.pos.x + args.pos.y) % 3 == 0>>", isTrue: {drawLogo: {textColor: "#212121"}}},
									},
								]
							}
						],
						gridDrawValues: {},
						
						onclick: [
							{
								value: {name: "mouseButton", value: 1},
								isTrue: {
									value: {name: "isFlagged", value: true},
									isFalse: [
										{
											value: "<<(!args.isRevealed && args.isBomb)>>",
											isTrue: {f: "addValueToVariable", args: {varName: "bombNum", value: -1}}
										},
										{isRevealed: true}
									]
								},
								isFalse: {
									value: {name: "isRevealed", value: true},
									isFalse: {
										value: {name: "isFlagged", value: true},
										isTrue: [
											{isFlagged: false},
											{f: "addValueToVariable", args: {varName: "bombNum", value: 1}}
										],
										isFalse: [
											{isFlagged: true},
											{f: "addValueToVariable", args: {varName: "bombNum", value: -1}}
										]
									}
								}
							},
							"<<checkIfWon = true;>>"
						],
						
						hover: {
							tiles: {}, time: 0.2, clickMultiplier: 1.5, maxHoverAlphaNum: 0.1, fadeInMultiplier: 4, fadeOutMultiplier: 1,
							color: "hsla(0, 100%, 100%, {{alphaNum}})"
						}
					}
				}
			},
			modifiedVariables: {
				camera: {zoom: {level: 0.18}, y: 0.18, areDimentionsEqual: true, minWidthToHeightRatio: 2, ...gamePresets["zoomCamera"]},
				
				gameState: {currentState: "menu", states: ["menu","game","win"]},
				
				colors: {
					bombColor: {
						pos: {start: {x: 0, y: 0}, end: {x: 1, y: 1}},
						colorStops: [["0", colors.bi[0]], ["0.5", colors.bi[1]], ["1", colors.bi[2]]]
					}
				}
			},
			data: {
				description: "Just like the classic Minesweeper,\nbut you toggle the grid between square, hexagon, and triangle tiles.",
				releaseDate: "Early 2025",
				tags: ["minesweeper", "puzzle", "shape-shifting grid"],
				/*videos: [
					{name: "Showcase/Walkthrough Video"},
					{name: '\\"How It Was Made\\" Video'},
				]*/
			},
		},
		"''Fascinating'' ''Possibilities''": {
			overriddenVariables: {
				events: {
					onload: [{f: "replaceValuesInArray", args: {arrName: "unlockedButtons"}}, "refreshNumberButtons"],
					onNextFrame: ["draw"],
					
					
					runNumberFunction: [{f: "runEventOfArrayWithState", extraArgs: {eventArrName: "numberFunctions", stateVarName: "numberTypes"}}],
					
					randomizeNumberType: [{f: "incrementArrayState", extraArgs: {arrName: "numberTypes", value: 1}}],
					
					addLogoText: [
						{f: "addButtonToCurrentGameState", args: gamePresets.channelIconPieceBottomRight},
					],
					
					addTextButtons: [
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0, y: -0.16, w: 0.15, h: 0.05}, text: "Score:\n<<getNumWithTruncatedDecimals(score, 2)>>",
						textSize: 0.15, marginY: 0.06, disableClick: true, outlineSize: 0.00075, textColor: colors.ace[2], outlineColor: colors.ace[0], color: "#00000000"}},
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0, y: -0.095, w: 0.15, h: 0.05}, text: "<<numberTexts[numberTypes.currentState]>>",
						textSize: 0.12, marginY: 0.06, disableClick: true, outlineSize: 0.00075, textColor: "#ffffff", outlineColor: "#000000", color: "#00000000"}},
					],
					addMoveCountText: [
						{f: "addButtonToCurrentGameState", args: {pos: {x: 0.058, y: 1 - 0.05, w: 0.15, h: 0.05}, outlineSize: 0.003, isAbsolutePositioned: true,
						text: "clicks: <<moveCount>>", textSize: 0.1, disableClick: true, textColor: "#ffffff", outlineColor: "#000000", color: "#00000000"}},
					],
					addStateButtons: [
						{f: "addButtonsFromStateArray", args: {arrName: "numberTypes", pos: {x: -0.4175, y: -0.125, w: 0.15, h: 0.03},
						textColor: colors.ace[2], lockedTextColor: colors.ace[0], lockedOutlineColor: colors.ace[0], outlineSize: 0.00015,
						color: colors.ace[3], lockedColor: colors.ace[1],
						textSize: 0.09, offset: {y: 0.04}, disableClick: true, disableClickLooksLocked: true}}
					],
					
					unlockableButtonClick: [
						{f: "setArrayState", extraArgs: {arrName: "numberTypes"}},
						"refreshNumberButtons"
					],
					addUnlockableButtons: ["generateUnlockableButtonsArgs"],
					
					unlockButtons: [
						{f: "changeArrayBooleansByEvalText", args: {arrName: "unlockedButtons", boolName: "value",
						text: "args.currentArr.score != Math.round(score)", shouldTurnOn: false}}
					],
					refreshNumberButtons: [
						"unlockButtons",
						{f: "resetButtons", args: {state: "game"}},
						"<<(!unlockedButtons[5].value && !unlockedButtons[6].value) ? generateUnlockableButtonsArgs.args.pos.margin.h = 0.363 : generateUnlockableButtonsArgs.args.pos.margin.h = Infinity>>",
						"addLogoText",
						"generateButtonsArgs",
						"addTextButtons",
						"addStateButtons",
						"addMoveCountText",
						"addUnlockableButtons"
					],
					
					duplicateButton: [
						{f: "addValueToInventory", extraArgs: {amount: "{{buttonValue}}"}},
						{f: "subtractValueFromVariable", extraArgs: {value: {f: "getArrayMultiple", args: ["{{buttonValue}}",50]}, varName: "score"}}
					],
					
					randomButtons: [
						{f: "addRandomValuesToInventory", extraArgs: {amount: "{{buttonValue}}", min: 1, max: 5}}
					],
					
					mergeButtons: [
						{f: "setVariableToValue", extraArgs: {varName: "mergeScore", value: {f: "getInventoryValueSumWithoutIndex", args: {index: "{{index}}", arrName: "{{arrName}}"}}}},
						"resetArray",
						"addValueToInventory",
						{f: "addValueToInventory", extraArgs: {value: "<<mergeScore>>"}}
					],
					
					moveCountIncrease: [
						{f: "addValueToVariable", extraArgs: {varName: "moveCount", value: 1}},
					],
					
					numberButtonClick: [
						"moveCountIncrease",
						"runNumberFunction",
						"randomizeNumberType",
						"refreshNumberButtons"
					]
				}
			},
			createdVariables: {
				score: 0,
				mergeScore: 0,
				moveCount: 0,
				
				numberTypes: {
					currentState: "add score",
					states: ["add score", "remove button", "divide score", "add score", "negative button"/*, "duplicateButton", "mergeButtons"*/, "random buttons"]
				},
				
				numberTexts: {
					"add score": "Gain score equal to the option number.",
					"remove button": "Choose a button to remove.",
					"divide score": "Divide your score by the option number.",
					"negative button": "Your option becomes negative.",
					"random buttons": "Gain an [option number] amount of random buttons.",
					
					"multiply score": "Multiply your score by the option number.",
					
					"duplicate button": "Duplicate a button the amount of times in the option number.\nLose that much score times 50.",
					"merge buttons": "Select an option. Merge your other options into one option.",
					
					"random value": "Your option becomes a random number between 0 and 1.",
					"square button": "Your option becomes squared.",
					"switch score": "Your [option number] and score switch.",
					"hundred score": "Set your score to [option number] times 100.",
					
					"the end": "You win!\nThank you for contributing to the Wizard Resurrection Initiative."
				},
				
				numberFunctions: {
					"add score": {f: "addValueToVariable", extraArgs: {varName: "score"}},
					"remove button": "removeValueFromInventory",
					"divide score": {f: "divideVariableByValue", extraArgs: {varName: "score"}},
					"negative button": {f: "multipleValueOfInventory", extraArgs: {value: -1}},
					"random buttons": "randomButtons",
					
					"multiply score": {f: "multiplyVariableByValue", extraArgs: {varName: "score"}},
					
					"duplicate button": "duplicateButton",
					"merge buttons": "mergeButtons",
					
					"random value": {f: "changeInventoryValueToEvalText", extraArgs: {text: "getRandomNum({min: 0, max: 1000}) / 1000"}},
					"square button": {f: "exponentiateValueOfInventory", extraArgs: {value: 2}},
					"switch score": {f: "replaceInventoryValueWithVariable", extraArgs: {varName: "score"}},
					"hundred score": {f: "runEval", extraArgs: {text: "window[args.varName] = args.buttonValue * 100;", varName: "score"}},
					
					"the end": [
						"<<saveCurrentGameScore(moveCount)>>",
						"<<alert('victory :>\\n\\nClicks: ' + moveCount);>>"
					]
				},
				
				buttonNumbers: [{value: 1, amount: 1},{value: 3, amount: 1},{value: 4, amount: 1},{value: 5, amount: 1},{value: 6, amount: 1}],
				
				unlockedButtons: [
					{value: true, name: "multiply score", score: "<<getRandomNum({min:7,max:19})>>"},
					{value: true, name: "duplicate button", score: "<<getRandomNum({min:50,max:99})>>"},
					{value: true, name: "merge buttons", score: "<<getRandomNum({max:-250,min:-999})>>"},
					{value: true, name: "random value", score: "<<getRandomNum({max:1000,min:9999})>>"},
					{value: true, name: "square button", score: "<<getRandomNum({min:50000,max:100000})>>"},
					{value: true, name: "switch score", score: "<<getRandomNum({min:5000000,max:10000000})>>"},
					{value: true, name: "hundred score", score: Infinity},
					{value: true, name: "the end", score: "<<getRandomNum({min:50000000000,max:100000000000})>>"}
				],
				
				generateButtonsArgs: {
					f: "generateButtons", args: {arrName: "buttonNumbers", gameState: "game",
					button: {text: "{{value}}", subtext: "x{{amount}}", textSize: 0.3, subtextSize: 0.15, downscaleTextLength: 5, downscaleSubtextLength: 4,
					subtextPos: {x: 0.325}, outlineSize: 0.0002, textColor: "#000000", outlineColor: "#000000",
					onclick: {event: "numberButtonClick", args: "{arrName: 'buttonNumbers', value: {{value}}, buttonValue: {{value}}, index: {{index}}, buttonIndex: {{index}}}"}},
					pos: {x: -0.285, y: -0.025, w: 0.07, h: 0.04, margin: {w: 0.01, h: 0.01}}, grid: {w: 10}}
				},
				
				generateUnlockableButtonsArgs: {
					f: "generateButtons", args: {arrName: "unlockedButtons", gameState: "game",
					button: {text: "{{name}}", lockedText: "{{score}}", textSize: 0.11, outlineSize: 0.0001, color: colors.ace[3], textColor: colors.ace[2], 
					hoverColor: colors.ace[2], maxHoverAlphaNum: 0.5, clickHoverMultiplier: 1.25, hoverReleaseMultiplier: 1.5, lockedColor: colors.ace[1],
					isLocked: "{{value}}", lockedTitle: "[have {{score}} score to unlock]", lockedTitleSize: 0.005,
					onclick: {event: "unlockableButtonClick", args: "{arrName: 'unlockedButtons', value: '{{name}}', buttonValue: '{{name}}', index: {{index}}, buttonIndex: {{index}}}"}},
					pos: {x: -0.41, y: -0.2225, w: 0.125, h: 0.02, margin: {w: 0.01, h: Infinity}}, grid: {w: 7}}
				},
			},
			modifiedVariables: {
				camera: gamePresets["lockedCamera"],
				gameState: {currentState: "game", states: ["game"]},
				
				colors: {
					backgroundColor: {
						pos: {start: {x: 0, y: 0}, end: {x: 1, y: 1}},
						colorStops: [["0", "#787878"], ["1.0", "#585858"]]
					}
				}
			},
			data: {
				description: "A slightly expanded version of Icely puzzle's \"\"\"Interesting\"\" \"\"Choices\"\"\" game.\nReach certain scores by the power of basic mathematics! :>",
				releaseDate: "Early 2025",
				tags: ["math(s)", "puzzle", "button game"],
				/*videos: [
					{name: "Showcase/Walkthrough Video"},
					{name: '\\"How It Was Made\\" Video'},
				]*/
			},
		},
		
		"Game Selection": {
			overriddenVariables: {
				drawOrder: ["drawEntities", "drawGrids", "drawButtons", "drawScrollbars"],
				
				events: {
					onload: ["generateGrids"],
					onNextFrame: [
						"refreshTimes",
						"moveEntities",
						"drawDayBackground",
						"draw"
					],
					
					refreshTimes: [
						"<<budapestTime.value = new Date(new Date().toLocaleString('en-US', {timeZone: 'Europe/Budapest'}));>>", //Europe/Budapest America/New_York America/Los_Angeles Asia/Tokyo
						"<<budapestTime.hour12 = budapestTime.value.toLocaleString('en-US', { hour: 'numeric', hour12: true})>>",
						"<<budapestTime.hour24 = budapestTime.value.getHours() + budapestTime.value.getMinutes() / 60>>",
						//"<<budapestTime.hour24 = ((budapestTime.value.getHours() + budapestTime.value.getMinutes() / 60 + budapestTime.value.getSeconds()/60/60) * 10000) % 24>>"
					],
					drawDayBackground: [
						"<<colors.backgroundColor = hourColors[Math.floor(budapestTime.hour24)]>>"
					],
					
					selectedGameVideoButtons: [
						"<<currentVideos = (((gameData[selectedGame] ?? {}).data ?? {}).videos ?? []);>>",
						{
							f: "generateButtons", args: {arrName: "currentVideos", gameState: "newGames",
							button: {text: "{{name}}", textSize: 0.325, downscaleTextLength: 5, textColor: "#000000",
							id: "videoButtons", isAbsolutePositioned: true,
							onclick: {f: "runEval", extraArgs: {text: "('{{value}}' != 'undefined') ? window.open('{{value}}') : alert('Video coming soon!')"}}},
							pos: {x: 0.725, y: 0.525, w: 0.19, h: 0.055, margin: {w: 0.01, h: 0.03}}, grid: {w: 1}}
						}
					],
					
					gameSelect: [
						"<<changeButtonArgsById('gameSelectHider', {isHidden: true});>>",
						"<<removeButtonsById('videoButtons');>>",
						"<<runEvent('selectedGameVideoButtons');>>",
						"<<runEvent('refreshCurrentHighScoreText');>>",
					],
					
					refreshCurrentHighScoreText: [`<<{
						let hasHighScore = ((gameSaves[selectedGame] ?? {score: null}).score != null);
						
						currentHighScoreText = "High Score:\\n";
						
						if (hasHighScore){
							let currentScore = gameSaves[selectedGame].score;
							
							if (isObject(currentScore)){
								currentHighScoreText = "High Scores:\\n";
								
								let isFirst = true;
								for (let i in currentScore){
									if (currentScore[i] != null){
										currentHighScoreText += ((!isFirst) ? "\\n" : "");
										currentHighScoreText += i + ": " + currentScore[i] + " " + (gameSaves[selectedGame] ?? {text: ''}).text;
										isFirst = false;
									}
								}
								
								if (currentHighScoreText == "High Scores:\\n"){
									currentHighScoreText += "None";
								}
							} else{
								currentHighScoreText += gameSaves[selectedGame].score + " " + (gameSaves[selectedGame] ?? {text: ''}).text;
							}
						} else{
							currentHighScoreText += "None";
						}
					}>>`],
				},
				gridNames: ["newGamesGrid", "oldGamesGrid"],
				
				buttons: {
					main: [
						{pos: {x: 0.3, y: 0.5, w: 0.2, h: 0.2}, text: "Newer Games", textSize: 0.14, subtext: "({{gamesArray.length}} Games)", subtextPos: {x: 0.325, y: 0.325},
						onclick: "<<gameState.currentState = 'newGames';>>", isAbsolutePositioned: true},
						
						{pos: {x: 1-0.3, y: 0.5, w: 0.2, h: 0.2}, text: "Older Games", textSize: 0.14, subtext: "({{oldGames.length}} Games)", subtextPos: {x: 0.325, y: 0.325},
						onclick: "<<gameState.currentState = 'oldGames';>>", isAbsolutePositioned: true},
						
						{pos: {x: 0.5, y: 0.925, w: 0.2, h: 0.2}, text: "It's {{budapestTime.hour12}} in parts of Europe", textSize: 0.14, textColor: "#ffffff",
						isAbsolutePositioned: true, ...gamePresets.textButton},
						
						{pos: {x: 0.5, y: 0.85, w: 0.2, h: 0.2}, textSize: 0.07, textColor: "#ffffff",
						text: "{{(budapestTime.hour24 % 12 == 0) ? ((budapestTime.hour24 == 12) ? 'It\\'s high noon.' : 'It\\'s high nigh.') : ''}}",
						isAbsolutePositioned: true, ...gamePresets.textButton},
						
						{pos: {x: 0.5, y: 0.0375, w: 0.1, h: 0.1}, text: "{{(browserName != 'Chrome') ? '(to ensure that everything works as intended, please consider opening this site with Google Chrome)' : ''}}", textSize: 0.14, textColor: "#ffffff",
						isAbsolutePositioned: true, ...gamePresets.textButton},
					],
					newGames: [
						{pos: {x: 0.725, y: 0.425, w: 0.4, h: 0.8}, text: "", color: "#FFFFFF88", isAbsolutePositioned: true, disableClick: true},
						
						{pos: {x: 0.725, y: 0.13, w: 0.25, h: 0.15}, text: "{{(selectedGame ?? '').replaceAll(' ', '\\n')}}",
						textSize: 0.1, marginY: 0.095, textColor: colors.black, color: "#FFFFFF66", isAbsolutePositioned: true, disableClick: true},
						
						{pos: {x: 0.725, y: 0.28, w: 0.38, h: 0.1}, text: "{{(((gameData[selectedGame] ?? {}).data ?? {}).description ?? '')}}",
						textSize: 0.215, downscaleTextLength: 8, textColor: colors.black, color: "#FFFFFF44", isAbsolutePositioned: true, disableClick: true},
						
						{pos: {x: 0.765 + 0.15/2, y: 0.4, w: 0.15, h: 0.1}, text: "{{(((gameData[selectedGame] ?? {}).data ?? {}).tags ?? []).join(',\\n')}}",
						textSize: 0.08, downscaleTextLength: 21, textColor: colors.black, color: "#00000000", isAbsolutePositioned: true, disableClick: true},
						{pos: {x: 0.77 - 0.01, y: 0.4, w: 0.05, h: 0.1}, text: "tags:",
						textSize: 0.3, textColor: colors.black, color: "#00000000", isAbsolutePositioned: true, disableClick: true},
						
						{pos: {x: 0.725-(0.77-0.725)*2, y: 0.4, w: 0.2, h: 0.1}, text: "Release Date: {{((gameData[selectedGame] ?? {}).data ?? {}).releaseDate ?? '???'}}",
						textSize: 0.185, downscaleTextLength: 8, textColor: colors.black, color: "#00000000", isAbsolutePositioned: true, disableClick: true},
						
						{pos: {x: 0.58, y: 0.57, w: 0.1, h: 0.1}, text: "{{currentHighScoreText}}",
						textSize: 0.19, downscaleTextLength: 8, textColor: colors.black, color: "#00000000", isAbsolutePositioned: true, disableClick: true},
						
						
						{pos: {x: 0.725, y: 0.725, w: 0.25, h: 0.1}, text: "Start", textSize: 0.15, onclick: "<<loadGame({gameName: selectedGame});>>", isAbsolutePositioned: true},
						
						{pos: {x: 0.725, y: 0.425, w: 0.4, h: 0.8}, text: "<-- Select a game!", id: "gameSelectHider",
						textColor: colors.black, color: "#888888", textSize: 0.075, isAbsolutePositioned: true, disableClick: true},
						
						
						{pos: {x: 0.9125, y: 0.915, w: 0.1, h: 0.08}, text: "Back", textSize: 0.225, onclick: "<<gameState.currentState = 'main';>>", isAbsolutePositioned: true},
					],
					oldGames: [
						{pos: {x: 0.0325, y: 0.0275, w: 0.05, h: 0.025}, text: "old site", textSize: 0.175, onclick: "<<window.open('https://soverthe.github.io/oldWebsite.html');>>", isAbsolutePositioned: true},
						
						{pos: {x: 0.9125, y: 0.915, w: 0.1, h: 0.08}, text: "Back", textSize: 0.225, onclick: "<<gameState.currentState = 'main';>>", isAbsolutePositioned: true},
					]
				},
				
				entities: [
					{pos: {x: 0, y: 0.5, w: 0.06, shape: "circle"}, color: "#FFFF00", movement: {
						type: "rotateEntityAroundTarget", target: {x: 0.5, y: 1}, radius: {x: 0.45, y: 0.95},
						radians: "<<(budapestTime.hour24 - 6.5 + Math.PI * 4) * Math.PI * 2 / 24>>"}, isAbsolutePositioned: true
					},
					{pos: {x: 0, y: 0.5, w: 0.06, shape: "circle"}, color: "#444444", movement: {
						type: "rotateEntityAroundTarget", target: {x: 0.5, y: 1}, radius: {x: 0.45, y: 0.95},
						radians: "<<(budapestTime.hour24 - 6.5) * Math.PI * 2 / 24>>"}, isAbsolutePositioned: true
					}
				],
			},
			createdVariables: {
				currentHighScoreText: "",
				
				budapestTime: {},
				hourColors: [
					"#000000","#000000","#000000","#000000","#000000","#000000","#440022","#221679","#3355bb","#4488ff","#4488ff","#4488ff","#4488ff",
					"#4488ff","#4488ff","#4488ff","#3355bb","#221679","#440022","#000000","#000000","#000000","#000000","#000000","#000000"
				],
				
				gamesArray: currentGame.states,
				oldGames: [
					{name: "Cursetris", href: "Cursetris", date: "Late 2024"},
					{name: "Nonograms", href: "Nonograms", date: "Early 2024"},
					{name: "Stardew Guess Who", href: "StardewGuessWho", date: "May 2022"},
					{name: "Adventures of FF Island\n(a game for ComputerCraft)", href: "FFIslandInstallation", date: "April 2021"}
				],
				
				newGamesGrid: {
					grid: {},
					entities: [],
					data: {
						//x: -0.35 - 0.2*2.5, y: 0, w: 0.4, h: 0.25, gaps: {left: 0.025, right: 0.025, up: 0.025, down: 0.025}, isCentered: true,
						x: -0.35 - 0.2*2.5, y: 0.425-0.5, w: 0.5, h: 0.3, gaps: {left: 0.025, right: 0.025, up: 0.025, down: 0.025}, isCentered: true,
						gridShape: "rect",
						gridSize: {w: 2, h: 2}, layers: ["base"], gameState: "newGames",
						isFastClick: false,
						
						onload: [
							{f: "setValuesOnGridFromArray", args: {value: {name: "gameName"}, arrName: "gamesArray"}},
						],
						
						draw: [
							{f: "fillGridShape", args: {id: "drawTile", borderColor: "#000000", borderSize: 0.006,//borderSize: 0.003,
							borderColor: "menuBorder"}},
							{f: "fillGridText", args: {id: "drawNames", textSize: 0.8, outlineSize: 0.002,
							textColor: "#FFFFFF", outlineColor: "menuBorder", marginY: 0.15, breakSpaces: true, downscaleTextLength: 2}},
						],
						
						gridDrawData: [
							{
								value: {name: "gameName", value: undefined},
								isTrue: {drawTile: {color: "#333333"}},
								isFalse: {drawTile: {color: "#FFFFFFE8"}, drawNames: {value: "gameName"}}
							}
						],
						gridDrawValues: {},
						
						onclick: {
							value: {name: "mouseButton", value: 1},
							isTrue: {
								value: {name: "gameName", value: undefined},
								isFalse: [
									"<<selectedGame = args.gameName;>>",
									"<<runEvent('gameSelect');>>",
								]
							}
						},
						
						hover: {
							tiles: {}, time: 0.2, clickMultiplier: 1.5, maxHoverAlphaNum: 0.3, fadeInMultiplier: 1, fadeOutMultiplier: 1,
							color: "hsla(0, 100%, 100%, {{alphaNum}})"
						}
					}
				},
				oldGamesGrid: {
					grid: {},
					entities: [],
					data: {
						x: 0, y: 0, w: 0.9, h: 0.4, gaps: {left: 0.1, right: 0.1, up: 0.1, down: 0.1}, isCentered: true,
						gridShape: "rect",
						gridSize: {w: 2, h: 2}, layers: ["base"], gameState: "oldGames",
						isFastClick: false,
						
						onload: [
							{f: "setValuesOnGridFromArray", args: {arrName: "oldGames"}},
						],
						
						draw: [
							{f: "fillGridShape", args: {id: "drawTile", borderColor: "#000000", borderSize: 0.003}},
							{f: "fillGridText", args: {id: "drawNames", textColor: "#000000", textSize: 1.25, outlineSize: 0.0001, outlineColor: "#000000", marginY: 0.175, downscaleTextLength: 1}},
							{f: "fillGridText", args: {id: "drawDates", textColor: "#000000", textSize: 0.05, outlineSize: 0.0001, outlineColor: "#000000", textOffset: {x: 0.1535, y: 0.094}}},
						],
						
						gridDrawData: [
							{
								value: {name: "name", value: undefined},
								isFalse: {drawTile: {color: "#ffffff"}, drawNames: {value: "name"}, drawDates: {value: "date"}}
							}
						],
						gridDrawValues: {},
						
						onclick: {
							value: {name: "mouseButton", value: 1},
							isTrue: {
								value: {name: "href", value: undefined},
								isFalse: {f: "runEval", extraArgs: {text: "window.open('https://soverthe.github.io/' + args.href + '.html')"}}
							}
						},
						
						hover: {
							tiles: {}, time: 0.2, clickMultiplier: 1.5, maxHoverAlphaNum: 0.3, fadeInMultiplier: 1, fadeOutMultiplier: 1,
							color: "hsla(0, 100%, 100%, {{alphaNum}})"
						}
					}
				}
			},
			modifiedVariables: {
				camera: {zoom: {level: 0.3}, areDimentionsEqual: true, minWidthToHeightRatio: 2, ...gamePresets["lockedCamera"]},
				
				gameState: {currentState: "main", states: ["main", "oldGames", "newGames"]},
				
				colors: {
					menuBorder: {
						pos: {start: {x: 0, y: 0.15}, end: {x: 0, y: 0.85}}, isScaled: false,
						colorStops: [["0", colors.bi[0]], ["0.5", colors.bi[1]], ["1", colors.bi[2]]]
					}
				}
			}
		},
	}
	
</script>

<script> //General
	
	let t = 0;
	function slowLog(...text){ //so console.log won't stop the browser
		if (t % Math.floor(fps/2) == 0){
			console.log(...text);
		}
	}
	function log(...text){
		console.log(...text);
	}
	
	
	function modulo(n, m){ //https://stackoverflow.com/a/17323608
		return ((n % m) + m) % m;
	}
	
	function getNumInRange(num, min, max, type){ //could be more clever
		if (type == "loop"){
			if (num < min){ num = max; }
			if (num > max){ num = min; }
		} else{
			if (num < min){ num = min; }
			if (num > max){ num = max; }
		}
		
		return num;
	}
	
	
	function insertIntoArray(arr, value, index){
		arr.splice(index, 0, value);
	}
	
	
	function objectLength(arr){
		let length = 0;
		
		if (arr != undefined){
			length = Object.keys(arr).length;
		}
		return length;
	}
	
	function getElementsOfObject(arr){
		let elements = [];
		
		for (let i in arr){
			elements.push({name: i, value: arr[i]});
		}
		return elements;
	}
	
	function getElementOfObjectByIndex(arr, index){
		let element;
		
		let name = Object.keys(arr)[index];
		
		return {name: name, value: arr[name]};
	}
	
	
	function range(size){ //example: for (let i of range(10))
		return [...Array(size).keys()];
	}
	
	
	function getSlicedString(s, span){
		return s.slice(span.start, span.end + 1);
	}
	
	function getReversedString(s){ //https://stackoverflow.com/a/959004 (doesn't work on double characters like 𝌆)
		return s.split("").reverse().join("");
	}
	
	function getCharacterOccurrenceInString(c, s){ //https://stackoverflow.com/a/10671743
		return (s.match(new RegExp(c, "g")) || []).length;
	}
	
	
	function containsExcludedWords(text, exclusionArray = []){
		return exclusionArray.some(word => text.includes(word));
	}
	
	
	function getTextWithoutPunctuation(text){
		return text.replace(/[^\p{L}0-9'-]+/gu, ' ').trim();
	}
	
	function getWordsOfTextWithoutPunctuation(text){
		return text.match(/[\p{L}0-9'-]+/gu) || [];
	}
	
	
	function getNumWithTruncatedDecimals(num, decimalsAmount){ //https://stackoverflow.com/a/11818658 (modified)
		let result = num;
		
		if (isNumberWithoutInfinity(num)){
			let regex = new RegExp('^-?\\d+(?:\.\\d{0,' + decimalsAmount + '})?');
			
			let arr = (num + "").split("e");
			
			
			result = arr[0].toString().match(regex)[0];
			
			result = result.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, ''); //turns 1.000 to 1
			
			result += (arr[1] != undefined ? "e" + arr[1] : "");
		}
		return result;
	}
	
	
	function removeExtraSpacesFromText(text){ //https://www.geeksforgeeks.org/how-to-replace-multiple-spaces-with-single-space-in-javascript/
		return text.trim().replace(/\s+/g, " ");
	}
	
	
	function getEvaluatedText(text, isCurlyBrackets = true, quoteInfinity = false, args){
		let evalText = "";
		
		let symbols = {
			open: (isCurlyBrackets) ? "{{" : "<<",
			close: (isCurlyBrackets) ? "}}" : ">>"
		}
		
		if ((text + "").includes(symbols.open) && shouldEvalText){
			let regex = new RegExp("(?=" + symbols.open + ")"); //split before symbols.open
			let arr = text.split(regex);
			
			let currentArr = [];
			let currentText = "";
			let depth = 1;
			for (let i in arr){ //undo symbols.open splits if they're nested
				currentText += arr[i];
				
				let num = getCharacterOccurrenceInString(symbols.close, currentText);
				if (num >= depth || !currentText.startsWith(symbols.open)){
					currentArr.push(currentText);
					
					currentText = "";
                    depth = 1;
				} else{
					depth++;
				}
			}
			
            let splitArr = [];
            for (let i in currentArr){ //split at last symbols.close and remove starting symbols.open
                let lastSymbolIndex = currentArr[i].lastIndexOf(symbols.close);
                if (lastSymbolIndex != -1){
					currentText = currentArr[i].slice(0, lastSymbolIndex);
					
					if (currentText.startsWith(symbols.open)){
						currentText = currentText.slice(symbols.open.length);
					}
					
					splitArr.push({shouldEval: true, text: currentText});
					splitArr.push({shouldEval: false, text: currentArr[i].slice(lastSymbolIndex + symbols.close.length)});
				} else{
					splitArr.push({shouldEval: false, text: currentArr[i]});
				}
            }
			
			evalText = "";
			for (let i = 0; i < splitArr.length; i++){
				if (splitArr[i].shouldEval){
					let evaledValue = functionEval(splitArr[i].text, {...args, shouldEval: false});
					
					//remove quotes around replaced numbers
					let isNumberFunction = (quoteInfinity) ? isNumberWithoutInfinity : isNumber;
					
					//if number surrounded by "" then remove quotes
					if (isNumberFunction(evaledValue) && i > 0){
						if (evalText[evalText.length - 1] == '"' && (splitArr[i + 1] ?? {text: ""}).text[0] == '"'){
							evalText = evalText.slice(0, -1);
							splitArr[i + 1].text = splitArr[i + 1].text.slice(1);
							
							shouldLoop = true;
						}
					}
					
					evalText += evaledValue;
				} else{
					evalText += splitArr[i].text;
				}
			}
		} else{
			evalText = text;
		}
		
		return evalText;
	}
	
	function getEvaluatedObject(arr, isCurlyBrackets = true){
		return parse(getEvaluatedText(stringify(arr), isCurlyBrackets));
	}
	
	
	function functionEval(text, args = {}){
		let argsText = "";
		
		if (args != undefined){
			argsText = "let args = " + stringify(args) + ";";
		}
		
		if (args.shouldEval){
			text = getEvaluatedText(text, false);
		}
		
		text = text.replaceAll('\\"', '"').replaceAll('\n', '').replaceAll('\t', '');
		
		let returnValue;
		
		try {
			returnValue = (new Function(argsText + "return " + text)());
		} catch (e){
			returnValue = (new Function(argsText + text)());
		}
		
		return returnValue;
	}
	
	
	function getRandomElementOfArray(arr){
		return arr[Math.floor(Math.random() * arr.length)];
	}
	function getRandomElementNameOfObject(arr){ //https://stackoverflow.com/a/15106541/12777947
		let keys = Object.keys(arr);
		
		return keys[keys.length * Math.random() << 0];
	}
	function getRandomElementOfObject(arr){
		return arr[getRandomElementNameOfObject(arr)];
	}
	
	function getRandomElementWithoutRepeats(arr, startingValue, f){
		let value = startingValue;
		let i = 0;
		
		f ??= getRandomElementOfArray;
		
		while (value == startingValue && i < 100){
			value = f(arr);
			i++;
		}
		return value;
	}
	
	function getRandomElementOfArrayWithoutRepeats(arr, startingValue){
		return getRandomElementWithoutRepeats(arr, startingValue, getRandomElementOfArray);
	}
	function getRandomElementOfObjectWithoutRepeats(arr, startingValue){
		return getRandomElementWithoutRepeats(arr, startingValue, getRandomElementOfObject);
	}
	function getRandomElementNameOfObjectWithoutRepeats(arr, startingValue){
		return getRandomElementWithoutRepeats(arr, startingValue, getRandomElementNameOfObject);
	}
	
	
	function getBiggestLengthOfArray(arr){
		let lengths = [];
		
		for (let i in arr){
			let value = arr[i];
			
			if (isNumber(value)){
				value = value + "";
			}
			
			lengths.push(value.length);
		}
		return Math.max(...lengths);
	}
	
	
	function areArraysEqual(a, b){ //https://stackoverflow.com/a/16436975/12777947
		if (a === b) return true;
		if (a == null || b == null) return false;
		if (a.length !== b.length) return false;
		
		for (var i = 0; i < a.length; ++i){
			if (a[i] !== b[i]) return false;
		}
		return true;
	}
	
	function compareObjects1D(a, b){ //https://stackoverflow.com/a/68091909
		return (Object.entries(a).sort().toString() === Object.entries(b).sort().toString());
	}
	
	
	function getArrayWithoutValue(arr, value){ //https://stackoverflow.com/a/5767357
		let index = arr.indexOf(value);
		
		if (index > -1){
			arr.splice(index, 1);
		}
	}
	
	function getArrayWithoutRemoveArrayElements(arr, removeArr){ //https://stackoverflow.com/a/19957433
		return arr.filter( function (el){
			return !removeArr.includes(el);
		});
	}
	
	
	function calculateObjectsByOperator(a, b, operatorType){
		let c = {};
		
		if (isArray(a) && isArray(b)){
			c = [];
		}
		
		let arrs = [a, b];
		
		for (let arrNum in arrs){
			let arr = arrs[arrNum];
			let otherArr = arrs[1 - arrNum];
			
			for (let i in arr){
				if (c[i] == undefined){
					if (isNumber(arr[i])){
						c[i] = arr[i];
						
						if (isNumber(otherArr[i])){
							switch (operatorType){
								case "+": c[i] += otherArr[i]; break;
								case "-": c[i] -= otherArr[i]; break;
								case "*": c[i] *= otherArr[i]; break;
								case "/": c[i] /= otherArr[i]; break;
							}
						}
					} else{
						if (arr[i] != undefined){
							if (isArrayOrObject(arr[i])){
								if (isArrayOrObject(otherArr[i])){
									c[i] = calculateObjectsByOperator(arr[i], otherArr[i] ?? [], operatorType);
								} else{
									c[i] = structuredClone(arr[i]);
								}
							} else{
								c[i] = arr[i];
							}
						}
					}
				}
			}
		}
		return c;
	}
	
	function addObjects(a, b){ return calculateObjectsByOperator(a, b, "+");}
	function subtractObjects(a, b){ return calculateObjectsByOperator(a, b, "-");}
	function multiplyObjects(a, b){ return calculateObjectsByOperator(a, b, "*");}
	function divideObjects(a, b){ return calculateObjectsByOperator(a, b, "/");}
	
	function combineValues(value1, value2){
		let combinedValue;
		
		if (isArrayOrObject(value1) && isArrayOrObject(value2)){
			combinedValue = calculateObjectsByOperator(value1, value2);
		} else{
			if (!isArrayOrObject(value2)){
				combinedValue = value2;
			}
			if (!isArrayOrObject(value1)){
				combinedValue = value1;
			}
		}
		return combinedValue;
	}
	
	
	function shuffleArray(arr){ //https://stackoverflow.com/a/3718452/12777947
		for (let i = 0; i < arr.length - 1; i++){
			let j = i + Math.floor(Math.random() * (arr.length - i));
			
			let temp = arr[j];
			arr[j] = arr[i];
			arr[i] = temp;
		}
		return arr;
	}
	
	function shuffleObject(arr){
		let values = Object.values(arr);
		
		let shuffledArray = shuffleArray(values);
		
		let num = 0;
		for (let i in arr){
			arr[i] = shuffledArray[num];
			
			num++;
		}
	}
	
	
	function sortObjectByValue(arr, valueName, isSmallToBig){ //https://stackoverflow.com/a/1063027/1277794
		if (isSmallToBig){
			arr.sort((a,b) => a[valueName] - b[valueName]);
		} else{
			arr.sort((a,b) => b[valueName] - a[valueName]);
		}
	}
	
	function sortObjectBy2DValue(arr, valueName1, valueName2, isSmallToBig){
		if (isSmallToBig){
			arr.sort((a,b) => a[valueName1][valueName2] - b[valueName1][valueName2]);
		} else{
			arr.sort((a,b) => b[valueName1][valueName2] - a[valueName1][valueName2]);
		}
	}
	
	
	function getObjectKeyWithHighestValue(arr){ //https://stackoverflow.com/a/27376421
		return Object.keys(arr).reduce((a, b) => arr[a] > arr[b] ? a : b);
	}
	
	
	function getAverageOfArray(arr){
		return arr.reduce((a, b) => a + b) / arr.length;
	}
	
	
	function toggleWindowBoolean(name){
		window[name] = !window[name];
	}
	
	
	function capitalizeFirstLetter(s){ //https://stackoverflow.com/a/1026087/12777947
		return s.charAt(0).toUpperCase() + s.slice(1);
	}
	
	
	function getCurrentTime(){
		return new Date().getTime();
	}
	
	
	function copyTextToClipboard(text){
		navigator.clipboard.writeText(text);
	}
	
	
	function isArray(arr){
		return Array.isArray(arr);
	}
	function isArrayOrObject(arr){
		return (typeof arr === 'object' && arr !== null);
	}
	function isObject(arr){
		return (isArrayOrObject(arr) && !isArray(arr));
	}
	
	
	function incrementValueInArray(i, arr, num = 1){
		if (arr[i] == undefined){
			arr[i] = 0;
		}
		
		arr[i] += num;
		
		return arr;
	}
	
	function getPosInArr(pos, arr){
		let value;
		
		if (arr[pos.y] != undefined){
			if (arr[pos.y][pos.x] != undefined){
				value = arr[pos.y][pos.x];
			}
		}
		return value;
	}
	
	function isPosInArr(pos, arr){
		let isInArr = false;
		
		if (arr[pos.y] != undefined){
			if (arr[pos.y][pos.x] != undefined){
				isInArr = true;
			}
		}
		return isInArr;
	}
	
	function setValueInArrAtPos(value, arr, pos){
		if (arr[pos.y] == undefined){
			arr[pos.y] = [];
		}
		
		arr[pos.y][pos.x] = value;
		
		return arr;
	}
	
	
	function getMirroredArray(arr){
		return arr.reverse();
	}
	
	function getMirroredArray2D(arr){
		for (let i in arr){
			arr[i] = arr[i].reverse();
		}
		return arr;
	}
	
	function getRotatedArray2D(arr, radians){
		let positionArr = [];
		
		let min = {x: 0, y: 0};
		
		for (let i = 0; i < arr.length; i++){
			for (let j = 0; j < arr[i].length; j++){
				let pos = {
					x: Math.round((Math.cos(radians) * j) + (Math.sin(radians) * i)),
					y: Math.round((Math.cos(radians) * i) - (Math.sin(radians) * j)),
					i: i,
					j: j
				};
				
				positionArr.push(pos);
				
				if (pos.x < min.x){ min.x = pos.x };
				if (pos.y < min.y){ min.y = pos.y };
			}
		}
		
		let rotatedArr = [];
		
		for (let i in positionArr){
			let pos = positionArr[i];
			
			pos.x -= min.x;
			pos.y -= min.y;
			
			if (rotatedArr[pos.y] == undefined){
				rotatedArr[pos.y] = [];
			}
			rotatedArr[pos.y][pos.x] = arr[pos.i][pos.j];
		}
		return rotatedArr;
	}
	
	
	function getRandomNumberFromPercentages(percentages){
		let num = 0;
		let randomNum = Math.random();
		let result = 0;
		
		for (let i in percentages){
			if (randomNum < num + percentages[i]){
				result = Number(i);
				
				break;
			} else{
				num += percentages[i];
			}
		}
		return result;
	}
	
	function getRandomOccurrencesFromPercentages(percentages, attempts){ //Mostly AI Generated, isn't perfect past Number.MAX_SAFE_INTEGER
		let results = [];
		
		let sum = 0;
		for (let i = 0; i < percentages.length; i++){
			let mean = attempts * percentages[i];
			let stdDev = Math.sqrt(attempts * percentages[i] * (1 - percentages[i]));
			
			let randomOccurrences = Math.round(mean + (Math.random() * 2 - 1) * stdDev);
			
			results.push(Math.max(0, Math.min(attempts, randomOccurrences)));
			
			sum += results[i];
		}
		
		sum = Math.max(sum, 1);
		
		let scalingFactor = attempts / sum;
		for (let i = 0; i < results.length; i++){
			results[i] = Math.floor(results[i] * scalingFactor);
		}
		
		
		let currentSum = results.reduce((acc, value) => acc + value, 0);
		
		if (attempts < Number.MAX_SAFE_INTEGER){
			for (let i = 0; i < attempts - currentSum; i++){
				results[getRandomNumberFromPercentages(percentages)]++;
			}
		} else if (attempts >= Number.MAX_VALUE){
			for (let i in results){
				results[i] = Infinity;
			}
		}
		
		return results;
	}
	
	
	function stringify(value){
		return JSON.stringify(value, (key, value) => {
			if (value === Infinity){ return 'Infinity'; }
			
			if (value === -Infinity){ return '-Infinity'; }
			
			if (Number.isNaN(value)){ return 'NaN'; }
			
			if (value instanceof RegExp || typeof value === 'function' || typeof value === 'symbol'){
				return value.toString();
			}
			
			if (typeof value === 'bigint'){ return value.toString() + "n"; }
			
			return value;
		});
	}
	
	function parse(text){ //this and the stringify was made with AI
		try {
			text = text.replace(/\n/g, '\\n').replace(/\t/g, '\\t');
			
			let result = JSON.parse(text, (key, value) => {
				if (value === 'Infinity'){ return Infinity; }
				
				if (value === '-Infinity'){ return -Infinity; }
				
				if (value === 'NaN'){ return NaN; }
				
				if (typeof value === 'string' && /^\/.*\/$/.test(value)){
					try {
						return new RegExp(value.slice(1, -1));
					} catch (e){
						return value;
					}
				}
				
				if (typeof value === 'string' && value.startsWith('function')){
					try {
						return new Function('return ' + value)();
					} catch (e){
						return value;
					}
				}
				
				if (typeof value === 'string' && /^Symbol\((.*)\)$/.test(value)){
					let symbolText = value.match(/^Symbol\((.*)\)$/)[1];
					return Symbol(symbolText);
				}
				
				if (typeof value === 'string' && /^[0-9]+n$/.test(value)){
					return BigInt(value.slice(0, -1));
				}
				
				return value;
			});
			
			return result;
		} catch (e){
			return text;
		}
	}
	
	
	function isNaNOrInfinity(value){
		return isNaN(value) || value == Infinity || value == -Infinity;
	}
	
	function isNumber(value){
		return !isNaN(value) && value !== "";
	}
	function isNumberWithoutInfinity(value){
		return isNumber(value) && value != Infinity && value != -Infinity;
	}
	
	
</script>
<script> //General 2 (Events Functions)
	
	function getArrayWithReplacedValues(arr, values){
		let text = stringify(arr);
		
		let args = {...values};
		let valuesText = stringify(values ?? "");
		
		let savedValues = {};
		
		if (isObject(values)){
			for (let i in values){
				if (isNumberWithoutInfinity(values[i])){
					text = text.replaceAll("\"{{" + i + "}}\"", values[i]);
					valuesText = valuesText.replaceAll("\"{{" + i + "}}\"", values[i]);
				}
				text = text.replaceAll("{{" + i + "}}", values[i]);
				valuesText = valuesText.replaceAll("{{" + i + "}}", values[i]);
			}
		}
		arr = parse(text);
		values = parse(valuesText);
		
		if (isObject(values)){
			for (let i in values){
				if (isObject(values[i])){
					if (values[i].f != undefined || values[i].event != undefined){
						values[i] = runEvent({name: values[i]});
						
						if (values[i] != undefined){
							savedValues[i] = values[i];
						}
					}
				}
			}
		}
		
		for (let i in savedValues){
			if (isObject(arr[i])){ arr[i] = savedValues[i]; }
			
			if (arr.args != undefined){ if (isObject(arr.args[i])){ arr.args[i] = savedValues[i]; } }
			if (arr.extraArgs != undefined){ if (isObject(arr.extraArgs[i])){ arr.extraArgs[i] = savedValues[i]; } }
		}
		
		text = getEvaluatedText(stringify(arr), false, true, args);
		arr = parse(text);
		
		return arr;
	}
	
	function replaceValuesInArray(args){
		window[args.arrName] = getArrayWithReplacedValues(window[args.arrName]);
	}
	
	
	
	function getConditionalArrayValue(arr, args){
		let isArr = isArray(arr);
		
		let result = {};
		
		if (isArr){
			for (let i in arr){
				if (typeof arr[i] != "string"){
					let currentResult = getConditionalArrayValue(arr[i], args);
					
					result = {...result, ...currentResult};
				} else{
					getEvaluatedText(arr[i], false, false, args);
				}
			}
		} else{
			for (let i in arr){
				if (i != "value" && i != "isTrue" && i != "isFalse" && i != "f" && i != "event" && i != "args" && i != "extraArgs"){
					result[i] = arr[i];
				}
			}
			
			if (arr.f != undefined || arr.event != undefined){
				runEvent([arr], args);
			}
			
			if (arr.value != undefined){
				let isTrue = false;
				
				if (isObject(arr.value)){
					isTrue = (args[arr.value.name] == arr.value.value);
				} else{
					isTrue = functionEval(arr.value.replaceAll("<<","").replaceAll(">>",""), args)
				}
				
				if (isTrue && arr.isTrue != undefined){
					result = {...result, ...getConditionalArrayValue(arr.isTrue, args)};
				}
				if (!isTrue && arr.isFalse != undefined){
					result = {...result, ...getConditionalArrayValue(arr.isFalse, args)};
				}
			}
		}
		
		return result;
	}
	
	
	
	function runEventOfArrayWithState(args){
		runEvent({name: window[args.eventArrName][window[args.stateVarName].currentState]}, args);
	}
	
	
	
	function setVariableToValue(args){
		window[args.varName] = args.value;
	}
	
	function addValueToVariable(args){
		window[args.varName] += args.value;
	}
	function subtractValueFromVariable(args){
		window[args.varName] -= args.value;
	}
	function multiplyVariableByValue(args){
		window[args.varName] *= args.value;
	}
	function divideVariableByValue(args){
		window[args.varName] /= args.value;
	}
	
	function addToValueOfArray(args){
		window[args.arrName][args.index] += args.value;
	}
	function subtractFromValueOfArray(args){
		window[args.arrName][args.index] -= args.value;
	}
	function multipleValueOfArray(args){
		window[args.arrName][args.index] *= args.value;
	}
	function divideValueOfArray(args){
		window[args.arrName][args.index] /= args.value;
	}
	
	function getArrayMultiple(args){
		return Object.values(args).reduce((acc, value) => acc * value, 1);
	}
	
	function addValueToArray(args){
		window[args.arrName].push(args.value);
	}
	function removeIndexFromArray(args){
		window[args.arrName].splice(args.index, 1);
	}
	function removeValueFromArray(args){
		let i = window[args.arrName].indexOf(args.value);
		
		if (i > -1){
			window[args.arrName].splice(i, 1);
		}
	}
	
	
	
	
	function getIndexOfInventoryValue(args){
		return window[args.arrName].findIndex(item => item.value === args.value);
	}
	
	function refreshInventory(args){
		let arr = window[args.arrName];
		
		for (let i = 0; i < arr.length; i++){
			let index = getIndexOfInventoryValue({arrName: args.arrName, value: arr[i].value});
			
			if (index != i){
				window[args.arrName][index].amount += window[args.arrName][i].amount;
				window[args.arrName][i].amount = 0;
			}
			
			if (window[args.arrName][i].amount == 0){
				window[args.arrName].splice(i, 1);
				i--;
			}
		}
	}
	
	function removeValueFromInventory(args){
		let index = getIndexOfInventoryValue(args);
		
		if (index != -1){
			if (window[args.arrName][index].amount > 1){
				window[args.arrName][index].amount--;
			} else{
				window[args.arrName].splice(index, 1);
			}
		}
	}
	
	function addValueToInventory(args){
		let index = getIndexOfInventoryValue(args);
		
		if (index == -1){
			let arr = {value: args.value, amount: Math.floor(args.amount ?? 1)};
			
			if (args.index == undefined || args.index == -1){
				window[args.arrName].push(arr);
			} else{
				window[args.arrName].splice(args.index, 0, arr);
			}
		} else{
			window[args.arrName][index].amount += Math.floor(args.amount ?? 1);
		}
	}
	
	function operateValueOfInventory(args, operationType){
		let currentValue = window[args.arrName][args.index].value;
		
		let index = getIndexOfInventoryValue({arrName: args.arrName, value: currentValue});
		
		if (operationType == "+"){ currentValue += args.value; }
		if (operationType == "-"){ currentValue -= args.value; }
		if (operationType == "*"){ currentValue *= args.value; }
		if (operationType == "/"){ currentValue /= args.value; }
		if (operationType == "**"){ currentValue **= args.value; }
		
		if (index != -1){
			window[args.arrName][args.index].amount--;
		}
		
		addValueToInventory({...args, value: currentValue});
		
		refreshInventory(args);
	}
	
	function addToValueOfInventory(args){
		operateValueOfInventory(args, "+");
	}
	function subtractFromValueOfInventory(args){
		operateValueOfInventory(args, "-");
	}
	function multipleValueOfInventory(args){
		operateValueOfInventory(args, "*");
	}
	function divideValueOfInventory(args){
		operateValueOfInventory(args, "/");
	}
	function exponentiateValueOfInventory(args){
		operateValueOfInventory(args, "**");
	}
	
	function getInventoryValueSum(args){
		return Object.values(window[args.arrName]).reduce((acc, value) => acc + (value.value * value.amount), 0);
	}
	function getInventoryValueSumWithoutIndex(args){
		let num = 0;
		
		for (let i in window[args.arrName]){
			let value = window[args.arrName][i];
			
			if (i == args.index){
				let currentNum = value.value * Math.max(value.amount - 1, 0);
				
				if (!isNaN(currentNum)){
					num += currentNum;
				}
			} else{
				num += value.value * value.amount;
			}
		}
		return num;
	}
	
	function addRandomValuesToInventory(args){
		let percentages = [];
		
		for (let i = args.min; i <= args.max; i++){
			percentages.push(1 / (args.max - args.min + 1));
		}
		
		
		let valuesArr = getRandomOccurrencesFromPercentages(percentages, args.amount);
		
		for (let i in valuesArr){
			if (valuesArr[i] > 0){
				addValueToInventory({...args, value: Number(i) + args.min, amount: valuesArr[i]});
			}
		}
	}
	
	function replaceInventoryValueWithVariable(args){
		let variableValue = window[args.varName];
		
		window[args.varName] = args.value;
		
		removeValueFromInventory(args);
		
		addValueToInventory({...args, value: variableValue});
		
		refreshInventory(args);
	}
	
	function changeInventoryValueToEvalText(args){
		window[args.arrName][args.index].amount--;
		
		let value = functionEval(args.text);
		
		addValueToInventory({...args, value: value});
		
		refreshInventory(args);
	}
	
	
	
	function resetArray(args){
		window[args.arrName] = [];
	}
	function resetButtons(args){
		if (args.state == undefined || args.state == "all"){
			buttons = {};
		} else{
			buttons[args.state] = [];
		}
	}
	
	
	function getArraySum(args){
		let num = 0;
		
		for (let i in window[args.arrName]){
			num += window[args.arrName][i];
		}
		return num;
	}
	function getArraySumWithoutIndex(args){
		return getArraySum(args) - window[args.arrName][args.index];
	}
	
	
	function addButtonToCurrentGameState(args){
		buttons[gameState.currentState] ??= [];
		
		buttons[gameState.currentState].push(args);
	}
	function addButtonToOverlay(args){
		buttons["overlay"] ??= [];
		
		buttons["overlay"].push(args);
	}
	
	function addButtonsFromStateArray(args){
		let arr = window[args.arrName];
		
		let pos = structuredClone(args.pos);
		
		for (let i in arr.states){
			let button = structuredClone(args);
			
			button.text = arr.states[i];
			button.pos.x = pos.x;
			button.pos.y = pos.y;
			
			if ((arr.stateNum ?? 0) != i){
				button.isLocked = true;
			}
			
			if ((arr.stateNum ?? 0) == i && arr.currentState != arr.states[i]){
				button.text = arr.currentState;
			}
			
			buttons[args.state ?? gameState.currentState].push(button);
			
			pos.x += args.offset.x ?? 0;
			pos.y += args.offset.y ?? 0;
		}
	}
	
	
	var lastValue = 0;
	var lastValueIndexLength = 0;
	function getButtonsOfButtonsArray(arr, originalArr, indexArr = []){
		let currentArr = [];
		originalArr ??= arr;
		
		for (let i in arr.buttons){
			let button = {value: arr.buttons[i].value, gameState: arr.value};
			
			if (button.value == undefined){
				let indexText = indexArr.slice(lastValueIndexLength).join(",");
				
				button.value = lastValue + indexText + ((indexText.length > 0) ? "," : "") + i;
				button.gameState = lastValue + indexText;
				
				lastValueText = arr.buttons[i].text;
			} else{
				lastValue = button.value;
				lastValueIndexLength = indexArr.length + 1;
			}
			
			
			
			for (let j in arr.buttons[i]){
				if (j != "buttons" && j != "label"){
					button[j] = arr.buttons[i][j];
				}
			}
			
			button.gameState ??= arr.args.initialState;
			
			if (arr.buttons[i].label != undefined){
				let labelButton = {...originalArr.labelArgs, ...button};
				
				labelButton.text = arr.buttons[i].label;
				
				if (arr.buttons[i].id != undefined){
					labelButton.id = arr.buttons[i].id + "Label";
				}
				
				currentArr.push(labelButton);
			}
			
			if (arr.buttons[i].isLabel){
				button = {...button, ...originalArr.labelArgs};
			}
			
			currentArr.push(button);
			
			if (arr.buttons[i].buttons != undefined){
				currentArr.push(...getButtonsOfButtonsArray(arr.buttons[i], originalArr, [...indexArr, i]));
			}
		}
		
		return currentArr;
	}
	
	function addButtonsFromButtonsArray(args){
		let arr = window[args.arrName];
		
		let pos = structuredClone(arr.buttonArgs.pos);
		
		buttonsArr = getButtonsOfButtonsArray(arr);
		
		
		let buttonNums = {};
		let isBacks = {};
		
		for (let i in buttonsArr){
			let state = buttonsArr[i].gameState;
			
			if (buttons[state] == undefined){ buttons[state] = []; }
			if (buttonNums[state] == undefined){ buttonNums[state] = 0; }
			
			if (buttonsArr[i].isBack || buttonsArr[i].isFullyBack){
				isBacks[state] = true;
				
				if (buttonsArr[i].isFullyBack){
					if (buttonsArr[i].onclickGameState == undefined){
						buttonsArr[i].onclickGameState = arr.args.initialState;
					} else{
						buttonsArr[i].savePreviousState ??= false;
					}
				} else{
					buttonsArr[i].onclickGameState = "Back";
				}
			}
		}
		
		if (arr.args.backButton != undefined){
			for (let i in buttonNums){
				if (!containsExcludedWords(i, arr.args.backButton.excludedStates) && !isBacks[i]){
					buttonsArr.push({gameState: i, ...arr.args.backButton});
				}
			}
		}
		
		
		for (let i in buttonsArr){
			let state = buttonsArr[i].gameState;
			
			
			let buttonArgs = structuredClone(arr.buttonArgs);
			
			for (let j in buttonsArr[i]){
				if (j != "onclick" && j != "isBack" && j != "isFullyBack"){
					buttonArgs[j] = buttonsArr[i][j];
				}
			}
			
			buttonArgs.text ??= buttonsArr[i].value;
			
			buttonArgs.pos.y += buttonArgs.pos.margin.h * buttonNums[state];
			
			
			if (buttonsArr[i].onclick != undefined){
				buttonArgs.onclick = [buttonsArr[i].onclick, buttonArgs.onclick].flat();
			}
			
			if (buttonsArr[i].isBack){
				buttonsArr[i].value = arr.args.backButton.value;
			}
			
			if (buttons[buttonsArr[i].value] != undefined){
				buttonArgs.onclickGameState = buttonsArr[i].value;
			}
			
			
			
			buttons[buttonsArr[i].gameState].push(buttonArgs);
			
			
			buttonNums[state]++;
		}
	}
	
	
	function getRandomNum(args){
		return Math.floor(Math.random() * (args.max - args.min + 1) + args.min);
	}
	
	
	function randomizeArrayState(args){
		if (args.canRepeat){
			window[args.arrName].currentState = getRandomElementOfArray(window[args.arrName].states);
		} else{
			window[args.arrName].currentState = getRandomElementOfArrayWithoutRepeats(window[args.arrName].states, window[args.arrName].currentState);
		}
	}
	function incrementArrayState(args){
		let arr = window[args.arrName];
		
		arr.stateNum ??= 0;
		arr.stateNum++;
		
		let stateNum = arr.stateNum;
		let statesSize = arr.states.length;
		
		if (stateNum >= statesSize || stateNum < 0){
			arr.stateNum = modulo(stateNum, statesSize);
		}
		
		arr.currentState = arr.states[arr.stateNum];
	}
	function setArrayState(args){
		window[args.arrName].currentState = args.value;
	}
	
	
	function runEval(args){
		return functionEval(args.text, args);
	}
	
	function changeArrayBooleansByEvalText(args){
		for (let i in window[args.arrName]){
			args.currentArr = window[args.arrName][i];
			
			let boolValue = runEval(args);
			
			if (boolValue && args.shouldTurnOn != false){
				window[args.arrName][i][args.boolName] = true;
			}
			if (!boolValue && args.shouldTurnOff != false){
				window[args.arrName][i][args.boolName] = false;
			}
		}
	}
	
	function modifyArrayByEvalArray(args){
		let evalArr = window[args.evalArrName];
		
		if (args.evalArrIndex != undefined){
			evalArr = evalArr[args.evalArrIndex];
		}
		
		for (let i in evalArr){
			let indexText = "window[args.arrName]['" + i + "']";
			console.log(evalArr[i], i, evalArr);
			functionEval(indexText + " = " + indexText + evalArr[i], args);
		}
	}
	
</script>

<script> //General Hitbox Functions
	
	function isVertexInRect(v, r){
		return (v.x >= r.x && v.x <= r.x + r.w &&
				v.y >= r.y && v.y <= r.y + r.h);
	}
	
	function areRectsColliding(r1, r2){ //https://stackoverflow.com/a/16012490/12777947
		return (
			(r1.x < (r2.x + r2.w)) && (r1.y < (r2.y + r2.h)) &&
			(r2.x < (r1.x + r1.w)) && (r2.y < (r1.y + r1.h))
		);
	}
	
	function areLinesColliding1D(l1, l2){
		return (l1.end >= l2.start && l2.end >= l1.start);
	}
	
	function isVertexInPolygon(v, p){ //https://stackoverflow.com/a/36070256/12777947
		let j = p.length - 1;
		let odd = false;
		
		for (let i = 0; i < p.length; i++){
			if ((p[i].y < v.y && p[j].y >= v.y || p[j].y < v.y && p[i].y >= v.y) && (p[i].x <= v.x || p[j].x <= v.x)){
				odd ^= (p[i].x + (v.y - p[i].y) * (p[j].x - p[i].x) / (p[j].y - p[i].y)) < v.x;
			}
			j = i;
		}
		return odd;
	}
	
	function getVertexDistance(v1, v2){
		return Math.sqrt(Math.abs(v1.x - v2.x) ** 2 + Math.abs(v1.y - v2.y) ** 2);
	}
	
	function getVertexToRectDistance(v, r){ //https://stackoverflow.com/a/41286161
		let b = {left: r.x, right: r.x + r.w, top: r.y, bottom: r.y + r.h};
		
		let d = {x: 0, y: 0};
		
		if (v.x < b.left){
			d.x = b.left - v.x;
		} else if (v.x > b.right){
			d.x = b.right - v.x;
		}
		
		if (v.y < b.top){
			d.y = b.top - v.y;
		} else if (v.y > b.bottom){
			d.y = b.bottom - v.y;
		}
		
		return Math.sqrt(d.x ** 2 + d.y ** 2);
	}
	
	
	function getVertexToVertexRadians(v1, v2){
		let deltaX = v2.x - v1.x; 
		let deltaY = v2.y - v1.y;
		
		return Math.atan2(deltaY, deltaX);
	}
	
	function getVertexToVertexDirection(v1, v2){
		let radians = getVertexToVertexRadians(v1, v2);
		
		return {x: Math.cos(radians), y: Math.sin(radians)};
	}
	
	
	function isVertexInCircle(v, c){
		return (getVertexDistance(v, c) < c.w/2);
	}
	
	function areCirclesColliding(c1, c2){
		return (getVertexDistance(c1, c2) < (c1.w/2 + c2.w/2));
	}
	
	function isCircleFullyInsideCircle(c1, c2){
		return (getVertexDistance(c1, c2) < (c2.w/2 - c1.w/2));
	}
	
	
	function getRotatedVertex(pos, radians, center = {x: 0, y: 0}){ //https://stackoverflow.com/a/17411276/12777947
		return {
			x: (Math.cos(radians) * (pos.x - center.x)) - (Math.sin(radians) * (pos.y - center.y)) + center.x,
			y: (Math.cos(radians) * (pos.y - center.y)) + (Math.sin(radians) * (pos.x - center.x)) + center.y
		};
	}
	
	
	
	function isVertexInTopLeftHalfOfRect(v, rect = {x: 0, y: 0, w: 1, h: 1}){ //AI Generated
		let boundaryY = (-rect.h / rect.w) * (v.x - (rect.x + rect.w)) + rect.y;
		
		return v.y < boundaryY;
	}
	function isVertexInTopRightHalfOfRect(v, rect = {x: 0, y: 0, w: 1, h: 1}){ //AI Generated
		let boundaryY = (rect.h / rect.w) * (v.x - rect.x) + rect.y;
		
		return v.y < boundaryY;
	}
	function isVertexInBottomLeftHalfOfRect(v, rect){
		return !isVertexInTopRightHalfOfRect(v, rect);
	}
	function isVertexInBottomRightHalfOfRect(v, rect){
		return !isVertexInTopLeftHalfOfRect(v, rect);
	}
	
	
	function isRectInScreen(r){
		let screen = getScreenSize();
		
		return (areRectsColliding(r, screen.size.absolute));
	}
	
</script>

<script> //Grid
	
	function getGridFromArgs(args){
		let grid = args;
		
		if (grid.grid == undefined || grid.data == undefined){
			grid = (args.grid ?? window[args.gridName]) ?? window[args.arrName];
		}
		
		return grid;
	}
	
</script>
<script> //Grid Generation
	
	function generateEmptyGrid(args){
		let arr = getGridFromArgs(args);
		
		let gridShape = arr.data.gridShape ?? "rect";
		
		arr.grid = {};
		
		for (let i of arr.data.layers){
			arr.grid[i] = [];
			
			for (let y = 0; y < arr.data.gridSize.h; y++){
				arr.grid[i][y] = [];
				for (let x = 0; x < arr.data.gridSize.w; x++){
					arr.grid[i][y][x] = {};
				}
			}
		}
	}
	
	function generateGrids(){
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			generateEmptyGrid(grid);
			
			for (let j in grid.data.onload){
				arr = grid.data.onload[j];
				
				arr.args ??= {};
				arr.args.gridName ??= gridName;
				
				runEvent([arr]);
			}
			
			for (let j in grid.data.draw){
				grid.data.draw[j].args ??= {};
				grid.data.draw[j].args.gridName = gridName;
			}
			
			refreshGridDrawValues({gridName: gridName});
		}
	}
	
	
	function getGridMiddlePos(posArr, grid){
		let pos = {...posArr};
		
		if (pos.isMiddle){
			pos.y = Math.floor(grid.length/2) - Math.floor(pos.h/2);
			pos.x = Math.floor(grid[pos.y].length/2) - Math.floor(pos.w/2);
		}
		return pos;
	}
	
	function setValuesOnGridRandomly(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let exclusionPos = args.exclusionPos;
		
		let isExcluded = {};
		for (let k in exclusionPos){
			let pos = getGridMiddlePos(exclusionPos[k], grid);
			
			for (let i = 0; i < (pos.h ?? 1); i++){
				for (let j = 0; j < (pos.w ?? 1); j++){
					isExcluded[(pos.y + i) + ";" + (pos.x + j)] = true;
				}
			}
		}
		
		
		
		if (args.amount != undefined || args.amountRatio != undefined){
			let remainingAmount = args.amount ?? Math.floor(args.amountRatio * gridArr.data.gridSize.w * gridArr.data.gridSize.h);
			
			while (remainingAmount > 0){
				let randomPos = {
					x: getRandomNum({min: 0, max: grid[0].length - 1}),
					y: getRandomNum({min: 0, max: grid.length - 1})
				};
				
				if (!isExcluded[randomPos.y + ";" + randomPos.x]){
					isExcluded[randomPos.y + ";" + randomPos.x] = true;
					
					grid[randomPos.y][randomPos.x][args.value.name] = args.value.value;
					
					remainingAmount--;
				} else{
					if (grid.length * grid[0].length - objectLength(isExcluded) <= 0){
						remainingAmount = 0;
					}
				}
			}
		} else{
			for (let i in grid){
				for (let j in grid[i]){
					if (!isExcluded[i + ";" + j]){
						if (args.chance > Math.random()){
							grid[i][j][args.value.name] = args.value.value;
						}
					}
				}
			}
		}
	}
	
	function setValuesOnGridPositions(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let posArr = args.pos;
		
		if (isObject(posArr)){
			posArr = [posArr];
		}
		
		for (let k in posArr){
			let pos = getGridMiddlePos(posArr[k], grid);
			
			for (let i = 0; i < (pos.h ?? 1); i++){
				for (let j = 0; j < (pos.w ?? 1); j++){
					grid[pos.y + i][pos.x + j] = (!args.shouldReplace) ? {...grid[pos.y + i][pos.x + j], ...args.value} : {...args.value};
				}
			}
		}
	}
	
	function setValuesOnGridFromArray(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let arr = window[args.arrName];
		
		let pos = {x: 0, y: 0};
		for (let i = 0; i < arr.length; i++){
			
			let value = arr[i];
			
			if (args.value != undefined){
				value = {[args.value.name]: arr[i]};
			}
			
			grid[pos.y][pos.x] = (!args.shouldReplace) ? {...grid[pos.y][pos.x], ...value} : {...value};
			
			
			pos.x++;
			
			if (grid[pos.y][pos.x] == undefined){
				pos.x = 0;
				pos.y++;
				
				if (grid[pos.y] == undefined){
					break;
				}
			}
		}
	}
	
	
	function countValuesInGrid(args){
		let gridArr = getGridFromArgs(args);
		
		let grid = gridArr.grid[args.layer ?? gridArr.data.layers[0]];
		
		let num = 0;
		
		for (let i in grid){
			for (let j in grid[i]){
				if (grid[i][j][args.value.name] == args.value.value){
					num++;
				}
			}
		}
		return num;
	}
	
</script>
<script> //Grid Neighbor
	
	/*
	rect
	0 1 2 3 4 5 6
	. . . . . . .
	. . . . . . .
	. . . . . . .
	. . . . . . .
	. . . . . . .
	
	hex (even indices are "pushed" 0.5 to the right)
	0 1 2 3 4 5 6
	 . . . . . . .
	. . . . . . .
	 . . . . . . .
	. . . . . . .
	 . . . . . . .
	
	tri (neighbors different, even indices start with upwards pointing triangles)
	0123456
	▲▼▲▼▲▼▲
	▼▲▼▲▼▲▼
	▲▼▲▼▲▼▲
	▼▲▼▲▼▲▼
	▲▼▲▼▲▼▲
	*/
	
	function getTileNeighborPositions(i, j, grid, gridShape = "rect"){
		let offsets = [];
		
		switch (gridShape){
			case "rect": {
				offsets = [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: -1, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}];
			} break;
			case "hex": {
				let horizontalOffset = (i % 2 == 0) ? 1 : -1;
				
				offsets = [{x: 0, y: -1}, {x: horizontalOffset, y: -1}, {x: -1, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: horizontalOffset, y: 1}];
			} break;
			case "tri": {
				let verticalOffset = ((i + j) % 2 == 0) ? 1 : -1;
				
				offsets = [{x: 0, y: verticalOffset}, {x: -1, y: 0}, {x: 1, y: 0}];
			} break;
		}
		
		
		let posArr = [];
		
		for (let offset of offsets){
			let pos = {x: j + offset.x, y: i + offset.y};
			
			if (grid[pos.y] != undefined){
				if (grid[pos.y][pos.x] != undefined){
					posArr.push(pos);
				}
			}
		}
		
		return posArr;
	}
	
	function incrementGridValuesFromNeighborValues(args){
		let arr = getGridFromArgs(args);
		
		let grid = arr.grid[args.layer ?? arr.data.layers[0]];
		
		for (let i = 0; i < grid.length; i++){
			for (let j = 0; j < grid[i].length; j++){
				let num = 0;
				
				let posArr = getTileNeighborPositions(i, j, grid, arr.data.gridShape);
				
				for (let pos of posArr){
					if (grid[pos.y][pos.x][args.neighborValue.name] == args.neighborValue.value){
						num++;
					}
				}
				
				if (!args.shouldReplace){
					grid[i][j][args.value] ??= 0;
					grid[i][j][args.value] += num;
				} else{
					grid[i][j][args.value] = num;
				}
			}
		}
	}
	
</script>
<script> //Grid Hitbox
	
	function getVertexPositionInGrid(v, grid, layerName){
		let gridShape = grid.data.gridShape;
		
		let pos = {...grid.data};
		
		let offsets = getGridOffset(grid);
		
		if (grid.data.isCentered != false){
			pos.x -= offsets.w * grid.data.gridSize.w / 2;
			pos.y -= offsets.h * grid.data.gridSize.h / 2;
		}
		
		
		let tilePos = {...pos};
		
		if (gridShape == "hex"){
			tilePos.w += pos.gaps.left + pos.gaps.right
			tilePos.h += pos.gaps.up + pos.gaps.down;
			
			tilePos.y -= tilePos.h * 0.0775; //Same as: tilePos.h * 0.155 / 2
			tilePos.w /= 2;
			tilePos.h = tilePos.h * 0.86625; //Same as: tilePos.h / 2 * 1.155 * 1.5;
			tilePos.h /= 3;
		}
		if (gridShape == "tri"){
			tilePos.w /= 2;
		}
		
		if (gridShape != "hex"){
			tilePos.w += pos.gaps.left + pos.gaps.right
			tilePos.h += pos.gaps.up + pos.gaps.down;
		}
		
		
		let vertexPos = {
			x: Math.floor((v.x - tilePos.x) / tilePos.w),
			y: Math.floor((v.y - tilePos.y) / tilePos.h)
		}
		
		if (gridShape == "hex"){
			vertexPos.x /= 2;
			vertexPos.y /= 3;
			
			vertexPos.x -= (Math.floor(vertexPos.y) % 2 == 0) ? 0.5 : 0;
		}
		
		if (gridShape == "hex"){
			if (vertexPos.y % 1 > 0){
				vertexPos.x = Math.floor(vertexPos.x);
				vertexPos.y = Math.floor(vertexPos.y);
			} else{
				let vertexPosInBox = {
					x: ((v.x - tilePos.x) / tilePos.w) % 1,
					y: ((v.y - tilePos.y) / tilePos.h) % 1
				}
				
				if (Math.abs(vertexPos.x) % 1 < 0.5){ //true is top left corner of hexagon, false is top right
					if (isVertexInTopLeftHalfOfRect(vertexPosInBox)){
						vertexPos.y--;
						
						if (Math.floor(vertexPos.y) % 2 == 0){
							vertexPos.x--;
						}
					}
				} else{
					if (isVertexInTopRightHalfOfRect(vertexPosInBox)){
						vertexPos.y--;
						
						if (Math.floor(vertexPos.y) % 2 != 0){
							vertexPos.x++;
						}
					}
				}
				
				vertexPos.x = Math.floor(vertexPos.x);
			}
		}
		if (gridShape == "tri"){
			let vertexPosInBox = {
				x: ((v.x - tilePos.x) / tilePos.w) % 1,
				y: ((v.y - tilePos.y) / tilePos.h) % 1
			}
			
			if ((vertexPos.x + vertexPos.y) % 2 == 0){
				if (isVertexInTopLeftHalfOfRect(vertexPosInBox)){
					vertexPos.x--;
				}
			} else{
				if (isVertexInBottomLeftHalfOfRect(vertexPosInBox)){
					vertexPos.x--;
				}
			}
		}
		
		
		let isInGrid = false;
		if (grid.grid[layerName][vertexPos.y] != undefined){
			if (grid.grid[layerName][vertexPos.y][vertexPos.x] != undefined){
				isInGrid = true;
			}
		}
		
		if (!isInGrid){
			vertexPos = {x: -1, y: -1};
		}
		
		return vertexPos;
	}
	
</script>
<script> //Grid Click
	
	function gridClick(args){
		clickedGridTile = {gridName: "", layer: "", pos: {x: -1, y: -1}, isDown: false, mouseButton: args.mouseButton, lastOnDownPos: clickedGridTile.lastOnDownPos, isUp: args.isUp};
		
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (grid.data.gameState == gameState.currentState || grid.data.gameState == undefined){
				for (let layerName in grid.grid){
					let pos = getVertexPositionInGrid(scaledMousePos, grid, layerName);
					
					if (pos.y != -1){
						if (args.isDown){
							clickedGridTile.lastOnDownPos = structuredClone(pos);
						}
						clickedGridTile = {...clickedGridTile, gridName: gridName, layer: layerName, pos: pos, isDown: args.isDown, mouseButton: args.mouseButton};
					}
				}
			}
		}
		
		let arr = clickedGridTile;
		
		if (arr.pos.y != -1){
			let grid = window[arr.gridName];
			
			let isClicked = (args.isUp && arr.pos.x == arr.lastOnDownPos.x && arr.pos.y == arr.lastOnDownPos.y);
			
			if (grid.data.isFastClick){
				isClicked = (arr.isDown);
			}
			
			
			if (isClicked){
				let tile = grid.grid[arr.layer][arr.pos.y][arr.pos.x];
				let extraArgs = {layer: arr.layer, pos: arr.pos, mouseButton: arr.mouseButton};
				
				let fullArgs = {...args, ...tile, ...extraArgs};
				
				let value = getConditionalArrayValue(grid.data.onclick, fullArgs);
				
				for (let i in value){
					if ((value[i] + "").includes("<<")){
						value[i] = functionEval(value[i].replaceAll("<<","").replaceAll(">>",""), fullArgs);
					}
				}
				
				grid.grid[arr.layer][arr.pos.y][arr.pos.x] = {...tile, ...value};
				
				refreshGridDrawValues({gridName: clickedGridTile.gridName});
			}
		}
	}
	
</script>

<script> //Buttons
	
	function generateButtons(args){
		let arr = window[args.arrName];
		
		for (let i = 0; i < arr.length; i++){
			let y = Math.floor(i / args.grid.w);
			let x = i % args.grid.w;
			
			let button = structuredClone(args.button) ?? {};
			
			
			let buttonSize = {
				w: args.pos.w + args.pos.margin.w,
				h: args.pos.h + args.pos.margin.h
			};
			
			button.pos = {
				x: args.pos.x + ((x > 0) ? buttonSize.w * x : 0), //works with Infinity buttonSize
				y: args.pos.y + ((y > 0) ? buttonSize.h * y : 0),
				w: args.pos.w,
				h: args.pos.h
			};
			
			if (args.isCentered){
				if (args.grid.w != undefined){
					button.pos.x = args.pos.x - (buttonSize.w * (args.grid.w - 1) / 2) + buttonSize.w * x;
				}
				
				if (args.grid.h != undefined){
					button.pos.y = args.pos.y - (buttonSize.h * (args.grid.h - 1) / 2) + buttonSize.h * y;
				}
			}
			
			let value = (isObject(arr[i])) ? arr[i].value : arr[i];
			
			let argsArr = {index: i, value: value};
			
			if (isObject(arr[i])){
				for (let j in arr[i]){
					if (argsArr[j] == undefined){
						argsArr[j] = arr[i][j];
					}
				}
			}
			
			button = getArrayWithReplacedValues(button, argsArr);
			
			let onclickArgs = button.onclick.args;
			
			if (onclickArgs != undefined){
				if (onclickArgs[0] == "{" && onclickArgs[onclickArgs.length - 1] == "}"){
					button.onclick.args = functionEval(onclickArgs);
				}
			}
			
			buttons[args.gameState] ??= [];
			buttons[args.gameState].push(button);
		}
	}
	
	
	function changeButtonArgsById(id, args){
		for (let i in buttons){
			for (let j in buttons[i]){
				let hasId = false;
				
				let idArr = buttons[i][j].id;
				if (!isArray(idArr)){ idArr = [idArr]; }
				
				for (let k in idArr){
					if (idArr[k] == id){
						hasId = true;
					}
				}
				
				if (hasId){
					for (let k in args){
						buttons[i][j][k] = structuredClone(args[k]);
					}
				}
			}
		}
	}
	
	function removeButtonsById(id){
		for (let i in buttons){
			for (let j = 0; j < buttons[i].length; j++){
				let hasId = false;
				
				let idArr = buttons[i][j].id;
				if (!isArray(idArr)){ idArr = [idArr]; }
				
				for (let k in idArr){
					if (idArr[k] == id){
						hasId = true;
					}
				}
				
				if (hasId){
					buttons[i].splice(j, 1);
					
					j--;
				}
			}
		}
	}
	
</script>
<script> //Buttons Click
	
	function buttonsClick(isDown, isHover){
		closestButton = {i: "", j: 0, distance: -1};
		
		let i = gameState.currentState;
		
		let currentButtons = [...(buttons[i] ?? [])];
		
		if (buttons["overlay"] != undefined){
			currentButtons.push(...buttons["overlay"]);
		}
		
		for (let j = 0; j < currentButtons.length; j++){
			let button = {...currentButtons[j]};
			
			if (!button.disableClick && !(button.isLocked && button.hideLocked) && !(button.isHidden && button.lockHidden != false)){
				let scaledPos = getScaledPosition(button.pos, {isAbsolutePositioned: button.isAbsolutePositioned});
				
				if (button.isCentered != false){
					scaledPos = getCenteredPosition(scaledPos);
				}
				
				let distance = getVertexToRectDistance(mousePos, scaledPos);
				
				if (isVertexInRect(mousePos, scaledPos)){
					if (isHover){
						closestButton = {i: i, j: j, distance: distance, isHover: true, isLocked: button.isLocked};
					} else{
						if (!button.isLocked){
							if (isDown){
								clickedButton = {i: i, j: j};
							} else{
								if (clickedButton.i === i && clickedButton.j === j){
									
									if (button.toggle != undefined){
										let arr = (window[button.toggleArrName] ?? window);
										
										let boolValue = !arr[button.toggle.value];
										
										if (boolValue && button.toggle.shouldTurnOn != false){
											arr[button.toggle.value] = true;
										}
										if (!boolValue && button.toggle.shouldTurnOff != false){
											arr[button.toggle.value] = false;
										}
									}
									
									
									let arr = button.onclick;
									
									if (arr != undefined){
										if (!isArray(arr)){
											arr = [arr];
										}
										
										runEvent(arr);
										
										if (button.onclickGameState != undefined){
											
											let nextState = button.onclickGameState;
											
											gameState.previousStates ??= {};
											
											if (nextState == "Back"){
												nextState = gameState.previousStates[gameState.currentState] ?? gameState.states[0];
											} else if (button.savePreviousState != false){
												gameState.previousStates[nextState] = gameState.currentState;
											}
											
											gameState.currentState = nextState;
										}
										
										
										let multiplier = (button.hoverReleaseMultiplier ?? hoveredButtons.releaseMultiplier);
										
										hoveredButtons.arr[clickedButton.j] = hoveredButtons.maxSeconds * multiplier;
										
										closestButton = {i: i, j: j, distance: distance, isHover: true};
									}
								}
							}
						} else{
							closestButton = {i: i, j: j, distance: distance, isHover: true, isLocked: true};
						}
					}
				} else{
					if (distance < closestButton.distance || closestButton.distance == -1){
						closestButton = {i: i, j: j, distance: distance};
					}
				}
			}
		}
	}
	
</script>
<script> //Scrollbars
	
	function getScreenSize(){
		let screen = {
			pixelSize: {
				relative: getCanvasScaledPositions({x: 0, y: 0, w: 1, h: 1/camera.minWidthToHeightRatio}),
				absolute: {x: 0, y: 0, w: canvas.width, h: canvas.height}
			}
		};
		
		screen.size = {
			relative: {
				w: (1 / camera.zoom.level),
				h: ((1 / camera.zoom.level) / camera.minWidthToHeightRatio),
			}
		}
		
		screen.size.absolute = {
			w: (screen.pixelSize.absolute.w / screen.pixelSize.relative.w) * screen.size.relative.w,
			h: (screen.pixelSize.absolute.h / screen.pixelSize.relative.h) * screen.size.relative.h
		};
		
		if (!camera.areDimentionsEqual){
			screen.size.relative = {
				w: screen.size.absolute.w,
				h: screen.size.absolute.h
			};
		}
		
		screen.size.relative.x = (-camera.x) - screen.size.relative.w/2;
		screen.size.relative.y = (-camera.y) - screen.size.relative.h/2;
		
		screen.size.absolute.x = (-camera.x) - screen.size.absolute.w/2;
		screen.size.absolute.y = (-camera.y) - screen.size.absolute.h/2;
		
		return screen;
	}
	
	function refreshScrolledCamera(forceCalculate){
		if (!scrolledCamera.hasCalculated || forceCalculate){
			let state = gameState.currentState;
			
			scrolledCamera = {...camera};
			
			if (scrolledCameras[gameState.currentState] != undefined){
				scrolledCamera = {...scrolledCameras[gameState.currentState]};
			}
			
			scrolledCamera.hasCalculated = true;
			
			
			let scrollbar = scrollbarsArr[gameState.currentState];
			
			if (scrollbar != undefined){
				
				let screen = getScreenSize();
				
				if (scrollbar.x != undefined){
					let sectionSize = Math.abs(scrollbar.x.end - scrollbar.x.start);
					let size = screen.size.absolute.w / sectionSize;
					
					let middlePos = -(scrollbar.x.end + scrollbar.x.start) / 2;
					
					if (Math.abs(size) < 1){
						let cameraLeft = -(scrolledCamera.x + screen.size.absolute.w/2);
						let cameraRight = -(scrolledCamera.x - screen.size.absolute.w/2);
						
						if (cameraLeft < scrollbar.x.start){
							scrolledCamera.x = (-scrollbar.x.start - screen.size.absolute.w/2);
						}
						
						if (cameraRight > scrollbar.x.end){
							scrolledCamera.x = (-scrollbar.x.end + screen.size.absolute.w/2);
						}
					} else{
						if (scrolledCameras[gameState.currentState] != undefined){
							scrolledCameras[gameState.currentState].x = middlePos;
						}
						
						scrolledCamera.x = middlePos;
					}
				}
				
				if (scrollbar.y != undefined){
					let sectionSize = Math.abs(scrollbar.y.end - scrollbar.y.start);
					let size = screen.size.absolute.h / sectionSize;
					
					let middlePos = -(scrollbar.y.end + scrollbar.y.start) / 2;
					
					if (Math.abs(size) < 1){
						let cameraTop = -(scrolledCamera.y + screen.size.absolute.h/2);
						let cameraBottom = -(scrolledCamera.y - screen.size.absolute.h/2);
						
						if (cameraTop < scrollbar.y.start){
							scrolledCamera.y = (-scrollbar.y.start - screen.size.absolute.h/2);
						}
						
						if (cameraBottom > scrollbar.y.end){
							scrolledCamera.y = (-scrollbar.y.end + screen.size.absolute.h/2);
						}
					} else{
						if (scrolledCameras[gameState.currentState] != undefined){
							scrolledCameras[gameState.currentState].y = middlePos;
						}
						
						scrolledCamera.y = middlePos;
					}
				}
			}
		}
	}
	
	function getScrollbarsPos(){
		let pos = {};
		
		let scrollbar = scrollbarsArr[gameState.currentState];
		
		if (scrollbar != undefined){
			refreshScrolledCamera(true);
			
			let screen = getScreenSize();
			
			if (scrollbar.x != undefined){
				let sectionSize = Math.abs(scrollbar.x.end - scrollbar.x.start);
				let size = screen.size.absolute.w / sectionSize;
				
				if (Math.abs(size) < 1){
					let cameraLeft = -(scrolledCamera.x + screen.size.absolute.w/2);
					
					let x = ((cameraLeft - scrollbar.x.start) / (sectionSize + screen.size.absolute.w));
					
					x *= (1 + size);
					
					pos.x = {y: 1 - scrollbarsSize.h, x: x, h: scrollbarsSize.h, w: Math.abs(size)};
					
					pos.w = {y: 1 - scrollbarsSize.h, x: 0, h: scrollbarsSize.h, w: 1};
				}
			}
			
			if (scrollbar.y != undefined){
				let sectionSize = Math.abs(scrollbar.y.end - scrollbar.y.start);
				let size = screen.size.absolute.h / sectionSize;
				
				if (Math.abs(size) < 1){
					let cameraTop = -(scrolledCamera.y + screen.size.absolute.h/2);
					
					let y = ((cameraTop - scrollbar.y.start) / (sectionSize + screen.size.absolute.h));
					
					y *= (1 + size);
					
					pos.y = {x: 1 - scrollbarsSize.w, y: y, w: scrollbarsSize.w, h: Math.abs(size)};
					
					pos.h = {x: 1 - scrollbarsSize.w, y: 0, w: scrollbarsSize.w, h: 1};
				}
			}
		}
		
		for (let i of xyArr){
			if (pos[i] != undefined){
				pos[i].x += scrollbarMargin.x;
				pos[i].y += scrollbarMargin.y;
				pos[i].w -= scrollbarMargin.x * 2;
				pos[i].h -= scrollbarMargin.y * 2;
			}
		}
		return pos;
	}
	
	
	function getCameraPosFromScrollbarPos(pos){
		refreshScrolledCamera(true);
		let screen = getScreenSize();
		
		let scrollbar = scrollbarsArr[gameState.currentState];
		
		let cameraPos = {};
		
		for (let xy of xyArr){
			if (pos[xy] != undefined){
				let wh = xyToWH[xy];
				
				let startPos = -scrollbar[xy].start - screen.size.absolute[wh]/2;
				
				let sectionSize = Math.abs(scrollbar[xy].end - scrollbar[xy].start);
				
				let ratio = (pos[xy][xy] - pos[wh][xy] - scrollbarMargin[xy]) / (pos[wh][wh] - pos[xy][wh] - scrollbarMargin[xy]*2);
				
				cameraPos[xy] = startPos - ((sectionSize - screen.size.absolute[wh]) * ratio);
			}
		}
		return cameraPos;
	}
	
	
	
	function setScrollbarsToGrids(args){
		let arr = {x: {}, y: {}};
		
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (args.state == grid.data.gameState){
				let pos = structuredClone(grid.data);
				let offsets = getGridOffset(grid);
				
				if (grid.data.isCentered != false){
					pos.x -= offsets.w * grid.data.gridSize.w / 2;
					pos.y -= offsets.h * grid.data.gridSize.h / 2;
				}
				
				for (let layerName in grid.grid){
					let currentGrid = grid.grid[layerName];
					
					let gridBounds = {x: pos.x, y: pos.y, w: offsets.w * currentGrid[0].length, h: offsets.h * currentGrid.length};
					
					if (grid.data.gridShape == "tri"){
						gridBounds.w += pos.w/2;
					}
					if (grid.data.gridShape == "hex"){
						gridBounds.w += offsets.w/2;
						gridBounds.h += offsets.h/4 + offsets.h/10;
						gridBounds.y -= offsets.h/10;
					}
					
					arr.x.start ??= gridBounds.x;
					arr.y.start ??= gridBounds.y;
					arr.x.end ??= gridBounds.x + gridBounds.w;
					arr.y.end ??= gridBounds.y + gridBounds.h;
					
					arr.x.start = Math.min(gridBounds.x, arr.x.start);
					arr.y.start ??= Math.min(gridBounds.y, arr.y.start);
					arr.x.end ??= Math.max(gridBounds.x + gridBounds.w, arr.x.end);
					arr.y.end ??= Math.max(gridBounds.y + gridBounds.h, arr.y.end);
				}
			}
		}
		
		if (arr.x.start != undefined){
			let margin = args.margin ?? {left: 0.5, right: 0.5, up: 0.5, down: 0.5};
			
			arr.x.start -= margin.left;
			arr.y.start -= margin.up;
			arr.x.end += margin.right;
			arr.y.end += margin.down;
			
			scrollbarsArr[args.state] = arr;
		}
	}
	
</script>
<script> //Scrollbars Click
	
	function isScrollbarPosTouchingMouse(pos, xy){
		let isTouching = isVertexInRect(mousePosRatio, pos[xy]);
		
		if (!isTouching){
			let wh = xyToWH[xy];
			
			if ((scrollbarsMinSize[xy] ?? {})[wh] != undefined){
				let currentPos = getScrollbarsPosDrawSize(pos, xy);
				
				isTouching = isVertexInRect(mousePosRatio, currentPos);
			}
		}
		return isTouching;
	}
	
	function scrollbarsClick(isDown, isHover){
		let pos = getScrollbarsPos();
		
		for (let xy of xyArr){
			if (pos[xy] != undefined){
				if (isDown){
					if (isScrollbarPosTouchingMouse(pos, xy)){
						clickedScrollbar = {xy: xy, clickedPos: {...mousePosRatio}};
						
						hoveredScrollbars.arr[xy] = hoveredScrollbars.maxSeconds * hoveredScrollbars.releaseMultiplier;
					}
				} else{
					if (isHover){
						if (clickedScrollbar.xy == xy){
							let offset = {
								x: mousePosRatio.x - clickedScrollbar.clickedPos.x,
								y: mousePosRatio.y - clickedScrollbar.clickedPos.y
							}
							
							clickedScrollbar = {xy: xy, clickedPos: {...mousePosRatio}};
							
							pos[xy][xy] += offset[xy];
							
							if (scrolledCameras[gameState.currentState] == undefined){
								scrolledCameras[gameState.currentState] = structuredClone(camera);
							}
							
							scrolledCameras[gameState.currentState][xy] = getCameraPosFromScrollbarPos(pos)[xy];
						}
					}
				}
			}
		}
	}
	
</script>
<script> //Editable Polygons Click
	
	function savedPolygonsClick(isDown = true){
		let previousClickedPolygons = clickedPolygons;
		
		clickedPolygonVertex = {i: -1, layer: "", j: -1, type: ""};
		clickedPolygons = [];
		
		for (let i in savedPolygons){
			for (let layer in savedPolygons[i]){
				if (savedPolygons[i][layer].length > 0){
					if (isDown){
						if (savedPolygons[i][layer][0].args.isEditable && shouldEditPolygons){
							for (let j in savedPolygons[i][layer]){
								let posArr = {
									vertex: savedPolygons[i][layer][j],
									front: savedPolygons[i][layer][j].front,
									back: savedPolygons[i][layer][j].back
								};
								
								for (let k in posArr){
									if (posArr[k] != undefined){
										let pos = {
											x: posArr[k].x - 5,
											y: posArr[k].y - 5,
											w: 10,
											h: 10
										}
										
										if (isVertexInRect(mousePos, pos)){
											if (savedPolygons[i][layer][j].args.canEditEdges != false || k != "vertex" || (j != 0 && j != savedPolygons[i][layer].length - 1)){
												clickedPolygonVertex = {i: i, layer: layer, j: j, type: k};
											}
										}
									}
								}
							}
						}
					}
					
					if (savedPolygons[i][layer][0].args.isClickable && shouldClickPolygons){
						if (isVertexInPolygon(mousePos, savedPolygons[i][layer])){
							if (isDown){
								clickedPolygons.push({i: i, layer: layer, isDown: isDown});
							} else{
								for (let j in previousClickedPolygons){
									if (previousClickedPolygons[j].i == i){
										clickedPolygons.push({i: i, layer: layer, isDown: isDown});
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	function savedPolygonsMove(){
		let polygonArgs = savedPolygons[clickedPolygonVertex.i][clickedPolygonVertex.layer][clickedPolygonVertex.j].args;
		
		let polygonArr = {base: [{x: mousePos.x, y: mousePos.y}]};
		
		let polygonPos = getCalculatedPolygonInverted(polygonArr, polygonArgs).base[0];
		
		for (let i in entities){
			if (entities[i].id == polygonArgs.id){
				let entityArr = entities[i].pos.arr;
				
				if ((entityArr[0] ?? {}).x != undefined){
					entityArr = entityArr[clickedPolygonVertex.j];
				} else{
					entityArr = entityArr[clickedPolygonVertex.layer][clickedPolygonVertex.j];
				}
				
				if (clickedPolygonVertex.type != "vertex"){
					let vertexPos = entityArr;
					let oppositeEntityArr = entityArr[(clickedPolygonVertex.type == "front") ? "back" : "front"];
					entityArr = entityArr[clickedPolygonVertex.type];
					
					if (((inputs["ControlLeft"] || inputs["ControlRight"]) ?? false) != isCurveSymmetryDefault){
						let changePos = {
							x: vertexPos.x - entityArr.x,
							y: vertexPos.y - entityArr.y
						};
						
						if (oppositeEntityArr != undefined){
							oppositeEntityArr.x = vertexPos.x + changePos.x;
							oppositeEntityArr.y = vertexPos.y + changePos.y;
						}
					}
				} else{
					let changePos = {
						x: polygonPos.x - entityArr.x,
						y: polygonPos.y - entityArr.y
					};
					
					if (entityArr.front != undefined){
						entityArr.front.x += changePos.x;
						entityArr.front.y += changePos.y;
					}
					if (entityArr.back != undefined){
						entityArr.back.x += changePos.x;
						entityArr.back.y += changePos.y;
					}
				}
				
				entityArr.x = polygonPos.x;
				entityArr.y = polygonPos.y;
			}
		}
	}
	
</script>

<script> //Grid & Button Hover
	
	function gridHoverNextFrame(){
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (grid.data.gameState == gameState.currentState || grid.data.gameState == undefined){
				let arr = grid.data.hover;
				
				if (arr != undefined){
					let currentHoverPos = "";
					
					if (clickedGridTile.gridName == gridName){
						currentHoverPos = clickedGridTile.layer + ";" + clickedGridTile.pos.x + ";" + clickedGridTile.pos.y;
					}
					
					for (let j in arr.tiles){
						if (j != currentHoverPos || arr.tiles[j] > arr.time){
							arr.tiles[j] -= 1/fps * (arr.fadeOutMultiplier ?? 1);
							
							if (arr.tiles[j] <= 0){
								delete arr.tiles[j];
							}
						}
					}
					
					if (currentHoverPos != ""){
						arr.tiles[currentHoverPos] ??= 0;
						
						if (clickedGridTile.isDown){
							arr.tiles[currentHoverPos] = arr.time * arr.clickMultiplier;
						} else{
							if (arr.tiles[currentHoverPos] < arr.time){
								arr.tiles[currentHoverPos] += 1/fps * (arr.fadeInMultiplier ?? 1);
								
								arr.tiles[currentHoverPos] = Math.min(arr.tiles[currentHoverPos], arr.time);
							}
						}
					}
				}
			}
		}
	}
	
	function buttonHoverNextFrame(){
		if (hoveredButtons.gameState != gameState.currentState){
			hoveredButtons.gameState = gameState.currentState;
			hoveredButtons.arr = [];
		}
		
		let name = (clickedButton.i == "") ? closestButton.j : clickedButton.j;
		
		let hoveredIndex = -1;
		
		if (closestButton.isHover && closestButton.i == gameState.currentState){
			if (!(hoveredButtons.arr[name] > hoveredButtons.maxSeconds)){
				hoveredButtons.arr[name] ??= 0;
				
				hoveredButtons.arr[name] += 1/fps;
				
				hoveredButtons.arr[name] = Math.min(hoveredButtons.maxSeconds, hoveredButtons.arr[name]);
				
				hoveredIndex = name;
			}
		}
		
		for (let i in hoveredButtons.arr){
			if (hoveredButtons.arr[i] > 0 && i != hoveredIndex){
				hoveredButtons.arr[i] -= 1/fps;
				
				hoveredButtons.arr[i] = Math.max(0, hoveredButtons.arr[i]);
			}
		}
		
		if (clickedButton.i == gameState.currentState){
			let button = buttons[clickedButton.i][clickedButton.j];
			
			if (button == undefined){
				button = buttons["overlay"][clickedButton.j - buttons[clickedButton.i].length];
			}
			
			let multiplier = (button.clickHoverMultiplier ?? hoveredButtons.clickMultiplier);
			
			hoveredButtons.arr[name] = hoveredButtons.maxSeconds * multiplier;
		}
	}
	
</script>

<script> //Keyboard/Gamepad Axis Inputs
	
	function getKeyboardMovementAxes(axes){
		for (let xy of xyArr){
		
			for (let key of keyboardAxes[xy].negative){
				if (inputs[key]){
					axes[xy] = -1;
				}
			}
			
			for (let key of keyboardAxes[xy].positive){
				if (inputs[key]){
					axes[xy] = 1;
				}
			}
		}
		return axes;
	}
	
	function getGamepadDpadAxes(axes){
		for (let gamepad of gamepads){
			if (gamepad != null){
				for (let xy of xyArr){
					for (let key of gamepadDpadAxes[xy].negative){
						if (gamepad.buttons[key] != undefined){
							if (gamepad.buttons[key].pressed){
								axes[xy] = -1;
							}
						}
					}
					
					for (let key of gamepadDpadAxes[xy].positive){
						if (gamepad.buttons[key] != undefined){
							if (gamepad.buttons[key].pressed){
								axes[xy] = 1;
							}
						}
					}
				}
			}
		}
		return axes;
	}
	
	function getGamepadMovementAxes(axes){
		for (let gamepad of gamepads){
			if (gamepad != null){
				
				let directionSigns = {
					x: ((gamepad.axes[0] < 0) ? -1 : 1),
					y: ((gamepad.axes[1] < 0) ? -1 : 1)
				}
				
				let speeds = {
					x: Math.abs(gamepad.axes[0]) - gamepadAxisRange.min,
					y: Math.abs(gamepad.axes[1]) - gamepadAxisRange.min
				}
				
				let maxSpeed = (gamepadAxisRange.max - gamepadAxisRange.min);
				
				for (let xy of xyArr){
					if (speeds[xy] > maxSpeed){ speeds[xy] = maxSpeed; }
					
					if (speeds[xy] > 0){
						axes[xy] = (1 / maxSpeed) * speeds[xy] * directionSigns[xy];
					}
				}
			}
		}
		return axes;
	}
	
</script>
<script> //Keyboard/Gamepad Button Inputs
	
	function refreshButtonPressStates(){
		inputButtonStates = {};
		
		for (let buttonName in inputButtons){
			let button = inputButtons[buttonName];
			
			
			let isConditionFulfilled = true;
			
			if (button.condition != undefined){
				isConditionFulfilled = functionEval(button.condition);
			}
			
			
			if (isConditionFulfilled){
				let isPressed = false;
				
				let pressedNum;
				
				for (let i in button.keyboard){
					if (inputs[button.keyboard[i]]){
						isPressed = true;
						pressedNum = i;
					}
				}
				
				for (let gamepadNum in button.gamepads){
					let gamepad = gamepads[gamepadNum];
					
					if (gamepad != null){
						
						for (let i in button.gamepads[gamepadNum]){
							if (gamepad.buttons[button.gamepads[gamepadNum][i]] != undefined){
								if (gamepad.buttons[button.gamepads[gamepadNum][i]].pressed){
									isPressed = true;
									pressedNum = i;
								}
							}
						}
					}
				}
				
				let isDelayed = false;
				
				if (button.timer > 0){
					if (isPressed){
						isDelayed = true;
						
						button.timer--;
					} else{
						button.timer = 0;
					}
				}
				
				if (button.disableHold){
					if (pressedNum == button.previousPressedNum){
						isDelayed = true;
					}
				}
				
				if (!isDelayed && isPressed){
					inputButtonStates[buttonName] = true;
					
					if (button.maxTimer > 0){
						button.timer = button.maxTimer;
					}
				} else{
					inputButtonStates[buttonName] = false;
				}
				
				if (inputButtonStates[buttonName]){
					let arr = button.onclick;
					
					if (arr != undefined){
						if (!isArray(arr)){
							arr = [arr];
						}
						
						runEvent(arr);
					}
				}
				
				button.previousPressedNum = pressedNum;
			} else{
				button.previousPressedNum = undefined;
			}
		}
	}
	
</script>

<script> //Entity General
	
	function getEntityById(id){
		return entities.find(arr => arr.id == id);
	}
	function getEntityNumById(id){
		return entities.findIndex(arr => arr.id == id);
	}
	
	function getEntitiesByClassName(className){
		let arr = entities.filter(arr => arr.className == className);
		
		return (arr.length > 0) ? arr : undefined;
	}
	
	function getPlayerEntity(){
		return entities.find(arr => arr.isPlayer) ?? {pos: {x: 0, y: 0, w: 0, h: 0, shape: "rect"}};
	}
	
	function getTargetEntities(args){
		let currentPos;
		
		switch (args){
			case "player": {
				currentPos = getPlayerEntity();
			} break;
			case "playerDash": {
				let playerEntity = getPlayerEntity();
				
				currentPos = playerEntity.dash ?? playerEntity;
			} break;
		}
		
		if (objectLength(currentPos) == 0){
			currentPos = getEntityById(args);
		}
		
		if (objectLength(currentPos) == 0){
			currentPos = getEntitiesByClassName(args);
		} else{
			currentPos = [currentPos];
		}
		
		return currentPos ?? [args];
	}
	
	function getTargetEntity(args){
		return getTargetEntities(args)[0];
	}
	
	function getEntityPos(entity){
		let pos = entity.boxPos ?? entity.pos;
		
		return pos ?? entity;
	}
	
	function getTargetEntityPos(args){
		let currentEntity = getTargetEntity(args);
		
		return getEntityPos(currentEntity);
	}
	
	
	function getWalls(){
		let arr = [];
		
		for (let i in entities){
			if (entities[i].isWall){
				arr.push(entities[i]);
			}
		}
		return arr;
	}
	function getInverseWalls(){
		let arr = [];
		
		for (let i in entities){
			if (entities[i].isInverseWall){
				arr.push(entities[i]);
			}
		}
		return arr;
	}
	
</script>
<script> //Entity Generation
	
	function generateEntities(args){
		for (let i = 0; i < (args.amount ?? 1); i++){
			let entityData = structuredClone(args.entityData);
			
			entities.push(entityData);
		}
	}
	
	function generateEntitiesInsideRect(args){
		for (let i = 0; i < (args.amount ?? 1); i++){
			let pos = {
				x: Math.random() * args.rect.w + args.rect.x,
				y: Math.random() * args.rect.h + args.rect.y
			}
			
			let entityData = structuredClone(args.entityData);
			
			if (entityData.boxPos != undefined){
				entityData.boxPos.x = pos.x;
				entityData.boxPos.y = pos.y;
			} else{
				entityData.pos.x = pos.x;
				entityData.pos.y = pos.y;
				
				if (args.makeHitbox){
					entityData.hitbox = [{pos: {x: pos.x, y: pos.y, w: entityData.pos.w, shape: "circle"}}];
				}
			}
			
			entities.push(entityData);
		}
	}
	
	function generateSegmentedPathEntityFromLine(args){
		let segmentCount = args.segmentCount;
		
		let start = args.linePos.start;
		let end = args.linePos.end;

		let offset = {x: end.x - start.x, y: end.y - start.y};

		let arr = [];

		for (let i = 0; i < segmentCount; i++){
			let percentage = i / (segmentCount - 1);
			
			let currentArr = {
				x: start.x + offset.x * percentage,
				y: start.y + offset.y * percentage
			};
			
			if (i > 0){
				currentArr.back = {
					x: start.x + offset.x * percentage - offset.x * 1/segmentCount / 2,
					y: start.y + offset.y * percentage - offset.y * 1/segmentCount / 2
				};
			}
			if (i < segmentCount - 1){
				currentArr.front = {
					x: start.x + offset.x * percentage + offset.x * 1/segmentCount / 2,
					y: start.y + offset.y * percentage + offset.y * 1/segmentCount / 2
				};
			}
			arr.push(currentArr);
		}
		
		entities.push({...args.entityData, pos: {arr: arr, shape: "polygon"}});
	}
	
</script>
<script> //Entity Movement
	
	function moveEntityAlongDirection(entity, direction, speed, axes = {x: 1, y: 1}){
		entity.pos.x += Math.cos(direction) * speed * Math.abs(axes.x);
		entity.pos.y += Math.sin(direction) * speed * Math.abs(axes.y);
	}
	
	
	function moveEntityByInputDistance(entity, distance){
		let movementAxes = {x: 0, y: 0};
		
		movementAxes = getKeyboardMovementAxes(movementAxes);
		movementAxes = getGamepadDpadAxes(movementAxes);
		movementAxes = getGamepadMovementAxes(movementAxes);
		
		for (let i in entity.disabledMovementAxis){
			if (entity.disabledMovementAxis[i]){
				movementAxes[i] = 0;
			}
		}
		
		if (movementAxes.x != 0 || movementAxes.y != 0){
			
			let walls = getWalls();
			let inverseWalls = getInverseWalls();
			
			let stepsNum = 10;
			
			for (let step = 0; step < stepsNum; step++){ //should probably remake this for better performance
				let directionAngle = getVertexToVertexRadians({x: 0, y: 0}, movementAxes);
				
				moveEntityAlongDirection(entity, directionAngle, distance/stepsNum, movementAxes);
				
				
				if (entity.isStoppedByWalls && inverseWalls.length > 0){
					let isInWalls = false;
					let isInsideInverseWalls = false;
					
					for (let i in walls){
						if (areCirclesColliding(entity.pos, walls[i].pos)){
							isInWalls = true;
						}
					}
					for (let i in inverseWalls){
						let inverseWallPos = structuredClone(inverseWalls[i].pos);
						
						inverseWallPos.w -= entity.pos.w * 2;
						
						if (areCirclesColliding(entity.pos, inverseWallPos)){
							isInsideInverseWalls = true;
						}
					}
					
					if (!isInsideInverseWalls || isInWalls){
						moveEntityAlongDirection(entity, directionAngle + Math.PI, distance/stepsNum);
					}
				}
			}
		}
	}
	
	
	function createEntityDashMovement(args){
		let dash = args.dash;
		
		if (dash.charge > 0){
			moveEntityByInputDistance(args, dash.maxDistance * (dash.charge / dash.maxCharge) + dash.minDistance);
			
			dash.charge = 0;
		}
	}
	
	function dashEntity(args){
		let dash = args.dash;
		
		if (dash != undefined){
			if (inputButtonStates.dash){
				dash.charge++;
				
				if (dash.charge > dash.maxCharge){
					dash.charge = dash.maxCharge;
				}
			} else{
				createEntityDashMovement(args);
			}
			
			
			let dashPos = structuredClone(args);
			
			createEntityDashMovement(dashPos);
			
			args.dash.pos = dashPos.pos;
		}
	}
	
	
	function movePlayer(args){
		let speed = args.speed * ((inputButtonStates.run) ? args.runMultiplier : 1);
		
		if (!inputButtonStates.dash){
			moveEntityByInputDistance(args, speed);
		}
	}
	
	
	
	function teleportEntityToOppositePos(args){
		let target = getTargetEntityPos(args.movement.target);
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = target.x * -1;
		pos.y = target.y * -1;
	}
	
	function teleportEntityToTargetEdge(args){
		let target = getTargetEntityPos(args.movement.target);
		
		let radians = getVertexToVertexRadians({x: 0, y: 0}, target);
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = Math.cos(radians) * args.movement.num;
		pos.y = Math.sin(radians) * args.movement.num;
	}
	
	
	function moveEntityAlongPath(args){
		let target = getTargetEntity(args.movement.target);
		
		args.pathPercent ??= 0;
		
		let currentPos = getPolygonPosAtPercentage(target.pos.arr, target, args.pathPercent, args.movement.layer);
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = currentPos.x;
		pos.y = currentPos.y;
		
		
		args.pathPercent += args.speed ?? 0;
		
		if (args.pathPercent > 1){
			if (args.movement.shouldLoop){
				args.pathPercent = 0;
			} else{
				args.pathPercent = 1;
			}
			
			if (args.movement.onFinishEvent != undefined){
				runEvent(args.movement.onFinishEvent);
			}
			
			if (args.movement.destroyOnFinish){
				args.shouldDestroy = true;
			}
		}
		
		args.changedArgs = ["pathPercent", "shouldDestroy"];
	}
	
	
	function rotateEntityAroundTarget(args){
		let target = getTargetEntityPos(args.movement.target) ?? {x: 0, y: 0};
		
		let radians = args.movement.radians ?? 0;
		let radius = args.movement.radius ?? 1;
		
		let pos = args.boxPos ?? args.pos;
		
		pos.x = Math.cos(radians) * (radius.x ?? radius) + target.x;
		pos.y = Math.sin(radians) * (radius.y ?? radius) + target.y;
	}
	
	
	function faceEntityTowardsClosestTargetInRadius(args){
		let targets = getTargetEntities(args.movement.target);
		
		args.foundTarget = false;
		
		if ((targets ?? []).length > 0 && targets[0] != args.movement.target){
			let pos = args.boxPos ?? args.pos;
			
			let radius = args.movement.radius;
			
			let closestTarget = {};
			
			for (let i in targets){
				let distance = getVertexDistance(pos, targets[i].boxPos ?? targets[i].pos);
				
				closestTarget.distance ??= distance;
				closestTarget.i ??= i;
				
				if (closestTarget.distance > distance){
					closestTarget = {distance: distance, i: i};
				}
			}
			
			let targetPos = targets[closestTarget.i].boxPos ?? targets[closestTarget.i].pos;
			
			if (closestTarget.distance <= args.movement.radius/2 + targetPos.w/2 || args.movement.radius == undefined){
				args.radians = getVertexToVertexRadians(pos, targetPos);
				
				args.foundTarget = true;
			}
		}
		
		args.changedArgs = ["radians", "foundTarget"];
	}
	
	
	function moveEntities(){
		for (let i = 0; i < entities.length; i++){
			let entity = entities[i];
			
			if (entity.isPlayer){
				movePlayer(entity);
				
				dashEntity(entity);
			} else{
				if (entity.movement != undefined){
					let entityArgs = structuredClone(entity);
					
					if (entityArgs.shouldEval != false){
						entityArgs = getEvaluatedObject(entityArgs, false);
					}
					
					window[entity.movement.type](entityArgs);
					
					if (entity.boxPos != undefined){
						entity.boxPos = entityArgs.boxPos;
					} else{
						entity.pos = entityArgs.pos;
					}
					
					if (entityArgs.changedArgs != undefined){
						for (let i of entityArgs.changedArgs){
							entity[i] = entityArgs[i];
						}
					}
				}
			}
			
			if (entity.shouldDestroy){
				entities.splice(i, 1);
				i--;
			}
		}
	}
	
</script>
<script> //Entity Actions
	
	function growEntitySize(entity, action, args = {}){
		for (let wh of whArr){
			if (entity[wh] != undefined){
				entity[wh] += action.speed;
			}
			
			if (entity.pos != undefined){
				if (entity.pos[wh] != undefined){
					entity.pos[wh] += action.speed;
				}
			}
		}
	}
	
	function moveEntityTowardsTarget(entity, action, args = {}){
		if (action.direction == undefined){
			action.direction = getVertexToVertexRadians(entity.pos, action.target);
		}
		
		moveEntityAlongDirection(entity, action.direction, action.speed);
	}
	
	function moveEntityAtAngle(entity, action, args = {}){
		action.radians ??= args.radians ?? 0;
		
		if (action.radians == "random"){
			action.radians = Math.random() * Math.PI*2;
		}
		
		
		moveEntityAlongDirection(entity, action.radians, action.speed);
	}
	
</script>
<script> //Entity Attacks
	
	function createBullet(pos, type, entity){
		let bullet = structuredClone(bullets[type]);
		
		if (bullet.shouldEval != false){
			bullet = getEvaluatedObject(bullet, false);
		}
		
		if (bullet.isMultiple){
			let data = bullet.data;
			
			if (bullet.formation.type == "arcAngle"){
				let targetAngle = bullet.formation.target;
				
				if (isNaN(targetAngle)){
					targetAngle = getVertexToVertexRadians(pos, getTargetEntityPos(targetAngle));
				}
				
				let amount = bullet.formation.amount;
				
				for (let i = 0; i < amount; i++){
					entities.push({
						...data,
						hitbox: [
							{
								pos: {x: pos.x, y: pos.y, w: data.w, shape: "circle"}, isHitboxHole: data.isHitboxHole,
								action: {type: "moveEntityAtAngle", radians: targetAngle + (i - amount/2 + 0.5) * bullet.formation.angleGap, speed: data.speed}
							}
						],
						pos: {x: pos.x, y: pos.y, w: data.w, shape: "circle"},
					});
				}
			}
			
		} else{
			let savedBullet = structuredClone(bullet);
			
			for (let i in bullet.hitbox){
				bullet.hitbox[i].pos = structuredClone(pos);
				bullet.hitbox[i].pos.w = savedBullet.hitbox[i].w;
				
				if (bullet.hitbox.length > 1){
					bullet.hitbox[i].pos.shape = "hollowCircle";
				}
			}
			
			bullet.pos = structuredClone(pos);
			bullet.pos.w = savedBullet.hitbox[0].w;
			
			if (entity.radians != undefined){
				bullet.radians = entity.radians;
			}
			
			entities.push(bullet);
		}
	}
	
	function createEntityAttacks(){
		for (let entity of entities){
			if (entity.attacks != undefined){
				
				if (entity.attackCooldown == undefined){
					entity.attackCooldown = {time: 0, phaseNum: 0, bulletNum: 0, repeatNum: 0};
					
					entity.attackType = getRandomElementOfArray(entity.attacks);
				}
				
				entity.attackCooldown.time--;
				
				
				let arr = entity.attackCooldown;
				
				let attack = attacks[entity.attackType];
				if (attack.shouldEval != false){
					attack = getEvaluatedObject(attack, false);
				}
				
				let phase = attack[arr.phaseNum];
				
				
				if (arr.time <= 0 && (!entity.onlyShootIfFoundTarget || entity.foundTarget)){
					if (arr.phaseNum < attack.length){
						
						let pos = phase.pos ?? entity.pos;
						
						createBullet(pos, phase.bullets[arr.bulletNum], entity);
						
						
						arr.time = attack[arr.phaseNum].time;
						
						arr.bulletNum++;
						
						if (arr.bulletNum >= phase.bullets.length){
							arr.bulletNum = 0;
							
							arr.repeatNum++;
							
							if (arr.repeatNum >= phase.repeatAmount){
								arr.repeatNum = 0;
								
								arr.phaseNum++;
							}
						}
						
						entity.attackCooldown = arr;
						
					} else{
						entity.attackCooldown = undefined;
					}
				}
			}
		}
	}
	
	
	function doBulletActions(){
		for (let entity of entities){
			if (entity.hitbox != undefined){
				
				for (let hitbox of entity.hitbox){
					let action = hitbox.action;
					
					if (action != undefined){
						if (window[action.type] != undefined){
							if (action.target != undefined){
								action.target = getTargetEntityPos(action.target);
							}
							
							window[action.type](hitbox, action, entity);
							
							entity.pos = hitbox.pos;
						}
					}
				}
				
			}
		}
	}
	
	function attacksNextFrame(){
		for (let i in entities){
			let entity = entities[i];
			
			if (entity.time != undefined){
				entity.time++;
				
				if (entity.time > entity.maxTime){
					entities.splice(i, 1);
				}
			}
		}
		
		createEntityAttacks();
		
		doBulletActions();
	}
	
</script>
<script> //Damage Entities
	
	function damageEntities(){
		let destroyedIndexes = [];
		
		for (let entityNum = 0; entityNum < entities.length; entityNum++){
			let entity = entities[entityNum];
			
			if (entity.invincibility > 0){
				entity.invincibility--;
			}
			
			if ((entity.invincibility ?? 0) <= 0 && entity.health != undefined){
				
				for (let attackerNum = 0; attackerNum < entities.length; attackerNum++){
					let attacker = entities[attackerNum];
					
					if (attacker.hitbox != undefined){
						if ((entity.isPlayer && attacker.canHitPlayers) || (!entity.isPlayer && attacker.canHitNotPlayers)){
							
							let isEntityAttacked;
							
							for (let hitbox of attacker.hitbox){
								
								if (isEntityAttacked != false){
									
									if (hitbox.isHitboxHole){
										if (isCircleFullyInsideCircle(entity.pos, hitbox.pos)){
											isEntityAttacked = false;
										}
									} else{
										if (areCirclesColliding(entity.pos, hitbox.pos)){
											isEntityAttacked = true;
										}
									}
								}
							}
							
							if (isEntityAttacked == true){
								entity.health -= attacker.damage;
								entity.invincibility = entity.maxInvincibility;
								
								if (attacker.destroyOnHit){
									entities.splice(attackerNum, 1);
									
									if (entityNum > attackerNum){
										entityNum--;
									}
									attackerNum--;
								}
								
								if (entity.health <= 0){
									entities.splice(entityNum, 1);
									
									entityNum--;
									
									break;
								}
							}
						}
					}
				}
				
			}
		}
	}
	
</script>

<script> //Polygons
	
	function getQuadraticCurvePosAtPercentage(startPt, controlPt, endPt, percentage){ //https://stackoverflow.com/a/22579440
		let T = percentage;
		
		let pos = {
			x: Math.pow(1-T,2) * startPt.x + 2 * (1-T) * T * controlPt.x + Math.pow(T,2) * endPt.x,
			y: Math.pow(1-T,2) * startPt.y + 2 * (1-T) * T * controlPt.y + Math.pow(T,2) * endPt.y
		}
		return pos;
	}
	
	function getCubicCurvePosAtPercentage(startPt, controlPt1, controlPt2, endPt, percentage){ //AI Generated from getQuadraticCurvePosAtPercentage
		let T = percentage;
		
		let pos = {
			x: Math.pow(1 - T, 3) * startPt.x + 
				3 * Math.pow(1 - T, 2) * T * controlPt1.x + 
				3 * (1 - T) * Math.pow(T, 2) * controlPt2.x + 
				Math.pow(T, 3) * endPt.x,
			
			y: Math.pow(1 - T, 3) * startPt.y + 
				3 * Math.pow(1 - T, 2) * T * controlPt1.y + 
				3 * (1 - T) * Math.pow(T, 2) * controlPt2.y + 
				Math.pow(T, 3) * endPt.y
		};
		return pos;
	}
	
	function getLinePosAtPercentage(startPt, endPt, percentage){ //AI Generated from getQuadraticCurvePosAtPercentage
		let T = percentage;
		
		let pos = {
			x: (1 - T) * startPt.x + T * endPt.x,
			y: (1 - T) * startPt.y + T * endPt.y
		};
		return pos;
	}
	
	
	function getPolygonPosAtPercentage(p, args, percentage, layer = "base"){
		let pArr = getCalculatedPolygon(p, {...args, isScaled: false});
		
		let arr = pArr[layer];
		
		let drawArr = (args.shouldCloseShape != false) ? [...arr, arr[0]] : arr;
		
		percentage = Math.max(percentage, 0);
		percentage = Math.min(percentage, 1);
		percentage *= 1 - (1 / (drawArr.length));
		
		let i = Math.floor(percentage * (drawArr.length));
		
		let currentPercentage = (percentage % (1 / (drawArr.length))) * drawArr.length;
		
		let nextArr = drawArr[i + 1] ?? {x: drawArr[i].x, y: drawArr[i].y, back: {x: drawArr[i].x, y: drawArr[i].y}};
		
		let currentPos = {
			start: drawArr[i],
			control1: drawArr[i].front,
			control2: nextArr.back,
			end: nextArr
		}
		
		let pos = {};
		
		if (drawArr[i].front != undefined){
			if (nextArr.back != undefined){
				pos = getCubicCurvePosAtPercentage(currentPos.start, currentPos.control1, currentPos.control2, currentPos.end, currentPercentage);
			} else{
				pos = getQuadraticCurvePosAtPercentage(currentPos.start, currentPos.control1, currentPos.end, currentPercentage);
			}
		} else{
			pos = getLinePosAtPercentage(currentPos.start, currentPos.end, currentPercentage);
		}
		
		return pos;
	}
	
</script>

<script> //Draw Positions Scaling
	
	function getCenteredPosition(pos){
		let arr = {...pos};
		
		arr.x -= (arr.w ?? arr.h ?? 0) / 2;
		arr.y -= (arr.h ?? arr.w ?? 0) / 2;
		
		return arr;
	}
	
	function getCanvasScaledPositions(pos, areDimentionsEqual = camera.areDimentionsEqual){
		let sizes = {x: canvas.width, y: canvas.height, w: canvas.width, h: canvas.height};
		
		if (areDimentionsEqual){
			let size = Math.min(canvas.width, canvas.height * camera.minWidthToHeightRatio);
			
			sizes = {x: size, y: size, w: size, h: size};
		}
		
		let scaledArr = {};
		
		for (let i in pos){
			scaledArr[i] = pos[i];
			
			if (sizes[i] != undefined){
				scaledArr[i] *= sizes[i];
			}
		}
		
		return scaledArr;
	}
	
	function getCanvasScaledPositionsInverted(pos, areDimentionsEqual = camera.areDimentionsEqual){
		let sizes = {x: canvas.width, y: canvas.height, w: canvas.width, h: canvas.height};
		
		if (areDimentionsEqual){
			let size = Math.min(canvas.width, canvas.height * camera.minWidthToHeightRatio);
			
			sizes = {x: size, y: size, w: size, h: size};
		}
		
		let scaledArr = {};
		
		for (let i in pos){
			scaledArr[i] = pos[i];
			
			if (sizes[i] != undefined){
				
				scaledArr[i] /= sizes[i];
			}
		}
		
		return scaledArr;
	}
	
	
	function calculatePositionWithCamera(arr){
		let pos = {x: arr.x, y: arr.y, w: arr.w, h: arr.h};
		
		refreshScrolledCamera();
		
		let scaledCamera = getCanvasScaledPositions(scrolledCamera);
		
		pos.x += scaledCamera.x;
		pos.y += scaledCamera.y;
		
		for (let i in pos){
			pos[i] *= camera.zoom.level;
		}
		
		return {x: Math.ceil(pos.x + canvas.width/2), y: Math.ceil(pos.y + canvas.height/2), w: Math.ceil(pos.w), h: Math.ceil(pos.h)};
	}
	
	function calculatePositionWithCameraInverted(arr){
		let pos = {x: arr.x - canvas.width/2, y: arr.y - canvas.height/2, w: arr.w, h: arr.h};
		
		for (let i in pos){
			pos[i] /= camera.zoom.level;
		}
		
		refreshScrolledCamera();
		
		let scaledCamera = getCanvasScaledPositions(scrolledCamera);
		
		pos.x -= scaledCamera.x;
		pos.y -= scaledCamera.y;
		
		return pos;
	}
	
	
	function getScaledPosition(pos, args = {}){
		let areDimentionsEqual = (args.isAbsolutePositioned) ? false : camera.areDimentionsEqual;
		
		let scaledPos = getCanvasScaledPositions(pos, areDimentionsEqual);
		
		if (!args.isAbsolutePositioned){
			scaledPos = calculatePositionWithCamera(scaledPos);
		}
		
		return scaledPos;
	}
	
	function getScaledPositionInverted(pos, args = {}){
		let scaledPos = pos;
		
		if (!args.isAbsolutePositioned){
			scaledPos = calculatePositionWithCameraInverted(pos);
		}
		
		let areDimentionsEqual = (args.isAbsolutePositioned) ? false : camera.areDimentionsEqual;
		
		scaledPos = getCanvasScaledPositionsInverted(scaledPos, areDimentionsEqual);
		
		return scaledPos;
	}
	
	
	
	function getCalculatedPolygon(p, args){
		let pArr = (isObject(p)) ? {...p} : {base: [...p]};
		
		for (let layer in pArr){
			let arr = pArr[layer];
			
			if ((args.radians ?? 0) % (Math.PI*2) != 0){
				let rotatedArr = [];
				
				for (let i in arr){
					let arrPos = getRotatedVertex(arr[i], args.radians, args.rotationCenter);
					
					if (arr[i].front != undefined){
						arrPos.front = getRotatedVertex(arr[i].front, args.radians, args.rotationCenter);
					}
					if (arr[i].back != undefined){
						arrPos.back = getRotatedVertex(arr[i].back, args.radians, args.rotationCenter);
					}
					
					rotatedArr.push(arrPos);
				}
				arr = rotatedArr;
			}
			
			let boxWidth = 1;
			
			if (args.boxPos != undefined){
				let currentArr = [];
				
				let ratio = args.boxRatio ?? {w: 1, h: 1};
				if (ratio.w == undefined){ ratio = {w: ratio, h: ratio}; }
				
				let boxSize = {
					w: (args.boxPos.w ?? 1) * ratio.w,
					h: (args.boxPos.h ?? 1) * ratio.h
				};
				
				boxWidth = boxSize.w;
				
				for (let i in arr){
					let arrPos = {
						x: arr[i].x * boxSize.w + args.boxPos.x,
						y: arr[i].y * boxSize.h + args.boxPos.y
					};
					
					if (arr[i].front != undefined){
						arrPos.front = {
							x: arr[i].front.x * boxSize.w + args.boxPos.x,
							y: arr[i].front.y * boxSize.h + args.boxPos.y
						};
					}
					if (arr[i].back != undefined){
						arrPos.back = {
							x: arr[i].back.x * boxSize.w + args.boxPos.x,
							y: arr[i].back.y * boxSize.h + args.boxPos.y
						};
					}
					
					currentArr.push(arrPos);
				}
				arr = currentArr;
				
			}
			if (args.isScaled != false){
				let scaledArr = [];
				
				for (let i in arr){
					let currentArr = getScaledPosition(arr[i], args);
					
					if (arr[i].front != undefined){
						currentArr.front = getScaledPosition(arr[i].front, args);
					}
					if (arr[i].back != undefined){
						currentArr.back = getScaledPosition(arr[i].back, args);
					}
					
					scaledArr.push(currentArr);
				}
				arr = scaledArr;
			}
			
			for (let i in arr){
				arr[i].boxWidth = boxWidth;
			}
			
			pArr[layer] = arr;
		}
		return pArr;
	}
	
	function getCalculatedPolygonInverted(p, args){
		let pArr = (isObject(p)) ? structuredClone(p) : {base: structuredClone(p)}; //todo: make it like in the uninverted one (without structuredClone)
		for (let layer in pArr){
			let arr = pArr[layer];
			
			if (args.isScaled != false){
				let scaledArr = [];
				
				for (let i in arr){
					let currentArr = getScaledPositionInverted(arr[i], args);
					
					if (arr[i].front != undefined){
						currentArr.front = getScaledPositionInverted(arr[i].front, args);
					}
					if (arr[i].back != undefined){
						currentArr.back = getScaledPositionInverted(arr[i].back, args);
					}
					
					scaledArr.push(currentArr);
				}
				arr = scaledArr;
			}
			
			if (args.boxPos != undefined){
				let currentArr = [];
				
				let ratio = args.boxRatio ?? {w: 1, h: 1};
				if (ratio.w == undefined){ ratio = {w: ratio, h: ratio}; }
				
				let boxSize = {
					w: (args.boxPos.w ?? 1) * ratio.w,
					h: (args.boxPos.h ?? 1) * ratio.h
				};
				
				
				for (let i in arr){
					let arrPos = {
						x: (arr[i].x - args.boxPos.x) / boxSize.w,
						y: (arr[i].y - args.boxPos.y) / boxSize.h
					};
					
					if (arr[i].front != undefined){
						arrPos.front = {
							x: (arr[i].front.x - args.boxPos.x) / boxSize.w,
							y: (arr[i].front.y - args.boxPos.y) / boxSize.h
						};
					}
					if (arr[i].back != undefined){
						arrPos.back = {
							x: (arr[i].back.x - args.boxPos.x) / boxSize.w,
							y: (arr[i].back.y - args.boxPos.y) / boxSize.h
						};
					}
					
					currentArr.push(arrPos);
				}
				arr = currentArr;
				
			}
			
			if ((args.radians ?? 0) % (Math.PI*2) != 0){
				let rotatedArr = [];
				
				for (let i in arr){
					let arrPos = getRotatedVertex(arr[i], -args.radians, args.rotationCenter);
					
					if (arr[i].front != undefined){
						arrPos.front = getRotatedVertex(arr[i].front, -args.radians, args.rotationCenter);
					}
					if (arr[i].back != undefined){
						arrPos.back = getRotatedVertex(arr[i].back, -args.radians, args.rotationCenter);
					}
					
					rotatedArr.push(arrPos);
				}
				arr = rotatedArr;
			}
			pArr[layer] = arr;
		}
		return pArr;
	}
	
</script>
<script> //Draw Color
	
	function setDrawStyleToColor(color, args = {}){
		let currentColor = colors[color] ?? color;
		
		if (isObject(currentColor)){
			let arr = currentColor;
			
			args.pos ??= {x: 0, y: 0, w: 1, h: 1};
			
			let pos = (arr.isScaled != false) ? getScaledPosition(args.pos, args) : {x: 0, y: 0, w: canvas.width, h: canvas.height};
			
			pos = {
				start: {
					x: pos.x + (pos.w ?? pos.h) * arr.pos.start.x,
					y: pos.y + (pos.h ?? pos.w) * arr.pos.start.y
				},
				end: {
					x: pos.x + (pos.w ?? pos.h) * arr.pos.end.x,
					y: pos.y + (pos.h ?? pos.w) * arr.pos.end.y
				},
			};
			
			let gradient = ctx.createLinearGradient(pos.start.x, pos.start.y, pos.end.x, pos.end.y);
			
			for (let i in arr.colorStops){
				gradient.addColorStop(arr.colorStops[i][0], arr.colorStops[i][1]);
			}
			
			currentColor = gradient;
		}
		
		ctx[(args.isFill != false) ? "fillStyle" : "strokeStyle"] = currentColor;
	}
	
</script>
<script> //Draw Shapes
	
	function drawRect(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		if (args.isFill != false){
			ctx.fillRect(pos.x, pos.y, pos.w, pos.h);
		} else{
			let polygon = [{x: pos.x, y: pos.y}, {x: pos.x + pos.w, y: pos.y}, {x: pos.x + pos.w, y: pos.y + pos.h}, {x: pos.x, y: pos.y + pos.h}];
			
			drawPolygon(polygon, {isScaled: false, isFill: false, lineWidth: args.lineWidth, minLinePixelSize: args.minLinePixelSize, isAbsolutePositioned: args.isAbsolutePositioned});
		}
	}
	
	function drawPolygonPoints(pArr, args){
		let currentArgs = {...args, lineWidth: undefined, color: undefined};
		
		for (let layer in pArr){
			let arr = pArr[layer];
			
			ctx.fillStyle = "#ff0000";
			ctx.strokeStyle = "#0000ff";
			ctx.lineWidth = 1;
			
			for (let i = 0; i < arr.length; i++){
				let nextPos = arr[i + 1] ?? arr[0];
				if (arr[i].front != undefined){
					ctx.strokeStyle = "#00c0ff";
					ctx.beginPath();
					ctx.moveTo(arr[i].x, arr[i].y);
					ctx.lineTo(arr[i].front.x, arr[i].front.y);
					ctx.stroke();
					
					drawRect({x: arr[i].front.x, y: arr[i].front.y, w: 10, h: 10}, {...currentArgs, isScaled: false, isCentered: true, isFill: false});
				}
				
				if (arr[i].back != undefined){
					ctx.strokeStyle = "#0000ff";
					ctx.beginPath();
					ctx.moveTo(arr[i].x, arr[i].y);
					ctx.lineTo(arr[i].back.x, arr[i].back.y);
					ctx.stroke();
				}
				
				drawRect({x: arr[i].x, y: arr[i].y, w: 7, h: 7}, {...currentArgs, isScaled: false, isCentered: true, isFill: true});
				
				if (arr[i].back != undefined){
					drawRect({x: arr[i].back.x, y: arr[i].back.y, w: 10, h: 10}, {...currentArgs, isScaled: false, isCentered: true, isFill: false});
				}
			}
		}
	}
	
	function drawPolygon(p, args = {}){
		let pArr = getCalculatedPolygon(p, args);
		let savedPaths = {};
		
		for (let layer in pArr){
			let arr = pArr[layer];
			
			if (arr.length > 0){
				let path = new Path2D();
				
				if (args.shouldCloseShape != false){
					path.moveTo(arr[arr.length-1].x, arr[arr.length-1].y);
				} else{
					path.moveTo(arr[0].x, arr[0].y);
				}
				
				let drawArr = (args.shouldCloseShape != false) ? [arr[arr.length-1], ...arr] : arr;
				for (let i = 0; i < drawArr.length - 1; i++){
					let nextArr = drawArr[i + 1];
					
					if (drawArr[i].front != undefined){
						if (nextArr.back != undefined){
							path.bezierCurveTo(drawArr[i].front.x, drawArr[i].front.y, nextArr.back.x, nextArr.back.y, nextArr.x, nextArr.y);
						} else{
							path.quadraticCurveTo(drawArr[i].front.x, drawArr[i].front.y, nextArr.x, nextArr.y);
						}
					} else{
						path.lineTo(nextArr.x, nextArr.y);
					}
					
				}
				if (args.shouldCloseShape != false){
					path.closePath();
				}
				
				let isFill = (args.isFill ?? {})[layer] ?? args.isFill ?? true;
				
				let savedLineWidth = 1;
				
				if (isFill){
					if (args.color != undefined){
						let currentColor = (isObject(args.color)) ? (args.color[layer] ?? colors.defaultPolygonFillColor) : args.color;
						
						ctx.fillStyle = currentColor;
					}
					
					ctx.fill(path);
				} else{
					if (args.color != undefined){
						let currentColor = (isObject(args.color)) ? (args.color[layer] ?? colors.defaultPolygonStrokeColor) : args.color;
						
						ctx.strokeStyle = currentColor;
					}
					if (args.lineWidth != undefined){
						savedLineWidth = getScaledPosition({w: (args.lineWidth[layer] ?? args.lineWidth) * arr[0].boxWidth}, {isAbsolutePositioned: args.isAbsolutePositioned}).w;
						
						if (savedLineWidth < args.minLinePixelSize){
							savedLineWidth = args.minLinePixelSize;
						}
						
						ctx.lineWidth = savedLineWidth;
					}
					
					ctx.stroke(path);
				}
				
				savedPaths[layer] = {path: path, lineWidth: savedLineWidth};
			}
		}
		if (args.isEditable || args.isClickable || args.savePolygon){
			savedPolygons[args.id] = pArr;
			
			for (let i in savedPolygons[args.id]){
				for (let j in savedPolygons[args.id][i]){
					savedPolygons[args.id][i][j].args = args;
					savedPolygons[args.id][i][j].args.savedPath = savedPaths;
					
					/* todo: incorporate this way of checking if a point is in a path:
					let extraRadius = 10;
					ctx.lineWidth = savedPolygons["p3"].base[0].args.savedPath.base.lineWidth + extraRadius;
					ctx.isPointInStroke(savedPolygons["p3"].base[0].args.savedPath.base.path, 0, 0)
					*/
				}
			}
		}
		
		if (args.showPoints){
			drawLayers[10000] ??= [];
			drawLayers[10000].push({f: drawPolygonPoints, args: [pArr, args]});
		}
		
		if (args.showBox){
			ctx.strokeStyle = "#ff6600";
			ctx.lineWidth = 1;
			
			drawRect({x: args.boxPos.x, y: args.boxPos.y, w: args.boxPos.w ?? 1, h: args.boxPos.h ?? 1}, {...args, isScaled: true, isCentered: true, isFill: false, showBox: false, lineWidth: undefined, color: undefined});
		}
	}
	
	
	function drawCircle(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let fillType = (args.isFill != false) ? "fill" : "stroke";
		
		ctx.beginPath();
		ctx.arc(pos.x + pos.w/2, pos.y + pos.w/2, Math.max(pos.w/2, 0), 0, 2 * Math.PI, false);
		ctx[fillType]();
	}
	
	function drawHollowCircle(circles, args = {}){
		let arr = structuredClone(circles);
		
		if (args.isCentered){
			let centeredArr = [];
		
			for (let i in arr){
				centeredArr.push({pos: getCenteredPosition(arr[i].pos)});
			}
			arr = centeredArr;
		}
		if (args.isScaled != false){
			let scaledArr = [];
			for (let i in arr){
				let pos = arr[i].pos;
				
				scaledArr.push({pos: getScaledPosition(pos, args)});
			}
			arr = scaledArr;
		}
		
		let fillType = (args.isFill != false) ? "fill" : "stroke";
		
		ctx.beginPath();
		for (let i in arr){
			let pos = arr[i].pos;
			
			ctx.arc(pos.x + pos.w/2, pos.y + pos.w/2, Math.max(pos.w/2, 0), 0, 2 * Math.PI, (i % 2 == 1));
		}
		ctx[fillType]();
	}
	
	
	function drawGridHex(pos, args = {}){
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let polygon = [];
		
		let xValue = 0.8660254037844386; //From: Math.cos(Math.PI * 2 / 6 * i + Math.PI/2)
		
		let hexPos = [{x: 0, y: 1}, {x: -xValue, y: 0.5}, {x: -xValue, y: -0.5}, {x: 0, y: -1}, {x: xValue, y: -0.5}, {x: xValue, y: 0.5}];
		
		for (let i = 0; i < 6; i++){
			polygon.push({
				x: hexPos[i].x * pos.w/2 * 1.155 + pos.x + pos.w/2,
				y: hexPos[i].y * pos.h/2 * 1.155 + pos.y + pos.h/2
			});
		}
		
		drawPolygon(polygon, {isScaled: false, isFill: args.isFill});
	}
	
	function drawGridTri(pos, args = {}){
		let i = pos.i; let j = pos.j;
		
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		let isUpwards = ((i + j) % 2 == 0);
		
		let polygon = (isUpwards) ? [{x: pos.x + pos.w/2, y: pos.y}, {x: pos.x + pos.w, y: pos.y + pos.h}, {x: pos.x, y: pos.y + pos.h}] :
									[{x: pos.x + pos.w/2, y: pos.y + pos.h}, {x: pos.x, y: pos.y}, {x: pos.x + pos.w, y: pos.y}];
		
		drawPolygon(polygon, {isScaled: false, isFill: args.isFill});
	}
	
</script>
<script> //Draw Image
	
	function drawImage(pos, args = {}){
		let image = pos.src;
		
		if (typeof image == "string"){
			if (images[image] == undefined){
				let imageElement = document.getElementById(image);
				
				if (imageElement == undefined){
					imageElement = document.createElement("img");
					imageElement.id = image;
					imageElement.src = image;
					
					document.getElementById("imagesId").appendChild(imageElement);
					
					imageElement = document.getElementById(image);
				}
				
				images[image] = imageElement;
			}
			
			image = images[image];
		}
		
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		ctx.drawImage(image, pos.x, pos.y, pos.w, pos.h);
	}
	
</script>
<script> //Draw Text	
	
	function getFontSizeFromRatio(ratio, args = {}){
		return getCanvasScaledPositions({h: ratio}).h * ((args.isAbsolutePositioned) ? 1 : (camera.zoom.level / camera.zoom.defaultTextLevel));
	}
	function getFontSizeFromRatioWithFont(ratio, font = defaultFont, args = {}){
		return getFontSizeFromRatio(ratio, args) + "px " + font;
	}
	
	function drawText(text, pos, args = {}){
		pos = structuredClone(pos);
		
		if (args.isCentered){
			pos = getCenteredPosition(pos);
		}
		
		if (args.textOffset != undefined){
			pos.x += args.textOffset.x ?? 0;
			pos.y += args.textOffset.y ?? 0;
		}
		
		if (args.isScaled != false){
			pos = getScaledPosition(pos, args);
		}
		
		
		let evalText = ((text + "").includes("{{")) ? getEvaluatedText(text) : text;
		
		if (args.breakSpaces){
			evalText = evalText.replaceAll(" ", "\n");
		}
		
		let lines = (evalText + "").split("\n");
		
		
		let size;
		if (args.scaleText != false){
			size = (pos.w != undefined) ? (pos.w * args.textSize) : getFontSizeFromRatio(args.textSize, args);
			
			let maxLineLength = getBiggestLengthOfArray(lines);
			
			if (args.downscaleTextLength < maxLineLength && (args.downscaleTextLength != undefined)){
				size *= args.downscaleTextLength / maxLineLength;
			}
			
			ctx.font = size + "px " + (args.font ?? defaultFont);
			
			if (args.outlineSize > 0){
				let outlineSize = (pos.w != undefined && args.isScaledOutline) ? (pos.w * args.outlineSize) : getFontSizeFromRatio(args.outlineSize, args);
				
				ctx.lineWidth = outlineSize;
			}
		}
		
		let marginY = args.marginY ?? defaultValues.textMarginY;
		
		if (args.isScaled != false){
			if (size != undefined && args.isMarginYScaled != false){
				marginY *= getCanvasScaledPositionsInverted({w: size}).w * 25;
			}
			
			marginY = getScaledPosition({...pos, h: marginY}, args).h;
		}
		
		
		if (lines.length > 1 && args.shouldCenterLines != false){
			pos.y -= marginY * (lines.length - 1) / 2;
		}
		
		for (let i = 0; i < lines.length; i++){
			let linePos = {x: pos.x, y: pos.y + marginY * i};
			
			if (args.outlineSize > 0){
				ctx.strokeStyle = colors[args.outlineColor] ?? args.outlineColor;
				
				ctx.strokeText(lines[i], linePos.x, linePos.y);
			}
			
			if (args.textColor != undefined){
				ctx.fillStyle = colors[args.textColor] ?? args.textColor;
			}
			
			
			if (args.isFill != false){
				ctx.fillText(lines[i], linePos.x, linePos.y);
			} else{
				ctx.strokeText(lines[i], linePos.x, linePos.y);
			}
		}
	}
	
	
	function drawTextAndBreakToFitWidth(text, pos, width, gapY, args = {}){
		let textArr = [];
		
		let remainingText = ((text + "").includes("{{")) ? getEvaluatedText(text) : text;
		
		let lastSpaceNum = 0;
		
		while (remainingText.length > 0){
			remainingText = remainingText.trimStart();
			
			for (let i = 0; i < width; i++){
				if (remainingText.length > width){
					if (i + 1 == width){
						
						let lineWidth = (lastSpaceNum > 0) ? lastSpaceNum : width;
						
						textArr.push(remainingText.substring(0, lineWidth));
						
						remainingText = remainingText.substring(lineWidth);
						
						lastSpaceNum = 0;
					} else{
						if (remainingText[i] == " "){
							lastSpaceNum = i;
						}
					}
				} else{
					textArr.push(remainingText);
					
					remainingText = "";
				}
			}
		}
		
		for (let i = 0; i < textArr.length; i++){
			drawText(textArr[i], {x: pos.x, y: pos.y + gapY*i}, args);
		}
	}
	
</script>
<script> //Rotation Draw Functions (unused for now)
	
	function rotatedDraw(functionName, argsArr, center, radians, posIndexesInArgsArr, arePosCentered = true){ //todo: remake this with args
		
		let args = structuredClone(argsArr);
		
		centerPos = getScaledPosition(center);
		
		for (let i in posIndexesInArgsArr){
			let index = posIndexesInArgsArr[i];
			
			for (let j in args[index]){
				args[index][j] *= camera.zoom.level;
			}
			
			if (arePosCentered){
				args[index].x -= args[index].w/2;
				args[index].y -= args[index].h/2;
			}
		}
		
		ctx.translate(centerPos.x, centerPos.y);
		ctx.rotate(radians);
		
		window[functionName](...args);
		
		ctx.rotate(-radians);
		ctx.translate(-centerPos.x, -centerPos.y);
	}
	
	function rotatedScaledFillRect(pos, radians, offset = {x: 0, y: 0}){ //the drawRect here hasn't been tested yet
		rotatedDraw("drawRect", [{x: offset.x, y: offset.y, w: pos.w, h: pos.h}, true], {x: pos.x, y: pos.y}, radians, [0], false);
	}
	function rotatedCenteredScaledFillRect(pos, radians, offset = {x: 0, y: 0}){
		rotatedDraw("drawRect", [{x: offset.x, y: offset.y, w: pos.w, h: pos.h}, true], {x: pos.x, y: pos.y}, radians, [0]);
	}
	
	function rotatedScaledFillText(text, pos, radians, offset = {x: 0, y: 0}){
		rotatedDraw("drawRect", [text, {x: offset.x, y: offset.y}, true], pos, radians);
	}
	
</script>
<script> //Draw Grids
	
	function refreshGridDrawValues(args){
		let grid = window[args.gridName];
		
		if (grid != undefined){
			let values = {};
			
			for (let layer in grid.grid){
				values[layer] = [];
				for (let i = 0; i < grid.grid[layer].length; i++){
					values[layer][i] = [];
					for (let j = 0; j < grid.grid[layer][i].length; j++){
						let extraArgs = {layer: layer, pos: {x: j, y: i}};
						let value = getConditionalArrayValue(grid.data.gridDrawData, {...args, ...grid.grid[layer][i][j], ...extraArgs});
						
						if (value != undefined){
							values[layer][i][j] = value;
						}
					}
				}
			}
			
			grid.data.gridDrawValues = values;
		}
	}
	
	
	function getGridOffset(grid){
		let pos = {...grid.data};
		
		let offsetX = pos.w;
		let offsetY = pos.h;
		
		if ((grid.data.gridShape == "tri")){
			offsetX = pos.w / 2;
		}
		if ((grid.data.gridShape == "hex")){
			offsetY = pos.h / 1.155
		}
		
		return {
			w: offsetX + pos.gaps.left + pos.gaps.right,
			h: offsetY + pos.gaps.up + pos.gaps.down
		}
	}
	
	function getGridTileHoverColor(data, currentHoverPos){
		let hoverColor;
		
		if (data.hover.tiles[currentHoverPos] != undefined){
			let alphaNum = data.hover.tiles[currentHoverPos] / data.hover.time;
			
			alphaNum *= data.hover.maxHoverAlphaNum ?? defaultValues.gridHoverAlphaNum;
			
			hoverColor = (data.hover.color ?? colors["defaultGridHover"]).replaceAll("{{alphaNum}}", alphaNum);
			
			if (hoverColor[0] == "#" && hoverColor.length == 7){
				hoverColor += Math.floor(Math.min(alphaNum, 1) * 255).toString(16).padStart(2, '0');
			}
		}
		return hoverColor;
	}
	
	function fillGridShape(args){
		let grid = window[args.gridName];
		let data = grid.data;
		
		ctx.lineWidth = getScaledPosition({w: (args.borderSize ?? defaultValues.gridBorderSize)}).w;
		
		let layers = (args.layers ?? args.layer) ?? Object.keys(grid.grid);
		if ( !isArray(layers) ){ layers = [layers]; }
		
		let shapeFunctions = {rect: drawRect, hex: drawGridHex, tri: drawGridTri}
		
		for (let layerName of layers){
			let currentGrid = grid.grid[layerName];
			
			let pos = structuredClone(data);
			
			let offsets = getGridOffset(grid);
			
			if (data.isCentered != false){
				pos.x -= offsets.w * data.gridSize.w / 2;
				pos.y -= offsets.h * data.gridSize.h / 2;
			}
			
			for (let i = 0; i < currentGrid.length; i++){
				for (let j = 0; j < currentGrid[i].length; j++){
					let extraArgs = (args.id != undefined) ? data.gridDrawValues[layerName][i][j][args.id] : {};
					
					if (extraArgs != undefined){
						extraArgs = {...args, ...extraArgs};
						
						
						let currentPos = {
							x: pos.x + offsets.w * j + pos.gaps.left,
							y: pos.y + offsets.h * i + pos.gaps.up,
							w: pos.w, h: pos.h, i: i, j: j
						}
						
						if (data.gridShape == "hex"){
							currentPos.x += (i % 2 == 0) * offsets.w/2;
						}
						
						setDrawStyleToColor(extraArgs.color, {...extraArgs, pos: currentPos, isFill: true});
						setDrawStyleToColor(extraArgs.borderColor, {...extraArgs, pos: currentPos, isFill: false});
						
						shapeFunctions[data.gridShape](currentPos);
						
						shapeFunctions[data.gridShape](currentPos, {isFill: false});
						
						//Hover
						if (data.hover != undefined){
							let currentHoverPos = layerName + ";" + j + ";" + i;
							
							let hoverColor = getGridTileHoverColor(data, currentHoverPos);
							
							if (hoverColor != undefined){
								drawLayers[0] ??= [];
								drawLayers[0].push({f: shapeFunctions[data.gridShape], args: [currentPos], color: hoverColor, isFill: true});
							}
						}
					}
				}
			}
		}
	}
	
	function fillGridText(args){
		let grid = window[args.gridName];
		let data = grid.data;
		
		let layers = (args.layers ?? args.layer) ?? Object.keys(grid.grid);
		if ( !isArray(layers) ){ layers = [layers]; }
		
		for (let layerName of layers){
			let currentGrid = grid.grid[layerName];
			
			let pos = structuredClone(data);
			
			let offsets = getGridOffset(grid);
			
			if (data.isCentered != false){
				pos.x -= offsets.w * data.gridSize.w / 2;
				pos.y -= offsets.h * data.gridSize.h / 2;
			}
			
			for (let i = 0; i < currentGrid.length; i++){
				for (let j = 0; j < currentGrid[i].length; j++){
					let extraArgs = (args.id != undefined) ? data.gridDrawValues[layerName][i][j][args.id] : {};
					
					if (extraArgs != undefined){
						extraArgs = {...args, ...extraArgs};
						
						let currentPos = {
							x: pos.x + offsets.w * j + pos.gaps.left + pos.w/2,
							y: pos.y + offsets.h * i + pos.gaps.up + pos.h/2,
							w: pos.w, h: pos.h
						}
						
						if (data.gridShape == "hex"){
							currentPos.x += (i % 2 == 0) * offsets.w/2;
						}
						
						if (args.textOffset != undefined){
							currentPos.x += (args.textOffset.x ?? 0) * pos.w;
							currentPos.y += (args.textOffset.y ?? 0) * pos.h;
						}
						
						
						let text = extraArgs.text;
						if (text != undefined){
							drawText(text, currentPos, extraArgs);
						}
						
						text = currentGrid[i][j][extraArgs.value];
						if (text != undefined){
							drawText(text, currentPos, extraArgs);
						}
						
					}
				}
			}
		}
	}
	
	function drawGrids(){
		gridHoverNextFrame();
		
		for (let gridName of gridNames){
			let grid = window[gridName];
			
			if (grid.data.gameState == gameState.currentState || grid.data.gameState == undefined){
				if (grid.data.draw != undefined){
					for (let j in grid.data.draw){
						arr = grid.data.draw[j];
						
						runEvent([arr]);
					}
				}
			}
		}
	}
	
</script>
<script> //Draw Entities
	
	function drawEntities(){
		for (let entity of entities){
			
			let entityArr = [entity];
			
			if (entity.dash != undefined){
				if (entity.dash.pos != undefined){
					entityArr.unshift(entity.dash);
				}
			}
			
			let isDash = entityArr.length > 1;
			
			for (let i in entityArr){
				let entityColor = entity.color;
				
				if (entity.invincibility > 0 && entity.hitColor != undefined){
					entityColor = entity.hitColor;
				}
				
				entityColor += ((isDash) ? "88" : "");
				
				ctx[(entity.isFill != false) ? "fillStyle" : "strokeStyle"] = entityColor;
				
				if (entity.lineWidth != undefined){
					ctx.lineWidth = getScaledPosition({w: entity.lineWidth}).w;
				}
				
				
				let drawArgs = {isCentered: true, ...entityArr[i]};
				
				let currentDrawLayer = [];
				
				switch (entity.pos.shape){ //todo: why is it push if there can only be 1?
					case "rect": {
						currentDrawLayer.push({f: drawRect, args: [entityArr[i].pos, drawArgs], color: entityColor});
					} break;
					case "circle": {
						currentDrawLayer.push({f: drawCircle, args: [entityArr[i].pos, drawArgs], color: entityColor});
					} break;
					case "hollowCircle": {
						currentDrawLayer.push({f: drawHollowCircle, args: [entityArr[i].hitbox, drawArgs], color: entityColor});
					} break;
					case "polygon": {
						currentDrawLayer.push({f: drawPolygon, args: [entityArr[i].pos.arr, drawArgs], color: entityColor});
					} break;
					case "image": {
						currentDrawLayer.push({f: drawImage, args: [entityArr[i].pos, drawArgs]});
					} break;
				}
				
				if (entityArr[i].drawLayer == undefined){
					for (let j in currentDrawLayer){
						currentDrawLayer[j].f(...currentDrawLayer[j].args);
					}
				} else{
					drawLayers[entityArr[i].drawLayer] ??= [];
					drawLayers[entityArr[i].drawLayer].push(...currentDrawLayer);
				}
				
				isDash = false;
			}
		}
	}
	
</script>
<script> //Draw Buttons
	
	function drawLockedButtonText(){
		if (closestButton.isLocked && !closestButton.hideLocked && !closestButton.isHidden){
			let button = buttons[closestButton.i][closestButton.j];
			let text = button.lockedTitle ?? defaultValues.lockedButtonTitle;
			
			ctx.textAlign = (mousePosRatio.x < 0.5) ? "left" : "right";
			ctx.textBaseline = "ideographic";
			
			let size = (button.lockedTitleSize ?? defaultValues.lockedButtonTitleSize);
			ctx.font = getFontSizeFromRatioWithFont(size);
			
			
			let shadowColor = (button.lockedTitleShadowColor ?? "defaultButtonLockedTitleShadow");
			ctx.fillStyle = colors[shadowColor] ?? shadowColor;
			
			let shadowOffset = button.lockedTitleShadowOffset ?? defaultValues.lockedButtonTitleShadowOffset;
			drawText(text, addObjects(mousePosRatio, shadowOffset), {isAbsolutePositioned: true, scaleText: false});
			
			
			let color = (button.lockedTitleColor ?? "defaultButtonLockedTitle");
			setDrawStyleToColor(color, {isFill: true});
			drawText(text, mousePosRatio, {isAbsolutePositioned: true, scaleText: false});
			
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
		}
	}
	
	
	function drawButtons(){
		let i = gameState.currentState;
		
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		
		buttonHoverNextFrame();
		
		let currentButtons = [...buttons[i]];
		
		if (buttons["overlay"] != undefined && currentButtons != undefined){
			currentButtons.push(...buttons["overlay"]);
		}
		
		for (let j in currentButtons){
			let button = {...currentButtons[j]};
			
			if (!button.isHidden && !(button.isLocked && button.hideLocked)){
				let pos = button.pos;
				
				let isAbsolutePositioned = (button.isAbsolutePositioned);
				
				let args = {
					isAbsolutePositioned: isAbsolutePositioned,
					downscaleTextLength: button.downscaleTextLength
				};
				
				if (button.isCentered != false){
					pos = getCenteredPosition(pos);
				}
				
				//hover color
				let hoverColor;
				if (hoveredButtons.arr[j] > 0 && !button.isLocked && !button.disableClick){
					let alphaNum = hoveredButtons.arr[j] / hoveredButtons.maxSeconds;
					
					alphaNum *= button.maxHoverAlphaNum ?? hoveredButtons.maxAlphaNum;
					
					hoverColor = (button.hoverColor ?? colors["defaultButtonHover"]).replaceAll("{{alphaNum}}", alphaNum);
					
					if (hoverColor[0] == "#" && hoverColor.length == 7){
						hoverColor += Math.floor(Math.min(alphaNum, 1) * 255).toString(16).padStart(2, '0');
					}
				}
				
				
				//button color
				let color = (button.isLocked && (!button.disableClick || button.disableClickLooksLocked)) ? (button.lockedColor ?? "defaultButtonLocked") : (button.color ?? "defaultButton");
				setDrawStyleToColor(color, {isFill: true});
				drawRect(pos, args);
				
				//button border
				if (button.borderSize != undefined){
					setDrawStyleToColor(button.borderColor ?? "defaultButtonBorder", {isFill: false});
					drawRect(pos, {...args, isFill: false, lineWidth: button.borderSize, minLinePixelSize: button.minLinePixelSize});
				}
				
				//button text
				let text = button.text;
				
				text += (button.extraText ?? "");
				
				if (button.toggle != undefined){
					if (!button.toggle.hideText){
						let arr = (window[button.toggleArrName] ?? window);
						
						let isOn = arr[button.toggle.value];
						
						if (button.toggle.isInverse){
							isOn = !isOn;
						}
						
						text += button.toggleTexts[isOn];
					}
				}
				
				if (button.isLocked && button.lockedText != undefined){
					text = button.lockedText;
				}
				
				let textColor = (button.isLocked) ? (button.lockedTextColor ?? "defaultButtonLockedText") : (button.textColor ?? "defaultButtonText");
				let outlineColor = (button.isLocked) ? (button.lockedOutlineColor ?? "defaultButtonLockedOutline") : (button.outlineColor ?? "defaultButtonOutline");
				
				if (text != undefined){
					let textArgs = {
						...button,
						...args,
						textColor: textColor,
						outlineColor: outlineColor,
						textSize: (button.textSize ?? defaultValues.buttonTextSize),
						outlineSize: (button.outlineSize ?? defaultValues.buttonOutlineSize),
						marginY: (button.marginY ?? defaultValues.buttonTextMarginY)
					}
					
					drawText(text, button.pos, textArgs);
					
					if (button.textHoverOverlay && hoverColor != undefined){
						drawText(text, button.pos, {...textArgs, outlineColor: hoverColor, textColor: hoverColor});
					}
				}
				
				//button subtext
				if (button.subtext != undefined){
					button.subtextPos ??= defaultValues.buttonSubtextPos;
					
					let subtextPos = {
						x: button.pos.x + (button.subtextPos.x ?? defaultValues.buttonSubtextPos.x) * button.pos.w,
						y: button.pos.y + (button.subtextPos.y ?? defaultValues.buttonSubtextPos.y) * button.pos.h,
						w: button.pos.w,
						h: button.pos.h
					}
					
					
					let textSize = (button.subtextSize ?? defaultValues.buttonSubtextSize);
					let outlineSize = (button.subtextOutlineSize ?? button.outlineSize) ?? defaultValues.buttonSubtextOutlineSize;
					
					
					drawText(button.subtext, subtextPos, {...args, textSize: textSize, outlineSize: outlineSize, outlineColor: outlineColor, textColor: textColor});
					
					if (button.textHoverOverlay && hoverColor != undefined){
						drawText(button.subtext, subtextPos, {...args, textSize: textSize, outlineSize: outlineSize, outlineColor: hoverColor, textColor: hoverColor});
					}
				}
				
				//button color hover
				if (hoverColor != undefined){
					ctx.fillStyle = colors[hoverColor] ?? hoverColor;
					drawRect(pos, args);
				}
			}
		}
		
		drawLockedButtonText();
	}
	
</script>
<script> //Draw Scrollbars
	
	function scrollHoverNextFrame(){
		if (hoveredScrollbars.gameState != gameState.currentState){
			hoveredScrollbars.gameState = gameState.currentState;
			hoveredScrollbars.arr = {};
		}
		
		let pos = getScrollbarsPos();
		
		let hoveredXY = "";
		
		for (let xy of xyArr){
			if (pos[xy] != undefined){
				if (isScrollbarPosTouchingMouse(pos, xy)){
					if (!(hoveredScrollbars.arr[xy] > hoveredScrollbars.maxSeconds)){
						if (hoveredScrollbars.arr[xy] == undefined){
							hoveredScrollbars.arr[xy] = 0;
						}
						
						hoveredScrollbars.arr[xy] += 1/fps;
						
						hoveredScrollbars.arr[xy] = Math.min(hoveredScrollbars.maxSeconds, hoveredScrollbars.arr[xy]);
						
						hoveredXY = xy;
					}
				}
			}
		}
		
		for (let i in hoveredScrollbars.arr){
			if (hoveredScrollbars.arr[i] > 0 && i != hoveredXY){
				hoveredScrollbars.arr[i] -= 1/fps;
				
				hoveredScrollbars.arr[i] = Math.max(0, hoveredScrollbars.arr[i]);
			}
		}
		
		if (clickedScrollbar.xy != undefined){
			hoveredScrollbars.arr[clickedScrollbar.xy] = hoveredScrollbars.maxSeconds * hoveredScrollbars.clickMultiplier;
		}
	}
	
	
	function getScrollbarsPosDrawSize(pos, xy){
		let currentPos = {...pos[xy]};
		
		let minSize = (scrollbarsMinSize[xy] ?? {})[xyToWH[xy]];
		
		if (minSize != undefined){
			let currentWH = currentPos[xyToWH[xy]];
			
			if (currentWH < minSize){
				let middlePos = currentPos[xy] + currentWH/2;
				
				currentPos[xyToWH[xy]] = minSize;
				currentPos[xy] = middlePos - minSize/2;
			}
		}
		return currentPos;
	}
	
	function drawScrollbars(){
		let pos = getScrollbarsPos();
		
		scrollHoverNextFrame();
		
		let scrollbarDrawOrder = ["w","x","h","y"];
		
		for (let i of scrollbarDrawOrder){
			if (pos[i] != undefined){
				let currentPos = getScrollbarsPosDrawSize(pos, i);
				
				ctx.fillStyle = colors[((i == "x" || i == "y") ? "scrollbar" : "scrollbarBackground")];
				
				drawRect(currentPos, {isAbsolutePositioned: true});
				
				if (hoveredScrollbars.arr[i] > 0){
					let alphaNum = hoveredScrollbars.arr[i] / hoveredScrollbars.maxSeconds;
					
					alphaNum *= hoveredScrollbars.maxAlphaNum;
					
					ctx.fillStyle = colors["scrollbarHover"].replaceAll("{{alphaNum}}", alphaNum);
					
					drawRect(currentPos, {isAbsolutePositioned: true});
				}
			}
		}
	}
	
</script>
<script> //Draw Layers
	
	function drawDrawLayers(){
		for (let i in drawLayers){
			for (let j in drawLayers[i]){
				let arr = drawLayers[i][j];
				
				if (arr.color != undefined){
					ctx[(arr.isFill != false) ? "fillStyle" : "strokeStyle"] = arr.color;
				}
				
				if (typeof(arr.f) == "function"){
					arr.f(...arr.args);
				} else{
					window[arr.f](...arr.args);
				}
			}
		}
		drawLayers = [];
	}
	
</script>

<script> //Draw Call
	
	function drawCall(alwaysDraw){
		if (!cancelNextDrawFrame || alwaysDraw){
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			setDrawStyleToColor(colors.backgroundColor, {isAbsolutePositioned: true});
			
			savedPolygons = {};
			
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			
			
			runEvent(drawOrder);
			
			
			drawDrawLayers();
			
			
			if (isNotesClickable){
				ctx.fillStyle = notesColors[currentNotesColorNum];
				
				let pos = {w: canvas.width * 0.00125, h: canvas.height * 0.0025};
				
				ctx.fillRect(0, 0, canvas.width, pos.h);
				ctx.fillRect(0, canvas.height - pos.h, canvas.width, pos.h);
				ctx.fillRect(0, 0, pos.w, canvas.height);
				ctx.fillRect(canvas.width - pos.w, 0, pos.w, canvas.height);
				
				if (isNotesTextHidden){
					ctx.textAlign = "left";
					ctx.font = "16px " + defaultFont;
					ctx.fillStyle = colors.debugText;
					
					ctx.fillText("*Notes Mode* [Press Tilde to Turn Off]", 10, 20);
				}
			}
		}
		
		cancelNextDrawFrame = false;
	}
	
	function draw(){
		requestAnimationFrame(drawCall);
	}
	
</script>

<script> //Events
	
	function isEvent(name){
		let isTrue = false;
		
		let currentName = name;
		
		if (isObject(name)){
			if (name.f != undefined){
				currentName = name.f;
			}
			if (name.event != undefined){
				currentName = name.event;
			}
		}
		
		if (typeof window[currentName] == "function"){
			isTrue = true;
		}
		if (events[currentName] != undefined){
			isTrue = true;
		}
		
		return isTrue;
	}
	
	function runEvent(eventData, args = {}){
		let eventsArr = eventData;
		
		if (events[eventData] != undefined){
			eventsArr = events[eventData];
		}
		if (eventsArr.f != undefined || eventsArr.event != undefined){
			eventsArr = [eventsArr];
		}
		
		eventsArr = structuredClone(Object.values(eventsArr));
		
		let mostRecentReturn;
		
		for (let i = 0; i < eventsArr.length; i++){
			let name = structuredClone(eventsArr[i]);
			
			
			let currentArr = {args: args};
			if (isObject(name)){ //if value is object (ex: {f: "resetButtons", args: {state: "game"}})
				let arr = structuredClone(name);
				
				arr.args = combineValues(arr.extraArgs ?? {}, arr.args ?? args);
				
				currentArr = arr;
			} else{
				if (window[name] != undefined){ //if value is a function's name
					if (window[name].args != undefined){
						let arr = window[name];
						
						arr.args = combineValues(arr.extraArgs ?? {}, arr.args ?? args);
						
						currentArr = arr;
					} else{
						currentArr = {args: args, f: name};
					}
				}
				if (events[name] != undefined){ //if value is an event's name
					if (events[name].args != undefined){
						let arr = events[name];
						
						arr.args = combineValues(arr.extraArgs ?? {}, arr.args ?? args);
						
						currentArr = arr;
					} else{
						currentArr = {args: args, event: name};
					}
				}
			}
			
			
			if (currentArr.f != undefined){
					if (currentArr.args != undefined){
						currentArr.args = getArrayWithReplacedValues(currentArr.args, currentArr.args);
					}
					name = getArrayWithReplacedValues(name, combineValues(args, currentArr.args));
				let currentReturn = window[currentArr.f](currentArr.args);
				
				mostRecentReturn = currentReturn ?? mostRecentReturn;
			} else if (currentArr.event != undefined){
					if (currentArr.args != undefined){
						currentArr.args = getArrayWithReplacedValues(currentArr.args, currentArr.args);
					}
					name = getArrayWithReplacedValues(name, combineValues(args, currentArr.args));
				let currentReturn = runEvent(currentArr.event, currentArr.args);
				
				mostRecentReturn = currentReturn ?? mostRecentReturn;
			} else{
				let evalArr = [name];
				if (typeof name != "string"){
					evalArr = name;
				}
				
				for (let j in evalArr){
					mostRecentReturn = getEvaluatedText(evalArr[j], false, false, currentArr.args);
				}
			}
			
			if (name.amount > 1){
				for (let j = 1; j < name.amount; j++){
					eventsArr[i].amount = 1;
					
					insertIntoArray(eventsArr, structuredClone(eventsArr[i]), Number(i) + 1);
				}
			}
		}
		
		return mostRecentReturn;
	}
	
	
	function runEventWithDelay(args){
		args = structuredClone(args);
		
		for (let i = 0; i < (args.amount ?? 1); i++){
			delayedEvents.push({
				time: (i + 1) * fps * args.delay + t,
				event: args.event
			});
		}
	}
	
</script>

<script> //Next Frame
	
	let lastFrameTime = getCurrentTime();
	let currentFrameTime = getCurrentTime();
	let wasPreviousCatchUpFrame = false;
	
	function nextFrame(){
		t++;
		
		gamepads = navigator.getGamepads();
		
		scrolledCamera.hasCalculated = false;
		
		refreshButtonPressStates();
		
		for (let i = 0; i < delayedEvents.length; i++){
			if (t >= delayedEvents[i].time){
				runEvent(delayedEvents[i].event);
				
				delayedEvents.splice(i, 1);
				i--;
			}
		}
		
		runEvent("onNextFrame");
		
		if (mouseLockFrames <= 1){
			mouseLockFrames++;
		}
		
		
		currentFrameTime = getCurrentTime();
		
		
		let nextFrameDelay = 1000/fps;
		
		if (!wasPreviousCatchUpFrame){
			nextFrameDelay = (1000/fps * 2) - (currentFrameTime - lastFrameTime);
			
			nextFrameDelay = Math.min(nextFrameDelay, 1);
			
			wasPreviousCatchUpFrame = true;
		} else{
			wasPreviousCatchUpFrame = false;
		}
		
		lastFrameTime = getCurrentTime();
		
		
		setTimeout(nextFrame, nextFrameDelay);
	}
	
</script>
<script> //Initiate Game
	
	function changeValuesByGameData(){
		let arr = gameData[currentGame.currentState];
		
		for (let valueName in arr.overriddenVariables){
			if (window[valueName] != undefined){
				window[valueName] = structuredClone(arr.overriddenVariables[valueName]);
			}
		}
		
		for (let valueName in arr.createdVariables){
			window[valueName] = structuredClone(arr.createdVariables[valueName]);
		}
		
		for (let valueName in arr.modifiedVariables){
			if (window[valueName] != undefined){
				if (isArrayOrObject(arr.modifiedVariables[valueName])){
					window[valueName] = calculateObjectsByOperator(arr.modifiedVariables[valueName], window[valueName]);
				} else{
					window[valueName] = structuredClone(arr.modifiedVariables[valueName]);
				}
			}
		}
	}
	
	function isVariableNew(i){
		let isNew = false;
		
		if (!defaultVariables[i] && i != "defaultVariables"){
			if (window[i] != undefined && window[i] != null){
				if (typeof(window[i]) != "function" && !(window[i] instanceof HTMLCanvasElement) && !(window[i] instanceof CanvasRenderingContext2D)){
					if (i != "originalVariableValues" && i != "gameSaves" && i != "currentGame" && i != "gameData"){
						isNew = true;
					}
				}
			}
		}
		return isNew;
	}
	
	function initiateGame(){
		if (!hasInitiated){
			let currentURL = new URLSearchParams(location.search);
			if (gameData[currentURL.get('game')]){
				currentGame.currentState = currentURL.get('game');
			}
			
			for (let i in window){
				if (isVariableNew(i)){
					originalVariableValues[i] = structuredClone(window[i]);
				}
			}
		} else{
			for (let i in window){
				if (isVariableNew(i)){
					if (originalVariableValues[i] == undefined){
						delete window[i];
					} else{
						window[i] = structuredClone(originalVariableValues[i]);
					}
				}
			}
		}
		
		
		if (gameData[currentGame.currentState] != undefined){
			changeValuesByGameData();
		}
		
		document.getElementById("titleId").innerHTML = "Sover the " + currentGame.currentState;
		
		if (events.onload != undefined){
			runEvent(events.onload);
		}
		
		if (!hasInitiated){
			nextFrame();
		}
		
		hasInitiated = true;
	}
	
	function loadGame(args){
		let previousGameName = currentGame.currentState;
		
		if (gameData[args.gameName] != undefined){
			if ((args.gameName == "Game Selection") ? (confirm("Are you sure you'd like to quit " + previousGameName + "?\n\nYour progress won't be saved (except for high scores).")) : true){
				currentGame.currentState = args.gameName;
				
				initiateGame();
				
				if (args.gameName == "Game Selection"){
					gameState.currentState = "newGames";
					
					selectedGame = previousGameName;
					
					runEvent("gameSelect");
				}
			}
		}
	}
	
</script>

<script> //Notes Canvas
	
	var notesCanvas = document.getElementById("notesCanvasId");
	var notesCtx = notesCanvas.getContext("2d");
	notesCanvas.oncontextmenu = function(){return false;}
	notesCanvas.height = window.innerHeight;
	notesCanvas.width = window.innerWidth;
	
	let isNotesClickable = false;
	let isNotesTextHidden = false;
	
	let notesColors = [colors.enby[3], ...colors.trans.slice(0, 3), ...colors.pan, ...colors.enby];
	let currentNotesColorNum = 0;
	
	function clickNotesCanvas(pos){
		if (currentNotesColorNum >= notesColors.length){
			currentNotesColorNum = 0;
		}
		
		notesCtx.fillStyle = notesColors[currentNotesColorNum];
		
		if (isMouseDown){
			switch (mouseButton){
				case 1:
					notesCtx.fillRect(pos.x, pos.y, 3, 3);
				break;
				case 2:
					notesCanvas.width |= 0;
				break;
			}
		}
	}
	
</script>

<script> //Mouse Wheel (Zoom and Scroll)
	
	function isMovingCamera(){
		return (isMouseDown && mouseButton != 1 && mouseLockFrames > 1 && !isNotesClickable);
	}
	
	function cameraMouseDown(){
		if (camera.state.canMove && camera.state.shouldLockMouse){
			if(notesCanvas.requestPointerLock){
				notesCanvas.requestPointerLock();
			}else {
				notesCanvas.mozRequestPointerLock();
			}
			
			mouseLockFrames = 0;
		}
	}
	
	function cameraMouseUp(){
		if (camera.state.canMove && camera.state.shouldLockMouse){
			if(document.exitPointerLock){
				document.exitPointerLock();
			} else{
				document.mozExitPointerLock();
			}
		}
	}
	
	function cameraMouseMove(event){
		if (camera.state.canMove){
			if (isMovingCamera()){
				let speed = {
					x: event.movementX / canvas.width,
					y: event.movementY / canvas.height
				}
				
				speed.x *= (camera.zoom.min / camera.zoom.level) * camera.zoom.speed;
				speed.y *= (camera.zoom.min / camera.zoom.level) * camera.zoom.speed;
				
				camera.x -= speed.x * camera.speed;
				camera.y -= speed.y * camera.speed;
			}
		}
	}
	
	
	function zoomWheel(event){
		if (camera.state.canZoom){
			let zoom = camera.zoom;
			
			if (zoom.scrollSpeed <= 0 && zoom.scrollbarSpeed > 0){
				let pos = getScrollbarsPos();
				
				for (let xy of xyArr){
					if (pos[xy] != undefined){
						let isShiftDown = (inputs["ShiftLeft"] || inputs["ShiftRight"]);
						
						let shouldScroll = (xy == "x") ? isShiftDown : !isShiftDown;
						
						if (shouldScroll){
							let wh = xyToWH[xy];
							
							pos[xy][xy] += event.deltaY * zoom.scrollbarSpeed * pos[xy][wh];
							
							if (scrolledCameras[gameState.currentState] == undefined){
								scrolledCameras[gameState.currentState] = structuredClone(camera);
							}
							
							scrolledCameras[gameState.currentState][xy] = getCameraPosFromScrollbarPos(pos)[xy];
							
							refreshScrolledCamera(true);
						}
					}
				}
			} else{
				if (event.deltaY >= 0){
					zoom.level *= zoom.scrollSpeed;
				} else{
					zoom.level /= zoom.scrollSpeed;
				}
				
				zoom.level = getNumInRange(zoom.level, zoom.min, zoom.max);
			}
			
			drawCall(true);
		}
	}
	
</script>

<script> //Listeners
	
	//Resize
	
	function onResize(args = {}){
		canvas.height = window.innerHeight;
		canvas.width = window.innerWidth;
		
		notesCanvas.height = window.innerHeight;
		notesCanvas.width = window.innerWidth;
		
		let resetKeys = ["ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight"];
		
		for (let i in resetKeys){
			inputs[resetKeys[i]] = false;
		}
		
		if (args.shouldDraw != false){
			drawCall(true);
		}
	}
	
	window.addEventListener("resize", onResize);
	
	
	//Inputs
	
	let inputs = []; //ex: inputs.KeyW
	
	function setKeyDown(e){
		e = e || window.event;
		inputs[e.code] = true;
		
		if (e.code == "Backquote"){
			isNotesClickable = !isNotesClickable;
		}
		if (e.code.includes("Digit")){
			currentNotesColorNum = e.code[5];
		}
		
		if (scrolledCameras[gameState.currentState] != undefined){
			if (e.code == "ArrowUp"){ scrolledCameras[gameState.currentState].y += scrollbarStep.y; }
			if (e.code == "ArrowDown"){ scrolledCameras[gameState.currentState].y -= scrollbarStep.y; }
			if (e.code == "ArrowLeft"){ scrolledCameras[gameState.currentState].x += scrollbarStep.x; }
			if (e.code == "ArrowRight"){ scrolledCameras[gameState.currentState].x -= scrollbarStep.x; }
		}
	}
	
	function setKeyUp(e){
		e = e || window.event;
		inputs[e.code] = false;
	}
	
	document.onkeydown = setKeyDown;
	document.onkeyup = setKeyUp;
	
	
	//Mouse
	
	function onMouseDown(event){
		setMousePos(notesCanvas, event);
		
		isMouseDown = true;
		mouseButton = event.buttons;
		
		if (isNotesClickable){
			clickNotesCanvas(mousePos);
		} else{
			if (mouseButton != 1){
				cameraMouseDown();
			}
			
			if ((shouldEditPolygons || shouldClickPolygons) && mouseButton == 1){
				savedPolygonsClick();
			}
			
			if (clickedPolygonVertex.i == -1){
				let scrollbarsPos = getScrollbarsPos();
				let isScrollbarBoxClicked = false;
				
				if (scrollbarsPos.w != undefined){
					isScrollbarBoxClicked = isVertexInRect(mousePosRatio, scrollbarsPos.w) || isScrollbarBoxClicked;
				}
				if (scrollbarsPos.h != undefined){
					isScrollbarBoxClicked = isVertexInRect(mousePosRatio, scrollbarsPos.h) || isScrollbarBoxClicked;
				}
				
				if (mouseButton == 1){
					scrollbarsClick(true);
					
					if (!isScrollbarBoxClicked){
						buttonsClick(true);
					}
					
					if (isScrollbarBoxClicked || clickedButton.i != ""){
						clickedPolygons = [];
					}
				} else{
					clickedScrollbar = {xy: "", clickedPos: {x: 0, y: 0}};
					clickedButton = {i: "", j: 0};
					
					buttonsClick(false, true);
				}
				
				if (!isScrollbarBoxClicked && clickedButton.i == "" && !closestButton.isHover){
					gridClick({isDown: true, mouseButton: mouseButton});
				}
			}
		}
	}
	
	function onMouseUp(event){
		setMousePos(notesCanvas, event);
		
		isMouseDown = false;
		
		if (isNotesClickable){
			
		} else{
			let wasButtonHover = closestButton.isHover
			
			scrollbarsClick(false);
			buttonsClick(false);
			
			if (!closestButton.isHover && !wasButtonHover){
				gridClick({isDown: false, isUp: true, mouseButton: mouseButton});
			}
			
			if (clickedPolygons.length > 0){
				savedPolygonsClick(false);
			}
		}
		
		clickedScrollbar = {xy: "", clickedPos: {x: 0, y: 0}};
		clickedButton = {i: "", j: 0};
		clickedPolygonVertex = {i: -1, layer: "", j: -1, type: ""};
		
		cameraMouseUp();
	}
	
	function onMouseMove(event){
		setMousePos(notesCanvas, event);
		
		let directions = getVertexToVertexDirection(mousePos, lastMousePos);
		let distance = getVertexDistance(mousePos, lastMousePos);
		
		if (isMovingCamera()){
			cameraMouseMove(event);
		} else{
			if (clickedPolygonVertex.i == -1){
				for (let i = 0; i < distance; i+=1){
					let currentPos = {
						x: mousePos.x + i * directions.x,
						y: mousePos.y + i * directions.y
					};
					
					if (isNotesClickable){
						clickNotesCanvas(currentPos);
					} else{
						//mouse move outside of notes
						scrollbarsClick(false, true);
						
						if (clickedScrollbar.xy == ""){
							buttonsClick(false, true);
							
							if (!closestButton.isHover){
								gridClick({isDown: false, mouseButton: mouseButton});
							}
						}
					}
				}
			} else{
				savedPolygonsMove();
			}
		}
	}
	
	
	function setMousePos(c, event){
		let rect = c.getBoundingClientRect();
		
		lastMousePos = mousePos;
		lastMousePosRatio = mousePosRatio;
		lastScaledMousePos = scaledMousePos;
		
		mousePos = {
			x: event.clientX - rect.left,
			y: event.clientY - rect.top
		};
		
		mousePosRatio = {x: mousePos.x / c.width, y: mousePos.y / c.height};
		
		scaledMousePos = getScaledPositionInverted(mousePos);
	}
	
	notesCanvas.addEventListener("mousedown", onMouseDown);
	notesCanvas.addEventListener("mouseup", onMouseUp);
	notesCanvas.addEventListener('mousemove',onMouseMove);
	notesCanvas.addEventListener('wheel', zoomWheel, {passive: true});
	
</script>

<script> //LocalStorage Save
	
	var savedData = localStorage.getItem("soverthe.saves");
	
	function refreshSaves(){
		try {
			savedData = JSON.parse(savedData);
		} catch (e){
			savedData = {};
		}
		
		if (!isObject(savedData)){
			savedData = {};
		}
		
		for (let i in gameSaves){
			if (savedData[i] != undefined){
				gameSaves[i].score = savedData[i];
			} else{
				savedData[i] = gameSaves[i].score;
			}
		}
		
		localStorage.setItem('soverthe.saves', JSON.stringify(savedData));
	}
	refreshSaves();
	
	function saveCurrentGameScore(score, type){
		gameSaves[currentGame.currentState] ??= {};
		
		let arr = gameSaves[currentGame.currentState];
		
		if (type != undefined){
			arr.score[type] ??= score;
			
			if (arr.score[type] == null || arr.trophies == undefined){
				arr.score[type] = score;
			} else{
				if (arr.trophies.mode == "less"){
					arr.score[type] = Math.min(score, arr.score[type]);
				} else{
					arr.score[type] = Math.max(score, arr.score[type]);
				}
			}
		} else{
			if (arr.score == null || arr.trophies == undefined){
				arr.score = score;
			} else{
				if (arr.trophies.mode == "less"){
					arr.score = Math.min(score, arr.score);
				} else{
					arr.score = Math.max(score, arr.score);
				}
			}
		}
		
		gameSaves[currentGame.currentState] = arr;
		
		refreshSaves();
	}
	
</script>
<script> //Browser Check
	
	function refreshBrowserName(){ //https://stackoverflow.com/a/13348618
		let winNav = window.navigator;
		let vendorName = winNav.vendor;

		let isChromium = window.chrome;
		let isOpera = typeof window.opr !== "undefined";
		let isFirefox = winNav.userAgent.indexOf("Firefox") > -1;
		let isIEedge = winNav.userAgent.indexOf("Edg") > -1;
		let isIOSChrome = winNav.userAgent.match("CriOS");
		let isGoogleChrome = isChromium !== null
			&& typeof isChromium !== "undefined"
			&& vendorName === "Google Inc."
			&& isOpera === false
			&& isIEedge === false
			&& (typeof winNav.userAgentData === "undefined" || winNav.userAgentData.brands.some(x => x.brand === "Google Chrome"));
		
		browserName = "Other";
		
		if (isChromium){ browserName = "Other Chromium"; }
		if (isOpera){ browserName = "Opera"; }
		if (isFirefox){ browserName = "Firefox"; }
		if (isIEedge){ browserName = "Edge"; }
		if (isIOSChrome){ browserName = "CriOS"; }
		if (isGoogleChrome){ browserName = "Chrome"; }
	}
	
</script>
<script> //Close Confirmation
	
	if (shouldConfirmBeforeClosing){
		window.onbeforeunload = function(e) {
			return "";
		};
	}
	
</script>

<script> //Calls
	refreshBrowserName();
	
	onResize({shouldDraw: false});
	
	initiateGame();
</script>
</body>
</html>